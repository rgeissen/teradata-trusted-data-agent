2025-08-21 22:45:30,687 - --- FULL CONTEXT (Session: df7e1f03-2ba5-457e-8b31-1a09c2af00c6) ---
--- REASON FOR CALL ---
Generating a strategic meta-plan for the goal: 'what is the system utilization of the past 3 days?...'

--- History ---
[user]: You are a helpful assistant.
[model]: Understood.

--- Current User Prompt (with System Prompt) ---
SYSTEM PROMPT:

# Core Directives
You are a specialized assistant for a Teradata database system. Your primary goal is to fulfill user requests by selecting the best capability (a tool or a prompt) from the categorized lists provided and supplying all necessary arguments.

# Response Format
Your response MUST be a single JSON object for a tool/prompt call OR a single plain text string for a final answer.

1.  **Tool/Prompt Calls (JSON format):**
    -   If the capability is a prompt, you MUST use the key `"prompt_name"`.
    -   If the capability is a tool, you MUST use the key `"tool_name"`.
    -   Provide all required arguments. Infer values from the conversation history if necessary.
    -   Example (Prompt): `{"prompt_name": "some_prompt", "arguments": {"arg": "value"}}`
    -   Example (Tool): `{"tool_name": "some_tool", "arguments": {"arg": "value"}}`

2.  **Final Answer (Plain Text format):**
    -   When you have sufficient information to fully answer the user's request, you MUST stop using tools.
    -   Your response MUST begin with the exact prefix `FINAL_ANSWER:`, followed by a natural language summary.
    -   Example: `FINAL_ANSWER: I found 48 databases on the system. The details are displayed below.`

# Decision Process
To select the correct capability, you MUST follow this two-step process, governed by one critical rule:

**CRITICAL RULE: Prioritize Specificity and Arguments.** Your primary filter for selecting a capability is its specificity. You MUST select the most granular capability that uses the most entities from the user's request (e.g., prefer a tool that uses a `table_name` over one that only uses a `database_name` if a table is mentioned). For direct actions and single analyses, you MUST select a `tool_name`; only select a `prompt_name` for broad, multi-step tasks explicitly described by the prompt.

1.  **Identify the Category:** First, analyze the user's request to determine which Tool or Prompt Category is the most relevant to their intent. The available categories are listed in the "Capabilities" section below.
2.  **Select the Capability:** Second, from within that single most relevant category, select the best tool or prompt to fulfill the request, adhering to the Critical Rule above.

# Few-Shot Examples
Here are examples of the correct thinking process:

**Example 1:**
- **User Query:** "what is the quality of table 'online' in database 'DEMO_Customer360_db'?"
- **Thought Process:**
    1.  The user's query is about a **table**.
    2.  My critical rule is to prioritize specificity. I must choose a table-level tool.
    3.  The `qlty_databaseQuality` prompt is for databases, not specific tables, so it's incorrect.
    4.  The `qlty_columnSummary` tool takes a `table_name` and is the most specific, correct choice.
- **Correct Response:** `{"tool_name": "qlty_columnSummary", "arguments": {"database_name": "DEMO_Customer360_db", "table_name": "online"}}`

**Example 2:**
- **User Query:** "describe the business purpose of the 'DEMO_Customer360_db' database"
- **Thought Process:**
    1.  The user's query is about a **database**. It's a broad request ("describe").
    2.  A prompt is better for broad tasks.
    3.  The `base_databaseBusinessDesc` prompt takes a `database_name` and is the correct choice.
- **Correct Response:** `{"prompt_name": "base_databaseBusinessDesc", "arguments": {"database_name": "DEMO_Customer360_db"}}`

**Example 3:**
- **User Query:** "what is the system utilization?"
- **Thought Process:**
    1.  The user is asking for a specific metric: "system utilization". This is a direct request for data.
    2.  My critical rule states I must prioritize a `tool_name` for direct actions.
    3.  The `dba_systemVoice` prompt is for adopting a persona, not for fetching specific metrics. It is the incorrect choice.
    4.  The `dba_resusageSummary` tool in the `Performance` category is designed to get system usage summary metrics. This is the correct choice.
- **Correct Response:** `{"tool_name": "dba_resusageSummary", "arguments": {}}`

# Best Practices
- **Context is Key:** Always use information from previous turns to fill in arguments like `db_name` or `table_name`.
- **Error Recovery:** If a tool fails, analyze the error message and attempt to call the tool again with corrected parameters. Only ask the user for clarification if you cannot recover.
- **SQL Generation:** When using the `base_readQuery` tool, you MUST use fully qualified table names in your SQL (e.g., `SELECT ... FROM my_database.my_table`).
- **Time-Sensitive Queries:** For queries involving relative dates (e.g., 'today', 'this week'), you MUST use the `util_getCurrentDate` tool first to determine the current date before proceeding.
- **Out of Scope:** If the user's request is unrelated to the available capabilities, respond with a `FINAL_ANSWER:` that politely explains you cannot fulfill the request and restates your purpose.
- **CRITICAL: Avoid Repetitive Behavior.** You are a highly intelligent agent. Do not get stuck in a loop by repeating the same tool calls or by cycling through the same set of tools. Once a tool has returned a successful result with data that is relevant to the user's request, do not call that same tool again unless there is a new and compelling reason to do so. If you have called a series of tools and believe you have enough information, you must call a FINAL_ANSWER. Do not repeat tool calls just to be "through".


# Capabilities
--- Available Tools ---
--- Category: Data Quality ---
- `qlty_columnSummary` (tool): 
Get the column summary statistics for a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_distinctCategories` (tool): 
Get the destinct categories from column in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_missingValues` (tool): 
Get the column names that having missing values in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_negativeValues` (tool): 
Get the column names that having negative values in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_rowsWithMissingValues` (tool): 
Get the rows with missing values in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_standardDeviation` (tool): 
Get the standard deviation from column in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_univariateStatistics` (tool): 
Get the univariate statistics for a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

--- Category: Data Visualization ---
- `viz_createChart` (tool): Generates a data visualization based on provided data. You must specify the chart type and map the data fields to the appropriate visual roles.
  - Arguments:
    - `chart_type` (string, required): The type of chart to generate (e.g., 'bar', 'pie', 'line', 'scatter'). This MUST be one of the types listed in the 'Charting Guidelines'.
    - `data` (list[dict], required): The data to be visualized, passed directly from the output of another tool.
    - `title` (string, required): A descriptive title for the chart.
    - `mapping` (dict, required): A dictionary that maps data keys to chart axes or roles (e.g., {'x_axis': 'product_name', 'y_axis': 'sales_total'}). The required keys for this mapping depend on the selected chart_type.
--- Category: Database Information ---
- `cust_td_serverInfo` (tool): Get the Teradata software information: demonstrates how to use parameters for prepared statements.
  - Arguments:
    - `infokey` (string, optional): No description.
- `dba_databaseVersion` (tool):  Get Teradata database version information.
- `base_databaseList` (tool): Lists all databases in the Teradata System.
--- Category: Database Space ---
- `dba_databaseSpace` (tool): 
Get database space if database name is provided, otherwise get all databases space allocations.

Arguments:
  database_name - database name

Returns:
  ResponseType: formatted response with query results + metadata

- `get_cube_cust_cube_db_space_metrics` (tool): 
    Tool to query the cube 'table_skew_pct'.
    Get the Teradata database space metrics for tables and databases

    Expected inputs:
        dimensions (str): Comma-separated dimension names to group by. Allowed values:
    - DatabaseName: Name of the database
    - TableName: Name of the table

        measures (str): Comma-separated measure names to aggregate. Allowed values:
    - current_perm: Object perm space in bytes
    - peak_perm: Object peak perm space in bytes
    - table_skew_pct: Object skew percentage

        filters (str): Comma-separated filter expressions to apply to either dimensions or measures selected. The dimension or measure used must be in the dimension list to group by or measure list, use valid SQL expressions, for example:
DatabaseName = 'value'
TableName = 'value'
current_perm > 1000
peak_perm > 1000
table_skew_pct > 1000

    Returns:
        Query result as a formatted response.
    
  - Arguments:
    - `dimensions` (string, optional): No description.
    - `measures` (string, optional): No description.
    - `filters` (string, optional): No description.
- `dba_systemSpace` (tool): Get the Teradata total system database space usage.
--- Category: Performance ---
- `dba_resusageSummary` (tool): 
Get the Teradata system usage summary metrics by weekday and hour for each workload type and query complexity bucket.

Arguments:
  dimensions - list of dimensions to aggregate the resource usage summary. All dimensions are: ["LogDate", "hourOfDay", "dayOfWeek", "workloadType", "workloadComplexity", "UserName", "AppId", "StatementType"]
  user_name - user name
  date - Date to analyze, formatted as `YYYY-MM-DD`
  dayOfWeek - day of the week to analyze
  hourOfDay - hour of day to analyze


- `dba_flowControl` (tool): Get the Teradata flow control metrics for a specified date range.
  - Arguments:
    - `start_date` (string, optional): No description.
    - `end_date` (string, optional): No description.
- `dba_userDelay` (tool): Get the Teradata user delay metrics for a specified date range.
  - Arguments:
    - `start_date` (string, optional): No description.
    - `end_date` (string, optional): No description.
--- Category: Query Execution ---
- `base_readQuery` (tool): 
Execute a SQL query via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  sql    - SQL text, with optional bind-parameter placeholders

Returns:
  ResponseType: formatted response with query results + metadata

--- Category: Sales Analytics ---
- `sales_top_customers` (tool): Get the top 20 customers by lifetime value.
- `sales_customer_profile` (tool): Get customer profile and metrics.
  - Arguments:
    - `customer_key` (string, optional): No description.
- `get_cube_sales_cube` (tool): 
    Tool to query the cube 'order_count'.
    Get the key sales metrics: USD amount and number of orders.

    Expected inputs:
        dimensions (str): Comma-separated dimension names to group by. Allowed values:
    - customer_key: Key for the customer
    - sales_year: Year of the sale
    - sales_month: Month of the sale

        measures (str): Comma-separated measure names to aggregate. Allowed values:
    - gift_amount_usd: Total gift card amount used for the order in USD
    - total_amount_usd: Total order amount in USD
    - order_count: Total number of orders

        filters (str): Comma-separated filter expressions to apply to either dimensions or measures selected. The dimension or measure used must be in the dimension list to group by or measure list, use valid SQL expressions, for example:
customer_key = 'value'
sales_year = 'value'
sales_month = 'value'
gift_amount_usd > 1000
total_amount_usd > 1000
order_count > 1000

    Returns:
        Query result as a formatted response.
    
  - Arguments:
    - `dimensions` (string, optional): No description.
    - `measures` (string, optional): No description.
    - `filters` (string, optional): No description.
--- Category: Security ---
- `sec_rolePermissions` (tool): 
Get permissions for a role.

Arguments:
  role_name - role name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `sec_userDbPermissions` (tool): 
Get permissions for a user.

Arguments:
  user_name - user name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `sec_userRoles` (tool): 
Get roles assigned to a user.

Arguments:
  user_name - user name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

--- Category: Session Management ---
- `dba_sessionInfo` (tool): Get the Teradata session information for user.
  - Arguments:
    - `user_name` (string, optional): No description.
--- Category: Table Management ---
- `dba_tableSpace` (tool): 
Get table space used for a table if table name is provided or get table space for all tables in a database if a database name is provided."

Arguments:
  database_name - database name
  table_name - table name

Returns:
  ResponseType: formatted response with query results + metadata

- `dba_tableSqlList` (tool): 
Get a list of SQL run against a table in the last number of days.

Arguments:
  table_name - table name
  no_days - number of days

Returns:
  ResponseType: formatted response with query results + metadata

- `dba_tableUsageImpact` (tool): 
Measure the usage of a table and views by users, this is helpful to understand what user and tables are driving most resource usage at any point in time.

Arguments:
  database_name - database name to analyze
  user_name - user name to analyze


- `base_columnDescription` (tool): 
Shows detailed column information about a database table via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name
  obj_name - table or view name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableAffinity` (tool): 
Get tables commonly used together by database users, this is helpful to infer relationships between tables via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name
  object_name - table or view name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableDDL` (tool): 
Displays the DDL definition of a table via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name
  table_name - table name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tablePreview` (tool): 
This function returns data sample and inferred structure from a database table or view via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  table_name - table or view name
  database_name - Database name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableUsage` (tool): 
Measure the usage of a table and views by users in a given schema, this is helpful to infer what database objects are most actively used or drive most value via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableList` (tool): Lists all tables in a database.
  - Arguments:
    - `database_name` (string, optional): No description.
--- Category: Usage Tracking ---
- `dba_featureUsage` (tool): Get the user feature usage metrics for a specified date range.
  - Arguments:
    - `start_date` (string, optional): No description.
    - `end_date` (string, optional): No description.
--- Category: User Management ---
- `dba_userSqlList` (tool): 
Get a list of SQL run by a user in the last number of days if a user name is provided, otherwise get list of all SQL in the last number of days.

Arguments:
  user_name - user name
  no_days - number of days

Returns:
  ResponseType: formatted response with query results + metadata

- `cust_activeUsers` (tool): Fetch currently active database users
--- Category: Utilities ---
- `tmpl_nameOfTool` (tool): 
<description of what the tool is for>

Arguments:
  arguments - arguments to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `evs_similarity_search` (tool): 
Enterprise Vector Store similarity search

Arguments:
  question - the query string to search for
  top_k - number of top results to return

Returns:
  ResponseType: formatted response with query results + metadata

- `rag_executeWorkflow` (tool): 
Execute complete RAG workflow to answer user questions based on document context.


This function handles the entire RAG pipeline:
1. Configuration setup (using configurable values from rag_config.yml)
2. Store user query (with /rag prefix stripping)
3. Generate query embeddings (tokenization + embedding)
4. Perform semantic search against chunk embeddings
5. Return retrieved context chunks for answer generation

The function uses configuration values from rag_config.yml with fallback defaults.

Arguments:
  question - user question to process
  k - number of top-k results to return (optional, uses config default if not provided)

Returns:
  Returns the top-k most relevant chunks with metadata for context-grounded answer generation.

- `rag_executeWorkflow_ivsm` (tool): 
Execute complete RAG workflow to answer user questions based on document context.

This function handles the entire RAG pipeline using IVSM functions:
1. Configuration setup (using configurable values from rag_config.yml)
2. Store user query (with /rag prefix stripping)
3. Tokenize query using ivsm.tokenizer_encode
4. Create embedding view using ivsm.IVSM_score
5. Convert embeddings to vector columns using ivsm.vector_to_columns
6. Perform semantic search against chunk embeddings

The function uses configuration values from rag_config.yml with fallback defaults.

Arguments:
  question - user question to process
  k - number of top-k results to return (optional, uses config default if not provided

Returns:
  Returns the top-k most relevant chunks with metadata for context-grounded answer generation.

- `util_getCurrentDate` (tool): Returns the current system date in YYYY-MM-DD format. Use this as the first step for any user query involving relative dates like 'today', 'yesterday', or 'this week'.
- `util_calculateDateRange` (tool): Calculates a list of dates based on a start date and a natural language phrase (e.g., 'past 3 days', 'last week'). This is a necessary second step for multi-day queries.
  - Arguments:
    - `start_date` (string, required): The anchor date for the calculation, usually today's date from `util_getCurrentDate`. Must be in YYYY-MM-DD format.
    - `date_phrase` (string, required): The natural language phrase describing the desired range (e.g., 'past 3 days', 'last 2 weeks').
- `CoreLLMTask` (tool): Performs internal, LLM-driven tasks that are not direct calls to the Teradata database. This tool is used for text synthesis, summarization, and formatting based on a specific 'task_description' provided by the LLM itself.
  - Arguments:
    - `task_description` (string, required): A natural language description of the internal task to be executed (e.g., 'describe the table in a business context', 'format final output'). The LLM infers this from the workflow plan.
    - `source_data` (list[string], required): A list of keys (e.g., 'result_of_phase_1') identifying which data from the workflow history is relevant for this task. This is critical for providing the correct context.
--- Available Prompts ---
--- Category: Prompts ---
- `base_query` (prompt): Help users interact with  Teradata databases effectively.
  - Arguments:
    - `query` (str, required): The problem or question that needs to be solved using Teradata database tools.
- `base_tableBusinessDesc` (prompt): You are a Teradata DBA who is an expert in describing the business use of tables in a database.
  - Arguments:
    - `database_name` (str, required): Database for the table to describe.
    - `table_name` (str, required): Table to describe.


USER PROMPT:

You are an expert strategic planning assistant. Your task is to analyze a user's request or a complex workflow goal and decompose it into a high-level, phased meta-plan. This plan will serve as a state machine executor.

--- GOAL ---
what is the system utilization of the past 3 days?

--- CONTEXT ---
- User's Original Question (for reference): what is the system utilization of the past 3 days?

--- INSTRUCTIONS ---
1.  **Analyze the Goal**: Carefully read the "GOAL" to understand the user's full intent.
2.  **Decompose into Phases**: Break down the overall goal into a sequence of logical phases. Each phase should represent a major step.
3.  **Define Each Phase**: For each phase, create a JSON object with the following keys:
    -   `"phase"`: An integer representing the step number (e.g., 1, 2, 3).
    -   `"goal"`: A clear, concise, and actionable description of what must be accomplished in this phase. This goal will guide a separate, tactical LLM.
    -   `"relevant_tools"`: A list of tool names that are permitted to be used during this phase. You MUST select the most appropriate and specific tools from the full "Capabilities" list provided in the main system prompt to achieve the phase's goal.
    -   (Optional) `"type": "loop"`: If a phase requires iterating over a list of items, you MUST include this key.
    -   (Optional) `"loop_over"`: If `"type"` is `"loop"`, specify the data source for the iteration (e.g., `"result_of_phase_1"`).
4.  **Embed Parameters**: When defining the `"goal"` for a phase, you MUST scan the main "GOAL" for any hardcoded arguments or parameters (e.g., table names, database names) relevant to that phase's task. You MUST embed these found parameters directly into the `"goal"` string to make it self-contained and explicit.
5.  **Final Synthesis and Formatting Phase**: If the main "GOAL" describes a multi-step process with a final reporting requirement, your plan **MUST** conclude with a single, final phase that handles both the synthesis of the final report AND its formatting. The `relevant_tools` for this final phase **MUST** be `["CoreLLMTask"]`.
6.  **CRITICAL RULE (Simplicity)**: If the "GOAL" is a simple, direct request that can be answered with a single tool call (e.g., "list all databases", "what is the system utilization?"), your plan **MUST** consist of only a single phase that calls the one most appropriate tool. Do not add unnecessary synthesis phases for simple data retrieval.
7.  **CRITICAL RULE (Execution Focus)**: Every phase you define **MUST** correspond to a concrete, tool-based action. You **MUST NOT** create phases for simple verification, confirmation, or acknowledgement of known information. Your plan must focus only on the execution steps required to gather new information or process existing data.
8.  **CRITICAL RULE (Capability Types)**: You are generating a plan of executable **tools**. The `relevant_tools` list **MUST ONLY** contain names of capabilities that are explicitly marked as `(tool)` in the system's "Capabilities" list. You **MUST NOT** include the name of any capability marked as `(prompt)`.
9.  **CRITICAL RULE (Efficiency)**: If a phase's `"goal"` already contains all the instructions for the final synthesis and formatting of the report (as specified in the main "GOAL"), you **MUST** make this the last phase of the plan. Do not add a separate, redundant formatting-only phase after it.

--- EXAMPLE (Complex Goal) ---
If the main goal requires getting DDL and then describing/formatting, your output should be a two-phase plan like this:
```json
[
  {
    "phase": 1,
    "goal": "Get the DDL for the table 'customers' in database 'sales' using the `base_tableDDL` tool.",
    "relevant_tools": ["base_tableDDL"]
  },
  {
    "phase": 2,
    "goal": "Synthesize a final report by describing the 'customers' table in a business context and format the output as markdown according to the Final output guidelines, using `***` for keys.",
    "relevant_tools": ["CoreLLMTask"]
  }
]
```

--- EXAMPLE (Simple Goal) ---
If the main goal is "what is the system utilization?", your output should be a single-phase plan like this:
```json
[
  {
    "phase": 1,
    "goal": "Get the system utilization using the `dba_resusageSummary` tool.",
    "relevant_tools": ["dba_resusageSummary"]
  }
]
```

--- EXAMPLE (Date Range Goal) ---
If the main goal is "what is the system utilization for the past 3 days?", your output must be a three-phase plan like this:
```json
[
  {
    "phase": 1,
    "goal": "Get the current date using the `util_getCurrentDate` tool to establish a reference point.",
    "relevant_tools": ["util_getCurrentDate"]
  },
  {
    "phase": 2,
    "goal": "Calculate the list of dates for 'the past 3 days' using the `util_calculateDateRange` tool.",
    "relevant_tools": ["util_calculateDateRange"]
  },
  {
    "phase": 3,
    "goal": "For each date calculated in the previous step, get the system utilization using the `dba_resusageSummary` tool.",
    "relevant_tools": ["dba_resusageSummary"],
    "type": "loop",
    "loop_over": "result_of_phase_2"
  }
]
```

Your response MUST be a single, valid JSON list of phase objects. Do NOT add any extra text, conversation, or markdown.


2025-08-21 22:45:30,688 - --- RESPONSE ---
```json
[
  {
    "phase": 1,
    "goal": "Get the current date using the `util_getCurrentDate` tool to establish a reference point.",
    "relevant_tools": ["util_getCurrentDate"]
  },
  {
    "phase": 2,
    "goal": "Calculate the list of dates for 'past 3 days' using the `util_calculateDateRange` tool.",
    "relevant_tools": ["util_calculateDateRange"]
  },
  {
    "phase": 3,
    "goal": "For each date calculated in the previous step, get the system utilization using the `dba_resusageSummary` tool.",
    "relevant_tools": ["dba_resusageSummary"],
    "type": "loop",
    "loop_over": "result_of_phase_2"
  }
]
```
--------------------------------------------------

2025-08-21 22:45:31,238 - --- FULL CONTEXT (Session: df7e1f03-2ba5-457e-8b31-1a09c2af00c6) ---
--- REASON FOR CALL ---
Deciding next tactical action for phase: Get the current date using the `util_getCurrentDate` tool to establish a reference point.

--- History ---
[user]: You are a helpful assistant.
[model]: Understood.
[user]: SYSTEM PROMPT:

# Core Directives
You are a specialized assistant for a Teradata database system. Your primary goal is to fulfill user requests by selecting the best capability (a tool or a prompt) from the categorized lists provided and supplying all necessary arguments.

# Response Format
Your response MUST be a single JSON object for a tool/prompt call OR a single plain text string for a final answer.

1.  **Tool/Prompt Calls (JSON format):**
    -   If the capability is a prompt, you MUST use the key `"prompt_name"`.
    -   If the capability is a tool, you MUST use the key `"tool_name"`.
    -   Provide all required arguments. Infer values from the conversation history if necessary.
    -   Example (Prompt): `{"prompt_name": "some_prompt", "arguments": {"arg": "value"}}`
    -   Example (Tool): `{"tool_name": "some_tool", "arguments": {"arg": "value"}}`

2.  **Final Answer (Plain Text format):**
    -   When you have sufficient information to fully answer the user's request, you MUST stop using tools.
    -   Your response MUST begin with the exact prefix `FINAL_ANSWER:`, followed by a natural language summary.
    -   Example: `FINAL_ANSWER: I found 48 databases on the system. The details are displayed below.`

# Decision Process
To select the correct capability, you MUST follow this two-step process, governed by one critical rule:

**CRITICAL RULE: Prioritize Specificity and Arguments.** Your primary filter for selecting a capability is its specificity. You MUST select the most granular capability that uses the most entities from the user's request (e.g., prefer a tool that uses a `table_name` over one that only uses a `database_name` if a table is mentioned). For direct actions and single analyses, you MUST select a `tool_name`; only select a `prompt_name` for broad, multi-step tasks explicitly described by the prompt.

1.  **Identify the Category:** First, analyze the user's request to determine which Tool or Prompt Category is the most relevant to their intent. The available categories are listed in the "Capabilities" section below.
2.  **Select the Capability:** Second, from within that single most relevant category, select the best tool or prompt to fulfill the request, adhering to the Critical Rule above.

# Few-Shot Examples
Here are examples of the correct thinking process:

**Example 1:**
- **User Query:** "what is the quality of table 'online' in database 'DEMO_Customer360_db'?"
- **Thought Process:**
    1.  The user's query is about a **table**.
    2.  My critical rule is to prioritize specificity. I must choose a table-level tool.
    3.  The `qlty_databaseQuality` prompt is for databases, not specific tables, so it's incorrect.
    4.  The `qlty_columnSummary` tool takes a `table_name` and is the most specific, correct choice.
- **Correct Response:** `{"tool_name": "qlty_columnSummary", "arguments": {"database_name": "DEMO_Customer360_db", "table_name": "online"}}`

**Example 2:**
- **User Query:** "describe the business purpose of the 'DEMO_Customer360_db' database"
- **Thought Process:**
    1.  The user's query is about a **database**. It's a broad request ("describe").
    2.  A prompt is better for broad tasks.
    3.  The `base_databaseBusinessDesc` prompt takes a `database_name` and is the correct choice.
- **Correct Response:** `{"prompt_name": "base_databaseBusinessDesc", "arguments": {"database_name": "DEMO_Customer360_db"}}`

**Example 3:**
- **User Query:** "what is the system utilization?"
- **Thought Process:**
    1.  The user is asking for a specific metric: "system utilization". This is a direct request for data.
    2.  My critical rule states I must prioritize a `tool_name` for direct actions.
    3.  The `dba_systemVoice` prompt is for adopting a persona, not for fetching specific metrics. It is the incorrect choice.
    4.  The `dba_resusageSummary` tool in the `Performance` category is designed to get system usage summary metrics. This is the correct choice.
- **Correct Response:** `{"tool_name": "dba_resusageSummary", "arguments": {}}`

# Best Practices
- **Context is Key:** Always use information from previous turns to fill in arguments like `db_name` or `table_name`.
- **Error Recovery:** If a tool fails, analyze the error message and attempt to call the tool again with corrected parameters. Only ask the user for clarification if you cannot recover.
- **SQL Generation:** When using the `base_readQuery` tool, you MUST use fully qualified table names in your SQL (e.g., `SELECT ... FROM my_database.my_table`).
- **Time-Sensitive Queries:** For queries involving relative dates (e.g., 'today', 'this week'), you MUST use the `util_getCurrentDate` tool first to determine the current date before proceeding.
- **Out of Scope:** If the user's request is unrelated to the available capabilities, respond with a `FINAL_ANSWER:` that politely explains you cannot fulfill the request and restates your purpose.
- **CRITICAL: Avoid Repetitive Behavior.** You are a highly intelligent agent. Do not get stuck in a loop by repeating the same tool calls or by cycling through the same set of tools. Once a tool has returned a successful result with data that is relevant to the user's request, do not call that same tool again unless there is a new and compelling reason to do so. If you have called a series of tools and believe you have enough information, you must call a FINAL_ANSWER. Do not repeat tool calls just to be "through".


# Capabilities
--- Available Tools ---
--- Category: Data Quality ---
- `qlty_columnSummary` (tool): 
Get the column summary statistics for a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_distinctCategories` (tool): 
Get the destinct categories from column in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_missingValues` (tool): 
Get the column names that having missing values in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_negativeValues` (tool): 
Get the column names that having negative values in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_rowsWithMissingValues` (tool): 
Get the rows with missing values in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_standardDeviation` (tool): 
Get the standard deviation from column in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_univariateStatistics` (tool): 
Get the univariate statistics for a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

--- Category: Data Visualization ---
- `viz_createChart` (tool): Generates a data visualization based on provided data. You must specify the chart type and map the data fields to the appropriate visual roles.
  - Arguments:
    - `chart_type` (string, required): The type of chart to generate (e.g., 'bar', 'pie', 'line', 'scatter'). This MUST be one of the types listed in the 'Charting Guidelines'.
    - `data` (list[dict], required): The data to be visualized, passed directly from the output of another tool.
    - `title` (string, required): A descriptive title for the chart.
    - `mapping` (dict, required): A dictionary that maps data keys to chart axes or roles (e.g., {'x_axis': 'product_name', 'y_axis': 'sales_total'}). The required keys for this mapping depend on the selected chart_type.
--- Category: Database Information ---
- `cust_td_serverInfo` (tool): Get the Teradata software information: demonstrates how to use parameters for prepared statements.
  - Arguments:
    - `infokey` (string, optional): No description.
- `dba_databaseVersion` (tool):  Get Teradata database version information.
- `base_databaseList` (tool): Lists all databases in the Teradata System.
--- Category: Database Space ---
- `dba_databaseSpace` (tool): 
Get database space if database name is provided, otherwise get all databases space allocations.

Arguments:
  database_name - database name

Returns:
  ResponseType: formatted response with query results + metadata

- `get_cube_cust_cube_db_space_metrics` (tool): 
    Tool to query the cube 'table_skew_pct'.
    Get the Teradata database space metrics for tables and databases

    Expected inputs:
        dimensions (str): Comma-separated dimension names to group by. Allowed values:
    - DatabaseName: Name of the database
    - TableName: Name of the table

        measures (str): Comma-separated measure names to aggregate. Allowed values:
    - current_perm: Object perm space in bytes
    - peak_perm: Object peak perm space in bytes
    - table_skew_pct: Object skew percentage

        filters (str): Comma-separated filter expressions to apply to either dimensions or measures selected. The dimension or measure used must be in the dimension list to group by or measure list, use valid SQL expressions, for example:
DatabaseName = 'value'
TableName = 'value'
current_perm > 1000
peak_perm > 1000
table_skew_pct > 1000

    Returns:
        Query result as a formatted response.
    
  - Arguments:
    - `dimensions` (string, optional): No description.
    - `measures` (string, optional): No description.
    - `filters` (string, optional): No description.
- `dba_systemSpace` (tool): Get the Teradata total system database space usage.
--- Category: Performance ---
- `dba_resusageSummary` (tool): 
Get the Teradata system usage summary metrics by weekday and hour for each workload type and query complexity bucket.

Arguments:
  dimensions - list of dimensions to aggregate the resource usage summary. All dimensions are: ["LogDate", "hourOfDay", "dayOfWeek", "workloadType", "workloadComplexity", "UserName", "AppId", "StatementType"]
  user_name - user name
  date - Date to analyze, formatted as `YYYY-MM-DD`
  dayOfWeek - day of the week to analyze
  hourOfDay - hour of day to analyze


- `dba_flowControl` (tool): Get the Teradata flow control metrics for a specified date range.
  - Arguments:
    - `start_date` (string, optional): No description.
    - `end_date` (string, optional): No description.
- `dba_userDelay` (tool): Get the Teradata user delay metrics for a specified date range.
  - Arguments:
    - `start_date` (string, optional): No description.
    - `end_date` (string, optional): No description.
--- Category: Query Execution ---
- `base_readQuery` (tool): 
Execute a SQL query via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  sql    - SQL text, with optional bind-parameter placeholders

Returns:
  ResponseType: formatted response with query results + metadata

--- Category: Sales Analytics ---
- `sales_top_customers` (tool): Get the top 20 customers by lifetime value.
- `sales_customer_profile` (tool): Get customer profile and metrics.
  - Arguments:
    - `customer_key` (string, optional): No description.
- `get_cube_sales_cube` (tool): 
    Tool to query the cube 'order_count'.
    Get the key sales metrics: USD amount and number of orders.

    Expected inputs:
        dimensions (str): Comma-separated dimension names to group by. Allowed values:
    - customer_key: Key for the customer
    - sales_year: Year of the sale
    - sales_month: Month of the sale

        measures (str): Comma-separated measure names to aggregate. Allowed values:
    - gift_amount_usd: Total gift card amount used for the order in USD
    - total_amount_usd: Total order amount in USD
    - order_count: Total number of orders

        filters (str): Comma-separated filter expressions to apply to either dimensions or measures selected. The dimension or measure used must be in the dimension list to group by or measure list, use valid SQL expressions, for example:
customer_key = 'value'
sales_year = 'value'
sales_month = 'value'
gift_amount_usd > 1000
total_amount_usd > 1000
order_count > 1000

    Returns:
        Query result as a formatted response.
    
  - Arguments:
    - `dimensions` (string, optional): No description.
    - `measures` (string, optional): No description.
    - `filters` (string, optional): No description.
--- Category: Security ---
- `sec_rolePermissions` (tool): 
Get permissions for a role.

Arguments:
  role_name - role name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `sec_userDbPermissions` (tool): 
Get permissions for a user.

Arguments:
  user_name - user name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `sec_userRoles` (tool): 
Get roles assigned to a user.

Arguments:
  user_name - user name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

--- Category: Session Management ---
- `dba_sessionInfo` (tool): Get the Teradata session information for user.
  - Arguments:
    - `user_name` (string, optional): No description.
--- Category: Table Management ---
- `dba_tableSpace` (tool): 
Get table space used for a table if table name is provided or get table space for all tables in a database if a database name is provided."

Arguments:
  database_name - database name
  table_name - table name

Returns:
  ResponseType: formatted response with query results + metadata

- `dba_tableSqlList` (tool): 
Get a list of SQL run against a table in the last number of days.

Arguments:
  table_name - table name
  no_days - number of days

Returns:
  ResponseType: formatted response with query results + metadata

- `dba_tableUsageImpact` (tool): 
Measure the usage of a table and views by users, this is helpful to understand what user and tables are driving most resource usage at any point in time.

Arguments:
  database_name - database name to analyze
  user_name - user name to analyze


- `base_columnDescription` (tool): 
Shows detailed column information about a database table via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name
  obj_name - table or view name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableAffinity` (tool): 
Get tables commonly used together by database users, this is helpful to infer relationships between tables via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name
  object_name - table or view name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableDDL` (tool): 
Displays the DDL definition of a table via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name
  table_name - table name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tablePreview` (tool): 
This function returns data sample and inferred structure from a database table or view via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  table_name - table or view name
  database_name - Database name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableUsage` (tool): 
Measure the usage of a table and views by users in a given schema, this is helpful to infer what database objects are most actively used or drive most value via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableList` (tool): Lists all tables in a database.
  - Arguments:
    - `database_name` (string, optional): No description.
--- Category: Usage Tracking ---
- `dba_featureUsage` (tool): Get the user feature usage metrics for a specified date range.
  - Arguments:
    - `start_date` (string, optional): No description.
    - `end_date` (string, optional): No description.
--- Category: User Management ---
- `dba_userSqlList` (tool): 
Get a list of SQL run by a user in the last number of days if a user name is provided, otherwise get list of all SQL in the last number of days.

Arguments:
  user_name - user name
  no_days - number of days

Returns:
  ResponseType: formatted response with query results + metadata

- `cust_activeUsers` (tool): Fetch currently active database users
--- Category: Utilities ---
- `tmpl_nameOfTool` (tool): 
<description of what the tool is for>

Arguments:
  arguments - arguments to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `evs_similarity_search` (tool): 
Enterprise Vector Store similarity search

Arguments:
  question - the query string to search for
  top_k - number of top results to return

Returns:
  ResponseType: formatted response with query results + metadata

- `rag_executeWorkflow` (tool): 
Execute complete RAG workflow to answer user questions based on document context.


This function handles the entire RAG pipeline:
1. Configuration setup (using configurable values from rag_config.yml)
2. Store user query (with /rag prefix stripping)
3. Generate query embeddings (tokenization + embedding)
4. Perform semantic search against chunk embeddings
5. Return retrieved context chunks for answer generation

The function uses configuration values from rag_config.yml with fallback defaults.

Arguments:
  question - user question to process
  k - number of top-k results to return (optional, uses config default if not provided)

Returns:
  Returns the top-k most relevant chunks with metadata for context-grounded answer generation.

- `rag_executeWorkflow_ivsm` (tool): 
Execute complete RAG workflow to answer user questions based on document context.

This function handles the entire RAG pipeline using IVSM functions:
1. Configuration setup (using configurable values from rag_config.yml)
2. Store user query (with /rag prefix stripping)
3. Tokenize query using ivsm.tokenizer_encode
4. Create embedding view using ivsm.IVSM_score
5. Convert embeddings to vector columns using ivsm.vector_to_columns
6. Perform semantic search against chunk embeddings

The function uses configuration values from rag_config.yml with fallback defaults.

Arguments:
  question - user question to process
  k - number of top-k results to return (optional, uses config default if not provided

Returns:
  Returns the top-k most relevant chunks with metadata for context-grounded answer generation.

- `util_getCurrentDate` (tool): Returns the current system date in YYYY-MM-DD format. Use this as the first step for any user query involving relative dates like 'today', 'yesterday', or 'this week'.
- `util_calculateDateRange` (tool): Calculates a list of dates based on a start date and a natural language phrase (e.g., 'past 3 days', 'last week'). This is a necessary second step for multi-day queries.
  - Arguments:
    - `start_date` (string, required): The anchor date for the calculation, usually today's date from `util_getCurrentDate`. Must be in YYYY-MM-DD format.
    - `date_phrase` (string, required): The natural language phrase describing the desired range (e.g., 'past 3 days', 'last 2 weeks').
- `CoreLLMTask` (tool): Performs internal, LLM-driven tasks that are not direct calls to the Teradata database. This tool is used for text synthesis, summarization, and formatting based on a specific 'task_description' provided by the LLM itself.
  - Arguments:
    - `task_description` (string, required): A natural language description of the internal task to be executed (e.g., 'describe the table in a business context', 'format final output'). The LLM infers this from the workflow plan.
    - `source_data` (list[string], required): A list of keys (e.g., 'result_of_phase_1') identifying which data from the workflow history is relevant for this task. This is critical for providing the correct context.
--- Available Prompts ---
--- Category: Prompts ---
- `base_query` (prompt): Help users interact with  Teradata databases effectively.
  - Arguments:
    - `query` (str, required): The problem or question that needs to be solved using Teradata database tools.
- `base_tableBusinessDesc` (prompt): You are a Teradata DBA who is an expert in describing the business use of tables in a database.
  - Arguments:
    - `database_name` (str, required): Database for the table to describe.
    - `table_name` (str, required): Table to describe.


USER PROMPT:

You are an expert strategic planning assistant. Your task is to analyze a user's request or a complex workflow goal and decompose it into a high-level, phased meta-plan. This plan will serve as a state machine executor.

--- GOAL ---
what is the system utilization of the past 3 days?

--- CONTEXT ---
- User's Original Question (for reference): what is the system utilization of the past 3 days?

--- INSTRUCTIONS ---
1.  **Analyze the Goal**: Carefully read the "GOAL" to understand the user's full intent.
2.  **Decompose into Phases**: Break down the overall goal into a sequence of logical phases. Each phase should represent a major step.
3.  **Define Each Phase**: For each phase, create a JSON object with the following keys:
    -   `"phase"`: An integer representing the step number (e.g., 1, 2, 3).
    -   `"goal"`: A clear, concise, and actionable description of what must be accomplished in this phase. This goal will guide a separate, tactical LLM.
    -   `"relevant_tools"`: A list of tool names that are permitted to be used during this phase. You MUST select the most appropriate and specific tools from the full "Capabilities" list provided in the main system prompt to achieve the phase's goal.
    -   (Optional) `"type": "loop"`: If a phase requires iterating over a list of items, you MUST include this key.
    -   (Optional) `"loop_over"`: If `"type"` is `"loop"`, specify the data source for the iteration (e.g., `"result_of_phase_1"`).
4.  **Embed Parameters**: When defining the `"goal"` for a phase, you MUST scan the main "GOAL" for any hardcoded arguments or parameters (e.g., table names, database names) relevant to that phase's task. You MUST embed these found parameters directly into the `"goal"` string to make it self-contained and explicit.
5.  **Final Synthesis and Formatting Phase**: If the main "GOAL" describes a multi-step process with a final reporting requirement, your plan **MUST** conclude with a single, final phase that handles both the synthesis of the final report AND its formatting. The `relevant_tools` for this final phase **MUST** be `["CoreLLMTask"]`.
6.  **CRITICAL RULE (Simplicity)**: If the "GOAL" is a simple, direct request that can be answered with a single tool call (e.g., "list all databases", "what is the system utilization?"), your plan **MUST** consist of only a single phase that calls the one most appropriate tool. Do not add unnecessary synthesis phases for simple data retrieval.
7.  **CRITICAL RULE (Execution Focus)**: Every phase you define **MUST** correspond to a concrete, tool-based action. You **MUST NOT** create phases for simple verification, confirmation, or acknowledgement of known information. Your plan must focus only on the execution steps required to gather new information or process existing data.
8.  **CRITICAL RULE (Capability Types)**: You are generating a plan of executable **tools**. The `relevant_tools` list **MUST ONLY** contain names of capabilities that are explicitly marked as `(tool)` in the system's "Capabilities" list. You **MUST NOT** include the name of any capability marked as `(prompt)`.
9.  **CRITICAL RULE (Efficiency)**: If a phase's `"goal"` already contains all the instructions for the final synthesis and formatting of the report (as specified in the main "GOAL"), you **MUST** make this the last phase of the plan. Do not add a separate, redundant formatting-only phase after it.

--- EXAMPLE (Complex Goal) ---
If the main goal requires getting DDL and then describing/formatting, your output should be a two-phase plan like this:
```json
[
  {
    "phase": 1,
    "goal": "Get the DDL for the table 'customers' in database 'sales' using the `base_tableDDL` tool.",
    "relevant_tools": ["base_tableDDL"]
  },
  {
    "phase": 2,
    "goal": "Synthesize a final report by describing the 'customers' table in a business context and format the output as markdown according to the Final output guidelines, using `***` for keys.",
    "relevant_tools": ["CoreLLMTask"]
  }
]
```

--- EXAMPLE (Simple Goal) ---
If the main goal is "what is the system utilization?", your output should be a single-phase plan like this:
```json
[
  {
    "phase": 1,
    "goal": "Get the system utilization using the `dba_resusageSummary` tool.",
    "relevant_tools": ["dba_resusageSummary"]
  }
]
```

--- EXAMPLE (Date Range Goal) ---
If the main goal is "what is the system utilization for the past 3 days?", your output must be a three-phase plan like this:
```json
[
  {
    "phase": 1,
    "goal": "Get the current date using the `util_getCurrentDate` tool to establish a reference point.",
    "relevant_tools": ["util_getCurrentDate"]
  },
  {
    "phase": 2,
    "goal": "Calculate the list of dates for 'the past 3 days' using the `util_calculateDateRange` tool.",
    "relevant_tools": ["util_calculateDateRange"]
  },
  {
    "phase": 3,
    "goal": "For each date calculated in the previous step, get the system utilization using the `dba_resusageSummary` tool.",
    "relevant_tools": ["dba_resusageSummary"],
    "type": "loop",
    "loop_over": "result_of_phase_2"
  }
]
```

Your response MUST be a single, valid JSON list of phase objects. Do NOT add any extra text, conversation, or markdown.

[model]: ```json
[
  {
    "phase": 1,
    "goal": "Get the current date using the `util_getCurrentDate` tool to establish a reference point.",
    "relevant_tools": ["util_getCurrentDate"]
  },
  {
    "phase": 2,
    "goal": "Calculate the list of dates for 'past 3 days' using the `util_calculateDateRange` tool.",
    "relevant_tools": ["util_calculateDateRange"]
  },
  {
    "phase": 3,
    "goal": "For each date calculated in the previous step, get the system utilization using the `dba_resusageSummary` tool.",
    "relevant_tools": ["dba_resusageSummary"],
    "type": "loop",
    "loop_over": "result_of_phase_2"
  }
]
```

--- Current User Prompt (with System Prompt) ---
SYSTEM PROMPT:

You are a tactical assistant executing a single phase of a larger plan. Your task is to decide the single best next action to take to achieve the current phase's goal, strictly adhering to the provided tool constraints.

--- OVERALL WORKFLOW GOAL ---
what is the system utilization of the past 3 days?

--- CURRENT PHASE GOAL ---
Get the current date using the `util_getCurrentDate` tool to establish a reference point.

--- CONSTRAINTS ---
- Permitted Tools for this Phase (You MUST use the exact argument names provided):

- Tool: `util_getCurrentDate`
  - Description: Returns the current system date in YYYY-MM-DD format. Use this as the first step for any user query involving relative dates like 'today', 'yesterday', or 'this week'.

- Previous Attempt (if any): None

--- WORKFLOW STATE & HISTORY ---
- Actions Taken So Far: []
- Data Collected So Far: {}

--- INSTRUCTIONS ---
1.  **Analyze the State**: Review the "CURRENT PHASE GOAL" and the "WORKFLOW STATE & HISTORY" to understand what has been done and what is needed next.
2.  **CRITICAL RULE (Tool Selection & Arguments)**: You **MUST** select your next action from the list of "Permitted Tools for this Phase". You are not allowed to use any other tool. Furthermore, you **MUST** use the exact argument names as they are defined in the tool details above. You **MUST NOT** invent, hallucinate, or use any arguments that are not explicitly listed in the definitions.
3.  **Self-Correction**: If a "Previous Attempt" is noted in the "CONSTRAINTS" section, it means your last choice was invalid. You **MUST** analyze the error and choose a different, valid tool from the permitted list. Do not repeat the invalid choice.
4.  **CoreLLMTask Usage**:
    -   For any task that involves synthesis, analysis, description, or summarization, you **MUST** use the `CoreLLMTask` tool, but only if it is in the permitted tools list.
    -   When calling `CoreLLMTask`, you **MUST** provide the `task_description` argument.
    -   Crucially, you **MUST** also determine which previous phase results are necessary for the task. You **MUST** provide these as a list of strings in the `source_data` argument.
    -   **CONTEXT PRESERVATION RULE**: If the current phase involves creating a final summary or report for the user, you **MUST** ensure you have all the necessary context. Your `source_data` list **MUST** include the results from **ALL** previous data-gathering phases (e.g., `["result_of_phase_1", "result_of_phase_2"]`) to prevent information loss.
5.  **Handle Loops**: If you are in a looping phase (indicated by the presence of a "LOOP CONTEXT" section), you **MUST** focus your action on the single item provided in `current_loop_item`. You **MUST** use the information within that item to formulate the arguments for your tool call.
6.  **Format Response**: Your response MUST be a single JSON object for a tool call.

Your response MUST be a single, valid JSON object for a tool call. Do NOT add any extra text or conversation.


USER PROMPT:
Determine the next action based on the instructions and state provided in the system prompt.

2025-08-21 22:45:31,238 - --- RESPONSE ---
```json
{"tool_name": "util_getCurrentDate", "arguments": {}}
```
--------------------------------------------------

2025-08-21 22:45:32,034 - --- FULL CONTEXT (Session: df7e1f03-2ba5-457e-8b31-1a09c2af00c6) ---
--- REASON FOR CALL ---
Deciding next tactical action for phase: Calculate the list of dates for 'past 3 days' using the `util_calculateDateRange` tool.

--- History ---
[user]: You are a helpful assistant.
[model]: Understood.
[user]: SYSTEM PROMPT:

# Core Directives
You are a specialized assistant for a Teradata database system. Your primary goal is to fulfill user requests by selecting the best capability (a tool or a prompt) from the categorized lists provided and supplying all necessary arguments.

# Response Format
Your response MUST be a single JSON object for a tool/prompt call OR a single plain text string for a final answer.

1.  **Tool/Prompt Calls (JSON format):**
    -   If the capability is a prompt, you MUST use the key `"prompt_name"`.
    -   If the capability is a tool, you MUST use the key `"tool_name"`.
    -   Provide all required arguments. Infer values from the conversation history if necessary.
    -   Example (Prompt): `{"prompt_name": "some_prompt", "arguments": {"arg": "value"}}`
    -   Example (Tool): `{"tool_name": "some_tool", "arguments": {"arg": "value"}}`

2.  **Final Answer (Plain Text format):**
    -   When you have sufficient information to fully answer the user's request, you MUST stop using tools.
    -   Your response MUST begin with the exact prefix `FINAL_ANSWER:`, followed by a natural language summary.
    -   Example: `FINAL_ANSWER: I found 48 databases on the system. The details are displayed below.`

# Decision Process
To select the correct capability, you MUST follow this two-step process, governed by one critical rule:

**CRITICAL RULE: Prioritize Specificity and Arguments.** Your primary filter for selecting a capability is its specificity. You MUST select the most granular capability that uses the most entities from the user's request (e.g., prefer a tool that uses a `table_name` over one that only uses a `database_name` if a table is mentioned). For direct actions and single analyses, you MUST select a `tool_name`; only select a `prompt_name` for broad, multi-step tasks explicitly described by the prompt.

1.  **Identify the Category:** First, analyze the user's request to determine which Tool or Prompt Category is the most relevant to their intent. The available categories are listed in the "Capabilities" section below.
2.  **Select the Capability:** Second, from within that single most relevant category, select the best tool or prompt to fulfill the request, adhering to the Critical Rule above.

# Few-Shot Examples
Here are examples of the correct thinking process:

**Example 1:**
- **User Query:** "what is the quality of table 'online' in database 'DEMO_Customer360_db'?"
- **Thought Process:**
    1.  The user's query is about a **table**.
    2.  My critical rule is to prioritize specificity. I must choose a table-level tool.
    3.  The `qlty_databaseQuality` prompt is for databases, not specific tables, so it's incorrect.
    4.  The `qlty_columnSummary` tool takes a `table_name` and is the most specific, correct choice.
- **Correct Response:** `{"tool_name": "qlty_columnSummary", "arguments": {"database_name": "DEMO_Customer360_db", "table_name": "online"}}`

**Example 2:**
- **User Query:** "describe the business purpose of the 'DEMO_Customer360_db' database"
- **Thought Process:**
    1.  The user's query is about a **database**. It's a broad request ("describe").
    2.  A prompt is better for broad tasks.
    3.  The `base_databaseBusinessDesc` prompt takes a `database_name` and is the correct choice.
- **Correct Response:** `{"prompt_name": "base_databaseBusinessDesc", "arguments": {"database_name": "DEMO_Customer360_db"}}`

**Example 3:**
- **User Query:** "what is the system utilization?"
- **Thought Process:**
    1.  The user is asking for a specific metric: "system utilization". This is a direct request for data.
    2.  My critical rule states I must prioritize a `tool_name` for direct actions.
    3.  The `dba_systemVoice` prompt is for adopting a persona, not for fetching specific metrics. It is the incorrect choice.
    4.  The `dba_resusageSummary` tool in the `Performance` category is designed to get system usage summary metrics. This is the correct choice.
- **Correct Response:** `{"tool_name": "dba_resusageSummary", "arguments": {}}`

# Best Practices
- **Context is Key:** Always use information from previous turns to fill in arguments like `db_name` or `table_name`.
- **Error Recovery:** If a tool fails, analyze the error message and attempt to call the tool again with corrected parameters. Only ask the user for clarification if you cannot recover.
- **SQL Generation:** When using the `base_readQuery` tool, you MUST use fully qualified table names in your SQL (e.g., `SELECT ... FROM my_database.my_table`).
- **Time-Sensitive Queries:** For queries involving relative dates (e.g., 'today', 'this week'), you MUST use the `util_getCurrentDate` tool first to determine the current date before proceeding.
- **Out of Scope:** If the user's request is unrelated to the available capabilities, respond with a `FINAL_ANSWER:` that politely explains you cannot fulfill the request and restates your purpose.
- **CRITICAL: Avoid Repetitive Behavior.** You are a highly intelligent agent. Do not get stuck in a loop by repeating the same tool calls or by cycling through the same set of tools. Once a tool has returned a successful result with data that is relevant to the user's request, do not call that same tool again unless there is a new and compelling reason to do so. If you have called a series of tools and believe you have enough information, you must call a FINAL_ANSWER. Do not repeat tool calls just to be "through".


# Capabilities
--- Available Tools ---
--- Category: Data Quality ---
- `qlty_columnSummary` (tool): 
Get the column summary statistics for a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_distinctCategories` (tool): 
Get the destinct categories from column in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_missingValues` (tool): 
Get the column names that having missing values in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_negativeValues` (tool): 
Get the column names that having negative values in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_rowsWithMissingValues` (tool): 
Get the rows with missing values in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_standardDeviation` (tool): 
Get the standard deviation from column in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_univariateStatistics` (tool): 
Get the univariate statistics for a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

--- Category: Data Visualization ---
- `viz_createChart` (tool): Generates a data visualization based on provided data. You must specify the chart type and map the data fields to the appropriate visual roles.
  - Arguments:
    - `chart_type` (string, required): The type of chart to generate (e.g., 'bar', 'pie', 'line', 'scatter'). This MUST be one of the types listed in the 'Charting Guidelines'.
    - `data` (list[dict], required): The data to be visualized, passed directly from the output of another tool.
    - `title` (string, required): A descriptive title for the chart.
    - `mapping` (dict, required): A dictionary that maps data keys to chart axes or roles (e.g., {'x_axis': 'product_name', 'y_axis': 'sales_total'}). The required keys for this mapping depend on the selected chart_type.
--- Category: Database Information ---
- `cust_td_serverInfo` (tool): Get the Teradata software information: demonstrates how to use parameters for prepared statements.
  - Arguments:
    - `infokey` (string, optional): No description.
- `dba_databaseVersion` (tool):  Get Teradata database version information.
- `base_databaseList` (tool): Lists all databases in the Teradata System.
--- Category: Database Space ---
- `dba_databaseSpace` (tool): 
Get database space if database name is provided, otherwise get all databases space allocations.

Arguments:
  database_name - database name

Returns:
  ResponseType: formatted response with query results + metadata

- `get_cube_cust_cube_db_space_metrics` (tool): 
    Tool to query the cube 'table_skew_pct'.
    Get the Teradata database space metrics for tables and databases

    Expected inputs:
        dimensions (str): Comma-separated dimension names to group by. Allowed values:
    - DatabaseName: Name of the database
    - TableName: Name of the table

        measures (str): Comma-separated measure names to aggregate. Allowed values:
    - current_perm: Object perm space in bytes
    - peak_perm: Object peak perm space in bytes
    - table_skew_pct: Object skew percentage

        filters (str): Comma-separated filter expressions to apply to either dimensions or measures selected. The dimension or measure used must be in the dimension list to group by or measure list, use valid SQL expressions, for example:
DatabaseName = 'value'
TableName = 'value'
current_perm > 1000
peak_perm > 1000
table_skew_pct > 1000

    Returns:
        Query result as a formatted response.
    
  - Arguments:
    - `dimensions` (string, optional): No description.
    - `measures` (string, optional): No description.
    - `filters` (string, optional): No description.
- `dba_systemSpace` (tool): Get the Teradata total system database space usage.
--- Category: Performance ---
- `dba_resusageSummary` (tool): 
Get the Teradata system usage summary metrics by weekday and hour for each workload type and query complexity bucket.

Arguments:
  dimensions - list of dimensions to aggregate the resource usage summary. All dimensions are: ["LogDate", "hourOfDay", "dayOfWeek", "workloadType", "workloadComplexity", "UserName", "AppId", "StatementType"]
  user_name - user name
  date - Date to analyze, formatted as `YYYY-MM-DD`
  dayOfWeek - day of the week to analyze
  hourOfDay - hour of day to analyze


- `dba_flowControl` (tool): Get the Teradata flow control metrics for a specified date range.
  - Arguments:
    - `start_date` (string, optional): No description.
    - `end_date` (string, optional): No description.
- `dba_userDelay` (tool): Get the Teradata user delay metrics for a specified date range.
  - Arguments:
    - `start_date` (string, optional): No description.
    - `end_date` (string, optional): No description.
--- Category: Query Execution ---
- `base_readQuery` (tool): 
Execute a SQL query via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  sql    - SQL text, with optional bind-parameter placeholders

Returns:
  ResponseType: formatted response with query results + metadata

--- Category: Sales Analytics ---
- `sales_top_customers` (tool): Get the top 20 customers by lifetime value.
- `sales_customer_profile` (tool): Get customer profile and metrics.
  - Arguments:
    - `customer_key` (string, optional): No description.
- `get_cube_sales_cube` (tool): 
    Tool to query the cube 'order_count'.
    Get the key sales metrics: USD amount and number of orders.

    Expected inputs:
        dimensions (str): Comma-separated dimension names to group by. Allowed values:
    - customer_key: Key for the customer
    - sales_year: Year of the sale
    - sales_month: Month of the sale

        measures (str): Comma-separated measure names to aggregate. Allowed values:
    - gift_amount_usd: Total gift card amount used for the order in USD
    - total_amount_usd: Total order amount in USD
    - order_count: Total number of orders

        filters (str): Comma-separated filter expressions to apply to either dimensions or measures selected. The dimension or measure used must be in the dimension list to group by or measure list, use valid SQL expressions, for example:
customer_key = 'value'
sales_year = 'value'
sales_month = 'value'
gift_amount_usd > 1000
total_amount_usd > 1000
order_count > 1000

    Returns:
        Query result as a formatted response.
    
  - Arguments:
    - `dimensions` (string, optional): No description.
    - `measures` (string, optional): No description.
    - `filters` (string, optional): No description.
--- Category: Security ---
- `sec_rolePermissions` (tool): 
Get permissions for a role.

Arguments:
  role_name - role name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `sec_userDbPermissions` (tool): 
Get permissions for a user.

Arguments:
  user_name - user name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `sec_userRoles` (tool): 
Get roles assigned to a user.

Arguments:
  user_name - user name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

--- Category: Session Management ---
- `dba_sessionInfo` (tool): Get the Teradata session information for user.
  - Arguments:
    - `user_name` (string, optional): No description.
--- Category: Table Management ---
- `dba_tableSpace` (tool): 
Get table space used for a table if table name is provided or get table space for all tables in a database if a database name is provided."

Arguments:
  database_name - database name
  table_name - table name

Returns:
  ResponseType: formatted response with query results + metadata

- `dba_tableSqlList` (tool): 
Get a list of SQL run against a table in the last number of days.

Arguments:
  table_name - table name
  no_days - number of days

Returns:
  ResponseType: formatted response with query results + metadata

- `dba_tableUsageImpact` (tool): 
Measure the usage of a table and views by users, this is helpful to understand what user and tables are driving most resource usage at any point in time.

Arguments:
  database_name - database name to analyze
  user_name - user name to analyze


- `base_columnDescription` (tool): 
Shows detailed column information about a database table via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name
  obj_name - table or view name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableAffinity` (tool): 
Get tables commonly used together by database users, this is helpful to infer relationships between tables via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name
  object_name - table or view name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableDDL` (tool): 
Displays the DDL definition of a table via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name
  table_name - table name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tablePreview` (tool): 
This function returns data sample and inferred structure from a database table or view via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  table_name - table or view name
  database_name - Database name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableUsage` (tool): 
Measure the usage of a table and views by users in a given schema, this is helpful to infer what database objects are most actively used or drive most value via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableList` (tool): Lists all tables in a database.
  - Arguments:
    - `database_name` (string, optional): No description.
--- Category: Usage Tracking ---
- `dba_featureUsage` (tool): Get the user feature usage metrics for a specified date range.
  - Arguments:
    - `start_date` (string, optional): No description.
    - `end_date` (string, optional): No description.
--- Category: User Management ---
- `dba_userSqlList` (tool): 
Get a list of SQL run by a user in the last number of days if a user name is provided, otherwise get list of all SQL in the last number of days.

Arguments:
  user_name - user name
  no_days - number of days

Returns:
  ResponseType: formatted response with query results + metadata

- `cust_activeUsers` (tool): Fetch currently active database users
--- Category: Utilities ---
- `tmpl_nameOfTool` (tool): 
<description of what the tool is for>

Arguments:
  arguments - arguments to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `evs_similarity_search` (tool): 
Enterprise Vector Store similarity search

Arguments:
  question - the query string to search for
  top_k - number of top results to return

Returns:
  ResponseType: formatted response with query results + metadata

- `rag_executeWorkflow` (tool): 
Execute complete RAG workflow to answer user questions based on document context.


This function handles the entire RAG pipeline:
1. Configuration setup (using configurable values from rag_config.yml)
2. Store user query (with /rag prefix stripping)
3. Generate query embeddings (tokenization + embedding)
4. Perform semantic search against chunk embeddings
5. Return retrieved context chunks for answer generation

The function uses configuration values from rag_config.yml with fallback defaults.

Arguments:
  question - user question to process
  k - number of top-k results to return (optional, uses config default if not provided)

Returns:
  Returns the top-k most relevant chunks with metadata for context-grounded answer generation.

- `rag_executeWorkflow_ivsm` (tool): 
Execute complete RAG workflow to answer user questions based on document context.

This function handles the entire RAG pipeline using IVSM functions:
1. Configuration setup (using configurable values from rag_config.yml)
2. Store user query (with /rag prefix stripping)
3. Tokenize query using ivsm.tokenizer_encode
4. Create embedding view using ivsm.IVSM_score
5. Convert embeddings to vector columns using ivsm.vector_to_columns
6. Perform semantic search against chunk embeddings

The function uses configuration values from rag_config.yml with fallback defaults.

Arguments:
  question - user question to process
  k - number of top-k results to return (optional, uses config default if not provided

Returns:
  Returns the top-k most relevant chunks with metadata for context-grounded answer generation.

- `util_getCurrentDate` (tool): Returns the current system date in YYYY-MM-DD format. Use this as the first step for any user query involving relative dates like 'today', 'yesterday', or 'this week'.
- `util_calculateDateRange` (tool): Calculates a list of dates based on a start date and a natural language phrase (e.g., 'past 3 days', 'last week'). This is a necessary second step for multi-day queries.
  - Arguments:
    - `start_date` (string, required): The anchor date for the calculation, usually today's date from `util_getCurrentDate`. Must be in YYYY-MM-DD format.
    - `date_phrase` (string, required): The natural language phrase describing the desired range (e.g., 'past 3 days', 'last 2 weeks').
- `CoreLLMTask` (tool): Performs internal, LLM-driven tasks that are not direct calls to the Teradata database. This tool is used for text synthesis, summarization, and formatting based on a specific 'task_description' provided by the LLM itself.
  - Arguments:
    - `task_description` (string, required): A natural language description of the internal task to be executed (e.g., 'describe the table in a business context', 'format final output'). The LLM infers this from the workflow plan.
    - `source_data` (list[string], required): A list of keys (e.g., 'result_of_phase_1') identifying which data from the workflow history is relevant for this task. This is critical for providing the correct context.
--- Available Prompts ---
--- Category: Prompts ---
- `base_query` (prompt): Help users interact with  Teradata databases effectively.
  - Arguments:
    - `query` (str, required): The problem or question that needs to be solved using Teradata database tools.
- `base_tableBusinessDesc` (prompt): You are a Teradata DBA who is an expert in describing the business use of tables in a database.
  - Arguments:
    - `database_name` (str, required): Database for the table to describe.
    - `table_name` (str, required): Table to describe.


USER PROMPT:

You are an expert strategic planning assistant. Your task is to analyze a user's request or a complex workflow goal and decompose it into a high-level, phased meta-plan. This plan will serve as a state machine executor.

--- GOAL ---
what is the system utilization of the past 3 days?

--- CONTEXT ---
- User's Original Question (for reference): what is the system utilization of the past 3 days?

--- INSTRUCTIONS ---
1.  **Analyze the Goal**: Carefully read the "GOAL" to understand the user's full intent.
2.  **Decompose into Phases**: Break down the overall goal into a sequence of logical phases. Each phase should represent a major step.
3.  **Define Each Phase**: For each phase, create a JSON object with the following keys:
    -   `"phase"`: An integer representing the step number (e.g., 1, 2, 3).
    -   `"goal"`: A clear, concise, and actionable description of what must be accomplished in this phase. This goal will guide a separate, tactical LLM.
    -   `"relevant_tools"`: A list of tool names that are permitted to be used during this phase. You MUST select the most appropriate and specific tools from the full "Capabilities" list provided in the main system prompt to achieve the phase's goal.
    -   (Optional) `"type": "loop"`: If a phase requires iterating over a list of items, you MUST include this key.
    -   (Optional) `"loop_over"`: If `"type"` is `"loop"`, specify the data source for the iteration (e.g., `"result_of_phase_1"`).
4.  **Embed Parameters**: When defining the `"goal"` for a phase, you MUST scan the main "GOAL" for any hardcoded arguments or parameters (e.g., table names, database names) relevant to that phase's task. You MUST embed these found parameters directly into the `"goal"` string to make it self-contained and explicit.
5.  **Final Synthesis and Formatting Phase**: If the main "GOAL" describes a multi-step process with a final reporting requirement, your plan **MUST** conclude with a single, final phase that handles both the synthesis of the final report AND its formatting. The `relevant_tools` for this final phase **MUST** be `["CoreLLMTask"]`.
6.  **CRITICAL RULE (Simplicity)**: If the "GOAL" is a simple, direct request that can be answered with a single tool call (e.g., "list all databases", "what is the system utilization?"), your plan **MUST** consist of only a single phase that calls the one most appropriate tool. Do not add unnecessary synthesis phases for simple data retrieval.
7.  **CRITICAL RULE (Execution Focus)**: Every phase you define **MUST** correspond to a concrete, tool-based action. You **MUST NOT** create phases for simple verification, confirmation, or acknowledgement of known information. Your plan must focus only on the execution steps required to gather new information or process existing data.
8.  **CRITICAL RULE (Capability Types)**: You are generating a plan of executable **tools**. The `relevant_tools` list **MUST ONLY** contain names of capabilities that are explicitly marked as `(tool)` in the system's "Capabilities" list. You **MUST NOT** include the name of any capability marked as `(prompt)`.
9.  **CRITICAL RULE (Efficiency)**: If a phase's `"goal"` already contains all the instructions for the final synthesis and formatting of the report (as specified in the main "GOAL"), you **MUST** make this the last phase of the plan. Do not add a separate, redundant formatting-only phase after it.

--- EXAMPLE (Complex Goal) ---
If the main goal requires getting DDL and then describing/formatting, your output should be a two-phase plan like this:
```json
[
  {
    "phase": 1,
    "goal": "Get the DDL for the table 'customers' in database 'sales' using the `base_tableDDL` tool.",
    "relevant_tools": ["base_tableDDL"]
  },
  {
    "phase": 2,
    "goal": "Synthesize a final report by describing the 'customers' table in a business context and format the output as markdown according to the Final output guidelines, using `***` for keys.",
    "relevant_tools": ["CoreLLMTask"]
  }
]
```

--- EXAMPLE (Simple Goal) ---
If the main goal is "what is the system utilization?", your output should be a single-phase plan like this:
```json
[
  {
    "phase": 1,
    "goal": "Get the system utilization using the `dba_resusageSummary` tool.",
    "relevant_tools": ["dba_resusageSummary"]
  }
]
```

--- EXAMPLE (Date Range Goal) ---
If the main goal is "what is the system utilization for the past 3 days?", your output must be a three-phase plan like this:
```json
[
  {
    "phase": 1,
    "goal": "Get the current date using the `util_getCurrentDate` tool to establish a reference point.",
    "relevant_tools": ["util_getCurrentDate"]
  },
  {
    "phase": 2,
    "goal": "Calculate the list of dates for 'the past 3 days' using the `util_calculateDateRange` tool.",
    "relevant_tools": ["util_calculateDateRange"]
  },
  {
    "phase": 3,
    "goal": "For each date calculated in the previous step, get the system utilization using the `dba_resusageSummary` tool.",
    "relevant_tools": ["dba_resusageSummary"],
    "type": "loop",
    "loop_over": "result_of_phase_2"
  }
]
```

Your response MUST be a single, valid JSON list of phase objects. Do NOT add any extra text, conversation, or markdown.

[model]: ```json
[
  {
    "phase": 1,
    "goal": "Get the current date using the `util_getCurrentDate` tool to establish a reference point.",
    "relevant_tools": ["util_getCurrentDate"]
  },
  {
    "phase": 2,
    "goal": "Calculate the list of dates for 'past 3 days' using the `util_calculateDateRange` tool.",
    "relevant_tools": ["util_calculateDateRange"]
  },
  {
    "phase": 3,
    "goal": "For each date calculated in the previous step, get the system utilization using the `dba_resusageSummary` tool.",
    "relevant_tools": ["dba_resusageSummary"],
    "type": "loop",
    "loop_over": "result_of_phase_2"
  }
]
```
[user]: SYSTEM PROMPT:

You are a tactical assistant executing a single phase of a larger plan. Your task is to decide the single best next action to take to achieve the current phase's goal, strictly adhering to the provided tool constraints.

--- OVERALL WORKFLOW GOAL ---
what is the system utilization of the past 3 days?

--- CURRENT PHASE GOAL ---
Get the current date using the `util_getCurrentDate` tool to establish a reference point.

--- CONSTRAINTS ---
- Permitted Tools for this Phase (You MUST use the exact argument names provided):

- Tool: `util_getCurrentDate`
  - Description: Returns the current system date in YYYY-MM-DD format. Use this as the first step for any user query involving relative dates like 'today', 'yesterday', or 'this week'.

- Previous Attempt (if any): None

--- WORKFLOW STATE & HISTORY ---
- Actions Taken So Far: []
- Data Collected So Far: {}

--- INSTRUCTIONS ---
1.  **Analyze the State**: Review the "CURRENT PHASE GOAL" and the "WORKFLOW STATE & HISTORY" to understand what has been done and what is needed next.
2.  **CRITICAL RULE (Tool Selection & Arguments)**: You **MUST** select your next action from the list of "Permitted Tools for this Phase". You are not allowed to use any other tool. Furthermore, you **MUST** use the exact argument names as they are defined in the tool details above. You **MUST NOT** invent, hallucinate, or use any arguments that are not explicitly listed in the definitions.
3.  **Self-Correction**: If a "Previous Attempt" is noted in the "CONSTRAINTS" section, it means your last choice was invalid. You **MUST** analyze the error and choose a different, valid tool from the permitted list. Do not repeat the invalid choice.
4.  **CoreLLMTask Usage**:
    -   For any task that involves synthesis, analysis, description, or summarization, you **MUST** use the `CoreLLMTask` tool, but only if it is in the permitted tools list.
    -   When calling `CoreLLMTask`, you **MUST** provide the `task_description` argument.
    -   Crucially, you **MUST** also determine which previous phase results are necessary for the task. You **MUST** provide these as a list of strings in the `source_data` argument.
    -   **CONTEXT PRESERVATION RULE**: If the current phase involves creating a final summary or report for the user, you **MUST** ensure you have all the necessary context. Your `source_data` list **MUST** include the results from **ALL** previous data-gathering phases (e.g., `["result_of_phase_1", "result_of_phase_2"]`) to prevent information loss.
5.  **Handle Loops**: If you are in a looping phase (indicated by the presence of a "LOOP CONTEXT" section), you **MUST** focus your action on the single item provided in `current_loop_item`. You **MUST** use the information within that item to formulate the arguments for your tool call.
6.  **Format Response**: Your response MUST be a single JSON object for a tool call.

Your response MUST be a single, valid JSON object for a tool call. Do NOT add any extra text or conversation.


USER PROMPT:
Determine the next action based on the instructions and state provided in the system prompt.
[model]: ```json
{"tool_name": "util_getCurrentDate", "arguments": {}}
```

--- Current User Prompt (with System Prompt) ---
SYSTEM PROMPT:

You are a tactical assistant executing a single phase of a larger plan. Your task is to decide the single best next action to take to achieve the current phase's goal, strictly adhering to the provided tool constraints.

--- OVERALL WORKFLOW GOAL ---
what is the system utilization of the past 3 days?

--- CURRENT PHASE GOAL ---
Calculate the list of dates for 'past 3 days' using the `util_calculateDateRange` tool.

--- CONSTRAINTS ---
- Permitted Tools for this Phase (You MUST use the exact argument names provided):

- Tool: `util_calculateDateRange`
  - Description: Calculates a list of dates based on a start date and a natural language phrase (e.g., 'past 3 days', 'last week'). This is a necessary second step for multi-day queries.
  - Arguments:
    - `start_date` (string, required): The anchor date for the calculation, usually today's date from `util_getCurrentDate`. Must be in YYYY-MM-DD format.
    - `date_phrase` (string, required): The natural language phrase describing the desired range (e.g., 'past 3 days', 'last 2 weeks').

- Previous Attempt (if any): None

--- WORKFLOW STATE & HISTORY ---
- Actions Taken So Far: [
  {
    "action": {
      "tool_name": "util_getCurrentDate",
      "arguments": {}
    },
    "result": {
      "status": "success",
      "metadata": {
        "tool_name": "util_getCurrentDate"
      },
      "results": [
        {
          "current_date": "2025-08-21"
        }
      ]
    }
  }
]
- Data Collected So Far: {
  "result_of_phase_1": [
    {
      "status": "success",
      "metadata": {
        "tool_name": "util_getCurrentDate"
      },
      "results": [
        {
          "current_date": "2025-08-21"
        }
      ]
    }
  ]
}

--- INSTRUCTIONS ---
1.  **Analyze the State**: Review the "CURRENT PHASE GOAL" and the "WORKFLOW STATE & HISTORY" to understand what has been done and what is needed next.
2.  **CRITICAL RULE (Tool Selection & Arguments)**: You **MUST** select your next action from the list of "Permitted Tools for this Phase". You are not allowed to use any other tool. Furthermore, you **MUST** use the exact argument names as they are defined in the tool details above. You **MUST NOT** invent, hallucinate, or use any arguments that are not explicitly listed in the definitions.
3.  **Self-Correction**: If a "Previous Attempt" is noted in the "CONSTRAINTS" section, it means your last choice was invalid. You **MUST** analyze the error and choose a different, valid tool from the permitted list. Do not repeat the invalid choice.
4.  **CoreLLMTask Usage**:
    -   For any task that involves synthesis, analysis, description, or summarization, you **MUST** use the `CoreLLMTask` tool, but only if it is in the permitted tools list.
    -   When calling `CoreLLMTask`, you **MUST** provide the `task_description` argument.
    -   Crucially, you **MUST** also determine which previous phase results are necessary for the task. You **MUST** provide these as a list of strings in the `source_data` argument.
    -   **CONTEXT PRESERVATION RULE**: If the current phase involves creating a final summary or report for the user, you **MUST** ensure you have all the necessary context. Your `source_data` list **MUST** include the results from **ALL** previous data-gathering phases (e.g., `["result_of_phase_1", "result_of_phase_2"]`) to prevent information loss.
5.  **Handle Loops**: If you are in a looping phase (indicated by the presence of a "LOOP CONTEXT" section), you **MUST** focus your action on the single item provided in `current_loop_item`. You **MUST** use the information within that item to formulate the arguments for your tool call.
6.  **Format Response**: Your response MUST be a single JSON object for a tool call.

Your response MUST be a single, valid JSON object for a tool call. Do NOT add any extra text or conversation.


USER PROMPT:
Determine the next action based on the instructions and state provided in the system prompt.

2025-08-21 22:45:32,035 - --- RESPONSE ---
```json
{"tool_name": "util_calculateDateRange", "arguments": {"start_date": "2025-08-21", "date_phrase": "past 3 days"}}
```
--------------------------------------------------

2025-08-21 22:45:34,410 - --- FULL CONTEXT (Session: df7e1f03-2ba5-457e-8b31-1a09c2af00c6) ---
--- REASON FOR CALL ---
Generating final summary from all collected tool data.

--- History ---
[user]: You are a helpful assistant.
[model]: Understood.
[user]: SYSTEM PROMPT:

# Core Directives
You are a specialized assistant for a Teradata database system. Your primary goal is to fulfill user requests by selecting the best capability (a tool or a prompt) from the categorized lists provided and supplying all necessary arguments.

# Response Format
Your response MUST be a single JSON object for a tool/prompt call OR a single plain text string for a final answer.

1.  **Tool/Prompt Calls (JSON format):**
    -   If the capability is a prompt, you MUST use the key `"prompt_name"`.
    -   If the capability is a tool, you MUST use the key `"tool_name"`.
    -   Provide all required arguments. Infer values from the conversation history if necessary.
    -   Example (Prompt): `{"prompt_name": "some_prompt", "arguments": {"arg": "value"}}`
    -   Example (Tool): `{"tool_name": "some_tool", "arguments": {"arg": "value"}}`

2.  **Final Answer (Plain Text format):**
    -   When you have sufficient information to fully answer the user's request, you MUST stop using tools.
    -   Your response MUST begin with the exact prefix `FINAL_ANSWER:`, followed by a natural language summary.
    -   Example: `FINAL_ANSWER: I found 48 databases on the system. The details are displayed below.`

# Decision Process
To select the correct capability, you MUST follow this two-step process, governed by one critical rule:

**CRITICAL RULE: Prioritize Specificity and Arguments.** Your primary filter for selecting a capability is its specificity. You MUST select the most granular capability that uses the most entities from the user's request (e.g., prefer a tool that uses a `table_name` over one that only uses a `database_name` if a table is mentioned). For direct actions and single analyses, you MUST select a `tool_name`; only select a `prompt_name` for broad, multi-step tasks explicitly described by the prompt.

1.  **Identify the Category:** First, analyze the user's request to determine which Tool or Prompt Category is the most relevant to their intent. The available categories are listed in the "Capabilities" section below.
2.  **Select the Capability:** Second, from within that single most relevant category, select the best tool or prompt to fulfill the request, adhering to the Critical Rule above.

# Few-Shot Examples
Here are examples of the correct thinking process:

**Example 1:**
- **User Query:** "what is the quality of table 'online' in database 'DEMO_Customer360_db'?"
- **Thought Process:**
    1.  The user's query is about a **table**.
    2.  My critical rule is to prioritize specificity. I must choose a table-level tool.
    3.  The `qlty_databaseQuality` prompt is for databases, not specific tables, so it's incorrect.
    4.  The `qlty_columnSummary` tool takes a `table_name` and is the most specific, correct choice.
- **Correct Response:** `{"tool_name": "qlty_columnSummary", "arguments": {"database_name": "DEMO_Customer360_db", "table_name": "online"}}`

**Example 2:**
- **User Query:** "describe the business purpose of the 'DEMO_Customer360_db' database"
- **Thought Process:**
    1.  The user's query is about a **database**. It's a broad request ("describe").
    2.  A prompt is better for broad tasks.
    3.  The `base_databaseBusinessDesc` prompt takes a `database_name` and is the correct choice.
- **Correct Response:** `{"prompt_name": "base_databaseBusinessDesc", "arguments": {"database_name": "DEMO_Customer360_db"}}`

**Example 3:**
- **User Query:** "what is the system utilization?"
- **Thought Process:**
    1.  The user is asking for a specific metric: "system utilization". This is a direct request for data.
    2.  My critical rule states I must prioritize a `tool_name` for direct actions.
    3.  The `dba_systemVoice` prompt is for adopting a persona, not for fetching specific metrics. It is the incorrect choice.
    4.  The `dba_resusageSummary` tool in the `Performance` category is designed to get system usage summary metrics. This is the correct choice.
- **Correct Response:** `{"tool_name": "dba_resusageSummary", "arguments": {}}`

# Best Practices
- **Context is Key:** Always use information from previous turns to fill in arguments like `db_name` or `table_name`.
- **Error Recovery:** If a tool fails, analyze the error message and attempt to call the tool again with corrected parameters. Only ask the user for clarification if you cannot recover.
- **SQL Generation:** When using the `base_readQuery` tool, you MUST use fully qualified table names in your SQL (e.g., `SELECT ... FROM my_database.my_table`).
- **Time-Sensitive Queries:** For queries involving relative dates (e.g., 'today', 'this week'), you MUST use the `util_getCurrentDate` tool first to determine the current date before proceeding.
- **Out of Scope:** If the user's request is unrelated to the available capabilities, respond with a `FINAL_ANSWER:` that politely explains you cannot fulfill the request and restates your purpose.
- **CRITICAL: Avoid Repetitive Behavior.** You are a highly intelligent agent. Do not get stuck in a loop by repeating the same tool calls or by cycling through the same set of tools. Once a tool has returned a successful result with data that is relevant to the user's request, do not call that same tool again unless there is a new and compelling reason to do so. If you have called a series of tools and believe you have enough information, you must call a FINAL_ANSWER. Do not repeat tool calls just to be "through".


# Capabilities
--- Available Tools ---
--- Category: Data Quality ---
- `qlty_columnSummary` (tool): 
Get the column summary statistics for a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_distinctCategories` (tool): 
Get the destinct categories from column in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_missingValues` (tool): 
Get the column names that having missing values in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_negativeValues` (tool): 
Get the column names that having negative values in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_rowsWithMissingValues` (tool): 
Get the rows with missing values in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_standardDeviation` (tool): 
Get the standard deviation from column in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_univariateStatistics` (tool): 
Get the univariate statistics for a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

--- Category: Data Visualization ---
- `viz_createChart` (tool): Generates a data visualization based on provided data. You must specify the chart type and map the data fields to the appropriate visual roles.
  - Arguments:
    - `chart_type` (string, required): The type of chart to generate (e.g., 'bar', 'pie', 'line', 'scatter'). This MUST be one of the types listed in the 'Charting Guidelines'.
    - `data` (list[dict], required): The data to be visualized, passed directly from the output of another tool.
    - `title` (string, required): A descriptive title for the chart.
    - `mapping` (dict, required): A dictionary that maps data keys to chart axes or roles (e.g., {'x_axis': 'product_name', 'y_axis': 'sales_total'}). The required keys for this mapping depend on the selected chart_type.
--- Category: Database Information ---
- `cust_td_serverInfo` (tool): Get the Teradata software information: demonstrates how to use parameters for prepared statements.
  - Arguments:
    - `infokey` (string, optional): No description.
- `dba_databaseVersion` (tool):  Get Teradata database version information.
- `base_databaseList` (tool): Lists all databases in the Teradata System.
--- Category: Database Space ---
- `dba_databaseSpace` (tool): 
Get database space if database name is provided, otherwise get all databases space allocations.

Arguments:
  database_name - database name

Returns:
  ResponseType: formatted response with query results + metadata

- `get_cube_cust_cube_db_space_metrics` (tool): 
    Tool to query the cube 'table_skew_pct'.
    Get the Teradata database space metrics for tables and databases

    Expected inputs:
        dimensions (str): Comma-separated dimension names to group by. Allowed values:
    - DatabaseName: Name of the database
    - TableName: Name of the table

        measures (str): Comma-separated measure names to aggregate. Allowed values:
    - current_perm: Object perm space in bytes
    - peak_perm: Object peak perm space in bytes
    - table_skew_pct: Object skew percentage

        filters (str): Comma-separated filter expressions to apply to either dimensions or measures selected. The dimension or measure used must be in the dimension list to group by or measure list, use valid SQL expressions, for example:
DatabaseName = 'value'
TableName = 'value'
current_perm > 1000
peak_perm > 1000
table_skew_pct > 1000

    Returns:
        Query result as a formatted response.
    
  - Arguments:
    - `dimensions` (string, optional): No description.
    - `measures` (string, optional): No description.
    - `filters` (string, optional): No description.
- `dba_systemSpace` (tool): Get the Teradata total system database space usage.
--- Category: Performance ---
- `dba_resusageSummary` (tool): 
Get the Teradata system usage summary metrics by weekday and hour for each workload type and query complexity bucket.

Arguments:
  dimensions - list of dimensions to aggregate the resource usage summary. All dimensions are: ["LogDate", "hourOfDay", "dayOfWeek", "workloadType", "workloadComplexity", "UserName", "AppId", "StatementType"]
  user_name - user name
  date - Date to analyze, formatted as `YYYY-MM-DD`
  dayOfWeek - day of the week to analyze
  hourOfDay - hour of day to analyze


- `dba_flowControl` (tool): Get the Teradata flow control metrics for a specified date range.
  - Arguments:
    - `start_date` (string, optional): No description.
    - `end_date` (string, optional): No description.
- `dba_userDelay` (tool): Get the Teradata user delay metrics for a specified date range.
  - Arguments:
    - `start_date` (string, optional): No description.
    - `end_date` (string, optional): No description.
--- Category: Query Execution ---
- `base_readQuery` (tool): 
Execute a SQL query via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  sql    - SQL text, with optional bind-parameter placeholders

Returns:
  ResponseType: formatted response with query results + metadata

--- Category: Sales Analytics ---
- `sales_top_customers` (tool): Get the top 20 customers by lifetime value.
- `sales_customer_profile` (tool): Get customer profile and metrics.
  - Arguments:
    - `customer_key` (string, optional): No description.
- `get_cube_sales_cube` (tool): 
    Tool to query the cube 'order_count'.
    Get the key sales metrics: USD amount and number of orders.

    Expected inputs:
        dimensions (str): Comma-separated dimension names to group by. Allowed values:
    - customer_key: Key for the customer
    - sales_year: Year of the sale
    - sales_month: Month of the sale

        measures (str): Comma-separated measure names to aggregate. Allowed values:
    - gift_amount_usd: Total gift card amount used for the order in USD
    - total_amount_usd: Total order amount in USD
    - order_count: Total number of orders

        filters (str): Comma-separated filter expressions to apply to either dimensions or measures selected. The dimension or measure used must be in the dimension list to group by or measure list, use valid SQL expressions, for example:
customer_key = 'value'
sales_year = 'value'
sales_month = 'value'
gift_amount_usd > 1000
total_amount_usd > 1000
order_count > 1000

    Returns:
        Query result as a formatted response.
    
  - Arguments:
    - `dimensions` (string, optional): No description.
    - `measures` (string, optional): No description.
    - `filters` (string, optional): No description.
--- Category: Security ---
- `sec_rolePermissions` (tool): 
Get permissions for a role.

Arguments:
  role_name - role name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `sec_userDbPermissions` (tool): 
Get permissions for a user.

Arguments:
  user_name - user name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `sec_userRoles` (tool): 
Get roles assigned to a user.

Arguments:
  user_name - user name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

--- Category: Session Management ---
- `dba_sessionInfo` (tool): Get the Teradata session information for user.
  - Arguments:
    - `user_name` (string, optional): No description.
--- Category: Table Management ---
- `dba_tableSpace` (tool): 
Get table space used for a table if table name is provided or get table space for all tables in a database if a database name is provided."

Arguments:
  database_name - database name
  table_name - table name

Returns:
  ResponseType: formatted response with query results + metadata

- `dba_tableSqlList` (tool): 
Get a list of SQL run against a table in the last number of days.

Arguments:
  table_name - table name
  no_days - number of days

Returns:
  ResponseType: formatted response with query results + metadata

- `dba_tableUsageImpact` (tool): 
Measure the usage of a table and views by users, this is helpful to understand what user and tables are driving most resource usage at any point in time.

Arguments:
  database_name - database name to analyze
  user_name - user name to analyze


- `base_columnDescription` (tool): 
Shows detailed column information about a database table via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name
  obj_name - table or view name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableAffinity` (tool): 
Get tables commonly used together by database users, this is helpful to infer relationships between tables via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name
  object_name - table or view name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableDDL` (tool): 
Displays the DDL definition of a table via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name
  table_name - table name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tablePreview` (tool): 
This function returns data sample and inferred structure from a database table or view via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  table_name - table or view name
  database_name - Database name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableUsage` (tool): 
Measure the usage of a table and views by users in a given schema, this is helpful to infer what database objects are most actively used or drive most value via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableList` (tool): Lists all tables in a database.
  - Arguments:
    - `database_name` (string, optional): No description.
--- Category: Usage Tracking ---
- `dba_featureUsage` (tool): Get the user feature usage metrics for a specified date range.
  - Arguments:
    - `start_date` (string, optional): No description.
    - `end_date` (string, optional): No description.
--- Category: User Management ---
- `dba_userSqlList` (tool): 
Get a list of SQL run by a user in the last number of days if a user name is provided, otherwise get list of all SQL in the last number of days.

Arguments:
  user_name - user name
  no_days - number of days

Returns:
  ResponseType: formatted response with query results + metadata

- `cust_activeUsers` (tool): Fetch currently active database users
--- Category: Utilities ---
- `tmpl_nameOfTool` (tool): 
<description of what the tool is for>

Arguments:
  arguments - arguments to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `evs_similarity_search` (tool): 
Enterprise Vector Store similarity search

Arguments:
  question - the query string to search for
  top_k - number of top results to return

Returns:
  ResponseType: formatted response with query results + metadata

- `rag_executeWorkflow` (tool): 
Execute complete RAG workflow to answer user questions based on document context.


This function handles the entire RAG pipeline:
1. Configuration setup (using configurable values from rag_config.yml)
2. Store user query (with /rag prefix stripping)
3. Generate query embeddings (tokenization + embedding)
4. Perform semantic search against chunk embeddings
5. Return retrieved context chunks for answer generation

The function uses configuration values from rag_config.yml with fallback defaults.

Arguments:
  question - user question to process
  k - number of top-k results to return (optional, uses config default if not provided)

Returns:
  Returns the top-k most relevant chunks with metadata for context-grounded answer generation.

- `rag_executeWorkflow_ivsm` (tool): 
Execute complete RAG workflow to answer user questions based on document context.

This function handles the entire RAG pipeline using IVSM functions:
1. Configuration setup (using configurable values from rag_config.yml)
2. Store user query (with /rag prefix stripping)
3. Tokenize query using ivsm.tokenizer_encode
4. Create embedding view using ivsm.IVSM_score
5. Convert embeddings to vector columns using ivsm.vector_to_columns
6. Perform semantic search against chunk embeddings

The function uses configuration values from rag_config.yml with fallback defaults.

Arguments:
  question - user question to process
  k - number of top-k results to return (optional, uses config default if not provided

Returns:
  Returns the top-k most relevant chunks with metadata for context-grounded answer generation.

- `util_getCurrentDate` (tool): Returns the current system date in YYYY-MM-DD format. Use this as the first step for any user query involving relative dates like 'today', 'yesterday', or 'this week'.
- `util_calculateDateRange` (tool): Calculates a list of dates based on a start date and a natural language phrase (e.g., 'past 3 days', 'last week'). This is a necessary second step for multi-day queries.
  - Arguments:
    - `start_date` (string, required): The anchor date for the calculation, usually today's date from `util_getCurrentDate`. Must be in YYYY-MM-DD format.
    - `date_phrase` (string, required): The natural language phrase describing the desired range (e.g., 'past 3 days', 'last 2 weeks').
- `CoreLLMTask` (tool): Performs internal, LLM-driven tasks that are not direct calls to the Teradata database. This tool is used for text synthesis, summarization, and formatting based on a specific 'task_description' provided by the LLM itself.
  - Arguments:
    - `task_description` (string, required): A natural language description of the internal task to be executed (e.g., 'describe the table in a business context', 'format final output'). The LLM infers this from the workflow plan.
    - `source_data` (list[string], required): A list of keys (e.g., 'result_of_phase_1') identifying which data from the workflow history is relevant for this task. This is critical for providing the correct context.
--- Available Prompts ---
--- Category: Prompts ---
- `base_query` (prompt): Help users interact with  Teradata databases effectively.
  - Arguments:
    - `query` (str, required): The problem or question that needs to be solved using Teradata database tools.
- `base_tableBusinessDesc` (prompt): You are a Teradata DBA who is an expert in describing the business use of tables in a database.
  - Arguments:
    - `database_name` (str, required): Database for the table to describe.
    - `table_name` (str, required): Table to describe.


USER PROMPT:

You are an expert strategic planning assistant. Your task is to analyze a user's request or a complex workflow goal and decompose it into a high-level, phased meta-plan. This plan will serve as a state machine executor.

--- GOAL ---
what is the system utilization of the past 3 days?

--- CONTEXT ---
- User's Original Question (for reference): what is the system utilization of the past 3 days?

--- INSTRUCTIONS ---
1.  **Analyze the Goal**: Carefully read the "GOAL" to understand the user's full intent.
2.  **Decompose into Phases**: Break down the overall goal into a sequence of logical phases. Each phase should represent a major step.
3.  **Define Each Phase**: For each phase, create a JSON object with the following keys:
    -   `"phase"`: An integer representing the step number (e.g., 1, 2, 3).
    -   `"goal"`: A clear, concise, and actionable description of what must be accomplished in this phase. This goal will guide a separate, tactical LLM.
    -   `"relevant_tools"`: A list of tool names that are permitted to be used during this phase. You MUST select the most appropriate and specific tools from the full "Capabilities" list provided in the main system prompt to achieve the phase's goal.
    -   (Optional) `"type": "loop"`: If a phase requires iterating over a list of items, you MUST include this key.
    -   (Optional) `"loop_over"`: If `"type"` is `"loop"`, specify the data source for the iteration (e.g., `"result_of_phase_1"`).
4.  **Embed Parameters**: When defining the `"goal"` for a phase, you MUST scan the main "GOAL" for any hardcoded arguments or parameters (e.g., table names, database names) relevant to that phase's task. You MUST embed these found parameters directly into the `"goal"` string to make it self-contained and explicit.
5.  **Final Synthesis and Formatting Phase**: If the main "GOAL" describes a multi-step process with a final reporting requirement, your plan **MUST** conclude with a single, final phase that handles both the synthesis of the final report AND its formatting. The `relevant_tools` for this final phase **MUST** be `["CoreLLMTask"]`.
6.  **CRITICAL RULE (Simplicity)**: If the "GOAL" is a simple, direct request that can be answered with a single tool call (e.g., "list all databases", "what is the system utilization?"), your plan **MUST** consist of only a single phase that calls the one most appropriate tool. Do not add unnecessary synthesis phases for simple data retrieval.
7.  **CRITICAL RULE (Execution Focus)**: Every phase you define **MUST** correspond to a concrete, tool-based action. You **MUST NOT** create phases for simple verification, confirmation, or acknowledgement of known information. Your plan must focus only on the execution steps required to gather new information or process existing data.
8.  **CRITICAL RULE (Capability Types)**: You are generating a plan of executable **tools**. The `relevant_tools` list **MUST ONLY** contain names of capabilities that are explicitly marked as `(tool)` in the system's "Capabilities" list. You **MUST NOT** include the name of any capability marked as `(prompt)`.
9.  **CRITICAL RULE (Efficiency)**: If a phase's `"goal"` already contains all the instructions for the final synthesis and formatting of the report (as specified in the main "GOAL"), you **MUST** make this the last phase of the plan. Do not add a separate, redundant formatting-only phase after it.

--- EXAMPLE (Complex Goal) ---
If the main goal requires getting DDL and then describing/formatting, your output should be a two-phase plan like this:
```json
[
  {
    "phase": 1,
    "goal": "Get the DDL for the table 'customers' in database 'sales' using the `base_tableDDL` tool.",
    "relevant_tools": ["base_tableDDL"]
  },
  {
    "phase": 2,
    "goal": "Synthesize a final report by describing the 'customers' table in a business context and format the output as markdown according to the Final output guidelines, using `***` for keys.",
    "relevant_tools": ["CoreLLMTask"]
  }
]
```

--- EXAMPLE (Simple Goal) ---
If the main goal is "what is the system utilization?", your output should be a single-phase plan like this:
```json
[
  {
    "phase": 1,
    "goal": "Get the system utilization using the `dba_resusageSummary` tool.",
    "relevant_tools": ["dba_resusageSummary"]
  }
]
```

--- EXAMPLE (Date Range Goal) ---
If the main goal is "what is the system utilization for the past 3 days?", your output must be a three-phase plan like this:
```json
[
  {
    "phase": 1,
    "goal": "Get the current date using the `util_getCurrentDate` tool to establish a reference point.",
    "relevant_tools": ["util_getCurrentDate"]
  },
  {
    "phase": 2,
    "goal": "Calculate the list of dates for 'the past 3 days' using the `util_calculateDateRange` tool.",
    "relevant_tools": ["util_calculateDateRange"]
  },
  {
    "phase": 3,
    "goal": "For each date calculated in the previous step, get the system utilization using the `dba_resusageSummary` tool.",
    "relevant_tools": ["dba_resusageSummary"],
    "type": "loop",
    "loop_over": "result_of_phase_2"
  }
]
```

Your response MUST be a single, valid JSON list of phase objects. Do NOT add any extra text, conversation, or markdown.

[model]: ```json
[
  {
    "phase": 1,
    "goal": "Get the current date using the `util_getCurrentDate` tool to establish a reference point.",
    "relevant_tools": ["util_getCurrentDate"]
  },
  {
    "phase": 2,
    "goal": "Calculate the list of dates for 'past 3 days' using the `util_calculateDateRange` tool.",
    "relevant_tools": ["util_calculateDateRange"]
  },
  {
    "phase": 3,
    "goal": "For each date calculated in the previous step, get the system utilization using the `dba_resusageSummary` tool.",
    "relevant_tools": ["dba_resusageSummary"],
    "type": "loop",
    "loop_over": "result_of_phase_2"
  }
]
```
[user]: SYSTEM PROMPT:

You are a tactical assistant executing a single phase of a larger plan. Your task is to decide the single best next action to take to achieve the current phase's goal, strictly adhering to the provided tool constraints.

--- OVERALL WORKFLOW GOAL ---
what is the system utilization of the past 3 days?

--- CURRENT PHASE GOAL ---
Get the current date using the `util_getCurrentDate` tool to establish a reference point.

--- CONSTRAINTS ---
- Permitted Tools for this Phase (You MUST use the exact argument names provided):

- Tool: `util_getCurrentDate`
  - Description: Returns the current system date in YYYY-MM-DD format. Use this as the first step for any user query involving relative dates like 'today', 'yesterday', or 'this week'.

- Previous Attempt (if any): None

--- WORKFLOW STATE & HISTORY ---
- Actions Taken So Far: []
- Data Collected So Far: {}

--- INSTRUCTIONS ---
1.  **Analyze the State**: Review the "CURRENT PHASE GOAL" and the "WORKFLOW STATE & HISTORY" to understand what has been done and what is needed next.
2.  **CRITICAL RULE (Tool Selection & Arguments)**: You **MUST** select your next action from the list of "Permitted Tools for this Phase". You are not allowed to use any other tool. Furthermore, you **MUST** use the exact argument names as they are defined in the tool details above. You **MUST NOT** invent, hallucinate, or use any arguments that are not explicitly listed in the definitions.
3.  **Self-Correction**: If a "Previous Attempt" is noted in the "CONSTRAINTS" section, it means your last choice was invalid. You **MUST** analyze the error and choose a different, valid tool from the permitted list. Do not repeat the invalid choice.
4.  **CoreLLMTask Usage**:
    -   For any task that involves synthesis, analysis, description, or summarization, you **MUST** use the `CoreLLMTask` tool, but only if it is in the permitted tools list.
    -   When calling `CoreLLMTask`, you **MUST** provide the `task_description` argument.
    -   Crucially, you **MUST** also determine which previous phase results are necessary for the task. You **MUST** provide these as a list of strings in the `source_data` argument.
    -   **CONTEXT PRESERVATION RULE**: If the current phase involves creating a final summary or report for the user, you **MUST** ensure you have all the necessary context. Your `source_data` list **MUST** include the results from **ALL** previous data-gathering phases (e.g., `["result_of_phase_1", "result_of_phase_2"]`) to prevent information loss.
5.  **Handle Loops**: If you are in a looping phase (indicated by the presence of a "LOOP CONTEXT" section), you **MUST** focus your action on the single item provided in `current_loop_item`. You **MUST** use the information within that item to formulate the arguments for your tool call.
6.  **Format Response**: Your response MUST be a single JSON object for a tool call.

Your response MUST be a single, valid JSON object for a tool call. Do NOT add any extra text or conversation.


USER PROMPT:
Determine the next action based on the instructions and state provided in the system prompt.
[model]: ```json
{"tool_name": "util_getCurrentDate", "arguments": {}}
```
[user]: SYSTEM PROMPT:

You are a tactical assistant executing a single phase of a larger plan. Your task is to decide the single best next action to take to achieve the current phase's goal, strictly adhering to the provided tool constraints.

--- OVERALL WORKFLOW GOAL ---
what is the system utilization of the past 3 days?

--- CURRENT PHASE GOAL ---
Calculate the list of dates for 'past 3 days' using the `util_calculateDateRange` tool.

--- CONSTRAINTS ---
- Permitted Tools for this Phase (You MUST use the exact argument names provided):

- Tool: `util_calculateDateRange`
  - Description: Calculates a list of dates based on a start date and a natural language phrase (e.g., 'past 3 days', 'last week'). This is a necessary second step for multi-day queries.
  - Arguments:
    - `start_date` (string, required): The anchor date for the calculation, usually today's date from `util_getCurrentDate`. Must be in YYYY-MM-DD format.
    - `date_phrase` (string, required): The natural language phrase describing the desired range (e.g., 'past 3 days', 'last 2 weeks').

- Previous Attempt (if any): None

--- WORKFLOW STATE & HISTORY ---
- Actions Taken So Far: [
  {
    "action": {
      "tool_name": "util_getCurrentDate",
      "arguments": {}
    },
    "result": {
      "status": "success",
      "metadata": {
        "tool_name": "util_getCurrentDate"
      },
      "results": [
        {
          "current_date": "2025-08-21"
        }
      ]
    }
  }
]
- Data Collected So Far: {
  "result_of_phase_1": [
    {
      "status": "success",
      "metadata": {
        "tool_name": "util_getCurrentDate"
      },
      "results": [
        {
          "current_date": "2025-08-21"
        }
      ]
    }
  ]
}

--- INSTRUCTIONS ---
1.  **Analyze the State**: Review the "CURRENT PHASE GOAL" and the "WORKFLOW STATE & HISTORY" to understand what has been done and what is needed next.
2.  **CRITICAL RULE (Tool Selection & Arguments)**: You **MUST** select your next action from the list of "Permitted Tools for this Phase". You are not allowed to use any other tool. Furthermore, you **MUST** use the exact argument names as they are defined in the tool details above. You **MUST NOT** invent, hallucinate, or use any arguments that are not explicitly listed in the definitions.
3.  **Self-Correction**: If a "Previous Attempt" is noted in the "CONSTRAINTS" section, it means your last choice was invalid. You **MUST** analyze the error and choose a different, valid tool from the permitted list. Do not repeat the invalid choice.
4.  **CoreLLMTask Usage**:
    -   For any task that involves synthesis, analysis, description, or summarization, you **MUST** use the `CoreLLMTask` tool, but only if it is in the permitted tools list.
    -   When calling `CoreLLMTask`, you **MUST** provide the `task_description` argument.
    -   Crucially, you **MUST** also determine which previous phase results are necessary for the task. You **MUST** provide these as a list of strings in the `source_data` argument.
    -   **CONTEXT PRESERVATION RULE**: If the current phase involves creating a final summary or report for the user, you **MUST** ensure you have all the necessary context. Your `source_data` list **MUST** include the results from **ALL** previous data-gathering phases (e.g., `["result_of_phase_1", "result_of_phase_2"]`) to prevent information loss.
5.  **Handle Loops**: If you are in a looping phase (indicated by the presence of a "LOOP CONTEXT" section), you **MUST** focus your action on the single item provided in `current_loop_item`. You **MUST** use the information within that item to formulate the arguments for your tool call.
6.  **Format Response**: Your response MUST be a single JSON object for a tool call.

Your response MUST be a single, valid JSON object for a tool call. Do NOT add any extra text or conversation.


USER PROMPT:
Determine the next action based on the instructions and state provided in the system prompt.
[model]: ```json
{"tool_name": "util_calculateDateRange", "arguments": {"start_date": "2025-08-21", "date_phrase": "past 3 days"}}
```

--- Current User Prompt (with System Prompt) ---
SYSTEM PROMPT:

# Core Directives
You are a specialized assistant for a Teradata database system. Your primary goal is to fulfill user requests by selecting the best capability (a tool or a prompt) from the categorized lists provided and supplying all necessary arguments.

# Response Format
Your response MUST be a single JSON object for a tool/prompt call OR a single plain text string for a final answer.

1.  **Tool/Prompt Calls (JSON format):**
    -   If the capability is a prompt, you MUST use the key `"prompt_name"`.
    -   If the capability is a tool, you MUST use the key `"tool_name"`.
    -   Provide all required arguments. Infer values from the conversation history if necessary.
    -   Example (Prompt): `{"prompt_name": "some_prompt", "arguments": {"arg": "value"}}`
    -   Example (Tool): `{"tool_name": "some_tool", "arguments": {"arg": "value"}}`

2.  **Final Answer (Plain Text format):**
    -   When you have sufficient information to fully answer the user's request, you MUST stop using tools.
    -   Your response MUST begin with the exact prefix `FINAL_ANSWER:`, followed by a natural language summary.
    -   Example: `FINAL_ANSWER: I found 48 databases on the system. The details are displayed below.`

# Decision Process
To select the correct capability, you MUST follow this two-step process, governed by one critical rule:

**CRITICAL RULE: Prioritize Specificity and Arguments.** Your primary filter for selecting a capability is its specificity. You MUST select the most granular capability that uses the most entities from the user's request (e.g., prefer a tool that uses a `table_name` over one that only uses a `database_name` if a table is mentioned). For direct actions and single analyses, you MUST select a `tool_name`; only select a `prompt_name` for broad, multi-step tasks explicitly described by the prompt.

1.  **Identify the Category:** First, analyze the user's request to determine which Tool or Prompt Category is the most relevant to their intent. The available categories are listed in the "Capabilities" section below.
2.  **Select the Capability:** Second, from within that single most relevant category, select the best tool or prompt to fulfill the request, adhering to the Critical Rule above.

# Few-Shot Examples
Here are examples of the correct thinking process:

**Example 1:**
- **User Query:** "what is the quality of table 'online' in database 'DEMO_Customer360_db'?"
- **Thought Process:**
    1.  The user's query is about a **table**.
    2.  My critical rule is to prioritize specificity. I must choose a table-level tool.
    3.  The `qlty_databaseQuality` prompt is for databases, not specific tables, so it's incorrect.
    4.  The `qlty_columnSummary` tool takes a `table_name` and is the most specific, correct choice.
- **Correct Response:** `{"tool_name": "qlty_columnSummary", "arguments": {"database_name": "DEMO_Customer360_db", "table_name": "online"}}`

**Example 2:**
- **User Query:** "describe the business purpose of the 'DEMO_Customer360_db' database"
- **Thought Process:**
    1.  The user's query is about a **database**. It's a broad request ("describe").
    2.  A prompt is better for broad tasks.
    3.  The `base_databaseBusinessDesc` prompt takes a `database_name` and is the correct choice.
- **Correct Response:** `{"prompt_name": "base_databaseBusinessDesc", "arguments": {"database_name": "DEMO_Customer360_db"}}`

**Example 3:**
- **User Query:** "what is the system utilization?"
- **Thought Process:**
    1.  The user is asking for a specific metric: "system utilization". This is a direct request for data.
    2.  My critical rule states I must prioritize a `tool_name` for direct actions.
    3.  The `dba_systemVoice` prompt is for adopting a persona, not for fetching specific metrics. It is the incorrect choice.
    4.  The `dba_resusageSummary` tool in the `Performance` category is designed to get system usage summary metrics. This is the correct choice.
- **Correct Response:** `{"tool_name": "dba_resusageSummary", "arguments": {}}`

# Best Practices
- **Context is Key:** Always use information from previous turns to fill in arguments like `db_name` or `table_name`.
- **Error Recovery:** If a tool fails, analyze the error message and attempt to call the tool again with corrected parameters. Only ask the user for clarification if you cannot recover.
- **SQL Generation:** When using the `base_readQuery` tool, you MUST use fully qualified table names in your SQL (e.g., `SELECT ... FROM my_database.my_table`).
- **Time-Sensitive Queries:** For queries involving relative dates (e.g., 'today', 'this week'), you MUST use the `util_getCurrentDate` tool first to determine the current date before proceeding.
- **Out of Scope:** If the user's request is unrelated to the available capabilities, respond with a `FINAL_ANSWER:` that politely explains you cannot fulfill the request and restates your purpose.
- **CRITICAL: Avoid Repetitive Behavior.** You are a highly intelligent agent. Do not get stuck in a loop by repeating the same tool calls or by cycling through the same set of tools. Once a tool has returned a successful result with data that is relevant to the user's request, do not call that same tool again unless there is a new and compelling reason to do so. If you have called a series of tools and believe you have enough information, you must call a FINAL_ANSWER. Do not repeat tool calls just to be "through".


# Capabilities
--- Available Tools ---
--- Category: Data Quality ---
- `qlty_columnSummary` (tool): 
Get the column summary statistics for a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_distinctCategories` (tool): 
Get the destinct categories from column in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_missingValues` (tool): 
Get the column names that having missing values in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_negativeValues` (tool): 
Get the column names that having negative values in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_rowsWithMissingValues` (tool): 
Get the rows with missing values in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_standardDeviation` (tool): 
Get the standard deviation from column in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_univariateStatistics` (tool): 
Get the univariate statistics for a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

--- Category: Data Visualization ---
- `viz_createChart` (tool): Generates a data visualization based on provided data. You must specify the chart type and map the data fields to the appropriate visual roles.
  - Arguments:
    - `chart_type` (string, required): The type of chart to generate (e.g., 'bar', 'pie', 'line', 'scatter'). This MUST be one of the types listed in the 'Charting Guidelines'.
    - `data` (list[dict], required): The data to be visualized, passed directly from the output of another tool.
    - `title` (string, required): A descriptive title for the chart.
    - `mapping` (dict, required): A dictionary that maps data keys to chart axes or roles (e.g., {'x_axis': 'product_name', 'y_axis': 'sales_total'}). The required keys for this mapping depend on the selected chart_type.
--- Category: Database Information ---
- `cust_td_serverInfo` (tool): Get the Teradata software information: demonstrates how to use parameters for prepared statements.
  - Arguments:
    - `infokey` (string, optional): No description.
- `dba_databaseVersion` (tool):  Get Teradata database version information.
- `base_databaseList` (tool): Lists all databases in the Teradata System.
--- Category: Database Space ---
- `dba_databaseSpace` (tool): 
Get database space if database name is provided, otherwise get all databases space allocations.

Arguments:
  database_name - database name

Returns:
  ResponseType: formatted response with query results + metadata

- `get_cube_cust_cube_db_space_metrics` (tool): 
    Tool to query the cube 'table_skew_pct'.
    Get the Teradata database space metrics for tables and databases

    Expected inputs:
        dimensions (str): Comma-separated dimension names to group by. Allowed values:
    - DatabaseName: Name of the database
    - TableName: Name of the table

        measures (str): Comma-separated measure names to aggregate. Allowed values:
    - current_perm: Object perm space in bytes
    - peak_perm: Object peak perm space in bytes
    - table_skew_pct: Object skew percentage

        filters (str): Comma-separated filter expressions to apply to either dimensions or measures selected. The dimension or measure used must be in the dimension list to group by or measure list, use valid SQL expressions, for example:
DatabaseName = 'value'
TableName = 'value'
current_perm > 1000
peak_perm > 1000
table_skew_pct > 1000

    Returns:
        Query result as a formatted response.
    
  - Arguments:
    - `dimensions` (string, optional): No description.
    - `measures` (string, optional): No description.
    - `filters` (string, optional): No description.
- `dba_systemSpace` (tool): Get the Teradata total system database space usage.
--- Category: Performance ---
- `dba_resusageSummary` (tool): 
Get the Teradata system usage summary metrics by weekday and hour for each workload type and query complexity bucket.

Arguments:
  dimensions - list of dimensions to aggregate the resource usage summary. All dimensions are: ["LogDate", "hourOfDay", "dayOfWeek", "workloadType", "workloadComplexity", "UserName", "AppId", "StatementType"]
  user_name - user name
  date - Date to analyze, formatted as `YYYY-MM-DD`
  dayOfWeek - day of the week to analyze
  hourOfDay - hour of day to analyze


- `dba_flowControl` (tool): Get the Teradata flow control metrics for a specified date range.
  - Arguments:
    - `start_date` (string, optional): No description.
    - `end_date` (string, optional): No description.
- `dba_userDelay` (tool): Get the Teradata user delay metrics for a specified date range.
  - Arguments:
    - `start_date` (string, optional): No description.
    - `end_date` (string, optional): No description.
--- Category: Query Execution ---
- `base_readQuery` (tool): 
Execute a SQL query via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  sql    - SQL text, with optional bind-parameter placeholders

Returns:
  ResponseType: formatted response with query results + metadata

--- Category: Sales Analytics ---
- `sales_top_customers` (tool): Get the top 20 customers by lifetime value.
- `sales_customer_profile` (tool): Get customer profile and metrics.
  - Arguments:
    - `customer_key` (string, optional): No description.
- `get_cube_sales_cube` (tool): 
    Tool to query the cube 'order_count'.
    Get the key sales metrics: USD amount and number of orders.

    Expected inputs:
        dimensions (str): Comma-separated dimension names to group by. Allowed values:
    - customer_key: Key for the customer
    - sales_year: Year of the sale
    - sales_month: Month of the sale

        measures (str): Comma-separated measure names to aggregate. Allowed values:
    - gift_amount_usd: Total gift card amount used for the order in USD
    - total_amount_usd: Total order amount in USD
    - order_count: Total number of orders

        filters (str): Comma-separated filter expressions to apply to either dimensions or measures selected. The dimension or measure used must be in the dimension list to group by or measure list, use valid SQL expressions, for example:
customer_key = 'value'
sales_year = 'value'
sales_month = 'value'
gift_amount_usd > 1000
total_amount_usd > 1000
order_count > 1000

    Returns:
        Query result as a formatted response.
    
  - Arguments:
    - `dimensions` (string, optional): No description.
    - `measures` (string, optional): No description.
    - `filters` (string, optional): No description.
--- Category: Security ---
- `sec_rolePermissions` (tool): 
Get permissions for a role.

Arguments:
  role_name - role name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `sec_userDbPermissions` (tool): 
Get permissions for a user.

Arguments:
  user_name - user name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `sec_userRoles` (tool): 
Get roles assigned to a user.

Arguments:
  user_name - user name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

--- Category: Session Management ---
- `dba_sessionInfo` (tool): Get the Teradata session information for user.
  - Arguments:
    - `user_name` (string, optional): No description.
--- Category: Table Management ---
- `dba_tableSpace` (tool): 
Get table space used for a table if table name is provided or get table space for all tables in a database if a database name is provided."

Arguments:
  database_name - database name
  table_name - table name

Returns:
  ResponseType: formatted response with query results + metadata

- `dba_tableSqlList` (tool): 
Get a list of SQL run against a table in the last number of days.

Arguments:
  table_name - table name
  no_days - number of days

Returns:
  ResponseType: formatted response with query results + metadata

- `dba_tableUsageImpact` (tool): 
Measure the usage of a table and views by users, this is helpful to understand what user and tables are driving most resource usage at any point in time.

Arguments:
  database_name - database name to analyze
  user_name - user name to analyze


- `base_columnDescription` (tool): 
Shows detailed column information about a database table via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name
  obj_name - table or view name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableAffinity` (tool): 
Get tables commonly used together by database users, this is helpful to infer relationships between tables via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name
  object_name - table or view name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableDDL` (tool): 
Displays the DDL definition of a table via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name
  table_name - table name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tablePreview` (tool): 
This function returns data sample and inferred structure from a database table or view via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  table_name - table or view name
  database_name - Database name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableUsage` (tool): 
Measure the usage of a table and views by users in a given schema, this is helpful to infer what database objects are most actively used or drive most value via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableList` (tool): Lists all tables in a database.
  - Arguments:
    - `database_name` (string, optional): No description.
--- Category: Usage Tracking ---
- `dba_featureUsage` (tool): Get the user feature usage metrics for a specified date range.
  - Arguments:
    - `start_date` (string, optional): No description.
    - `end_date` (string, optional): No description.
--- Category: User Management ---
- `dba_userSqlList` (tool): 
Get a list of SQL run by a user in the last number of days if a user name is provided, otherwise get list of all SQL in the last number of days.

Arguments:
  user_name - user name
  no_days - number of days

Returns:
  ResponseType: formatted response with query results + metadata

- `cust_activeUsers` (tool): Fetch currently active database users
--- Category: Utilities ---
- `tmpl_nameOfTool` (tool): 
<description of what the tool is for>

Arguments:
  arguments - arguments to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `evs_similarity_search` (tool): 
Enterprise Vector Store similarity search

Arguments:
  question - the query string to search for
  top_k - number of top results to return

Returns:
  ResponseType: formatted response with query results + metadata

- `rag_executeWorkflow` (tool): 
Execute complete RAG workflow to answer user questions based on document context.


This function handles the entire RAG pipeline:
1. Configuration setup (using configurable values from rag_config.yml)
2. Store user query (with /rag prefix stripping)
3. Generate query embeddings (tokenization + embedding)
4. Perform semantic search against chunk embeddings
5. Return retrieved context chunks for answer generation

The function uses configuration values from rag_config.yml with fallback defaults.

Arguments:
  question - user question to process
  k - number of top-k results to return (optional, uses config default if not provided)

Returns:
  Returns the top-k most relevant chunks with metadata for context-grounded answer generation.

- `rag_executeWorkflow_ivsm` (tool): 
Execute complete RAG workflow to answer user questions based on document context.

This function handles the entire RAG pipeline using IVSM functions:
1. Configuration setup (using configurable values from rag_config.yml)
2. Store user query (with /rag prefix stripping)
3. Tokenize query using ivsm.tokenizer_encode
4. Create embedding view using ivsm.IVSM_score
5. Convert embeddings to vector columns using ivsm.vector_to_columns
6. Perform semantic search against chunk embeddings

The function uses configuration values from rag_config.yml with fallback defaults.

Arguments:
  question - user question to process
  k - number of top-k results to return (optional, uses config default if not provided

Returns:
  Returns the top-k most relevant chunks with metadata for context-grounded answer generation.

- `util_getCurrentDate` (tool): Returns the current system date in YYYY-MM-DD format. Use this as the first step for any user query involving relative dates like 'today', 'yesterday', or 'this week'.
- `util_calculateDateRange` (tool): Calculates a list of dates based on a start date and a natural language phrase (e.g., 'past 3 days', 'last week'). This is a necessary second step for multi-day queries.
  - Arguments:
    - `start_date` (string, required): The anchor date for the calculation, usually today's date from `util_getCurrentDate`. Must be in YYYY-MM-DD format.
    - `date_phrase` (string, required): The natural language phrase describing the desired range (e.g., 'past 3 days', 'last 2 weeks').
- `CoreLLMTask` (tool): Performs internal, LLM-driven tasks that are not direct calls to the Teradata database. This tool is used for text synthesis, summarization, and formatting based on a specific 'task_description' provided by the LLM itself.
  - Arguments:
    - `task_description` (string, required): A natural language description of the internal task to be executed (e.g., 'describe the table in a business context', 'format final output'). The LLM infers this from the workflow plan.
    - `source_data` (list[string], required): A list of keys (e.g., 'result_of_phase_1') identifying which data from the workflow history is relevant for this task. This is critical for providing the correct context.
--- Available Prompts ---
--- Category: Prompts ---
- `base_query` (prompt): Help users interact with  Teradata databases effectively.
  - Arguments:
    - `query` (str, required): The problem or question that needs to be solved using Teradata database tools.
- `base_tableBusinessDesc` (prompt): You are a Teradata DBA who is an expert in describing the business use of tables in a database.
  - Arguments:
    - `database_name` (str, required): Database for the table to describe.
    - `table_name` (str, required): Table to describe.


USER PROMPT:
You are an expert data analyst. Synthesize all collected data into a clear, concise, and insightful final answer.

--- USER'S QUESTION ---
'what is the system utilization of the past 3 days?'

--- DATA COLLECTED ---
```json
[
  {
    "status": "success",
    "metadata": {
      "tool_name": "util_getCurrentDate"
    },
    "results": [
      {
        "current_date": "2025-08-21"
      }
    ]
  },
  {
    "status": "success",
    "metadata": {
      "tool_name": "util_calculateDateRange"
    },
    "results": [
      {
        "date": "2025-08-18"
      },
      {
        "date": "2025-08-19"
      },
      {
        "date": "2025-08-20"
      }
    ]
  },
  {
    "status": "success",
    "metadata": {
      "tool_name": "dba_resusageSummary",
      "total_rows": 1,
      "comment": "Total system resource usage summary."
    },
    "results": [
      {
        "Request Count": "0",
        "Total AMPCPUTime": "None",
        "Total IOCount": "None",
        "Total ReqIOKB": "None",
        "Total ReqPhysIO": "None",
        "Total ReqPhysIOKB": "None",
        "Total ReqIO GB": "None",
        "Total ReqPhysIOGB": "None",
        "Total Server Byte Count": "None"
      }
    ]
  },
  {
    "status": "success",
    "metadata": {
      "tool_name": "dba_resusageSummary",
      "total_rows": 1,
      "comment": "Total system resource usage summary."
    },
    "results": [
      {
        "Request Count": "283",
        "Total AMPCPUTime": "1.1800000000000002",
        "Total IOCount": "15931.0",
        "Total ReqIOKB": "741228.0",
        "Total ReqPhysIO": "44.0",
        "Total ReqPhysIOKB": "904.0",
        "Total ReqIO GB": "0.7068901062011719",
        "Total ReqPhysIOGB": "0.00086212158203125",
        "Total Server Byte Count": "0"
      }
    ]
  },
  {
    "status": "success",
    "metadata": {
      "tool_name": "dba_resusageSummary",
      "total_rows": 1,
      "comment": "Total system resource usage summary."
    },
    "results": [
      {
        "Request Count": "121",
        "Total AMPCPUTime": "0.316",
        "Total IOCount": "3929.0",
        "Total ReqIOKB": "163096.0",
        "Total ReqPhysIO": "8.0",
        "Total ReqPhysIOKB": "184.0",
        "Total ReqIO GB": "0.15554046630859375",
        "Total ReqPhysIOGB": "0.00017547607421875",
        "Total Server Byte Count": "0"
      }
    ]
  }
]
```

--- INSTRUCTIONS ---
1.  Provide a holistic analysis and actionable insights.
2.  Begin with a high-level summary, then use bullet points for key observations.
3.  Your entire response **MUST** begin with `FINAL_ANSWER:`.


2025-08-21 22:45:34,411 - --- RESPONSE ---
FINAL_ANSWER: The system utilization for the past 3 days (2025-08-18 to 2025-08-20) shows varying levels of activity.

*   **2025-08-18:** No resource usage data was found for this date.
*   **2025-08-19:** The system processed 283 requests, consuming 1.18 AMP CPU seconds and performing 15931 I/O operations, with a total of 741228 KB of I/O.
*   **2025-08-20:** The system processed 121 requests, consuming 0.316 AMP CPU seconds and performing 3929 I/O operations, with a total of 163096 KB of I/O.
--------------------------------------------------

2025-08-21 22:46:01,345 - --- FULL CONTEXT (Session: df7e1f03-2ba5-457e-8b31-1a09c2af00c6) ---
--- REASON FOR CALL ---
Generating a strategic meta-plan for the goal: 'what is the system utilization of the past 2 weeks?...'

--- History ---
[user]: You are a helpful assistant.
[model]: Understood.
[user]: SYSTEM PROMPT:

# Core Directives
You are a specialized assistant for a Teradata database system. Your primary goal is to fulfill user requests by selecting the best capability (a tool or a prompt) from the categorized lists provided and supplying all necessary arguments.

# Response Format
Your response MUST be a single JSON object for a tool/prompt call OR a single plain text string for a final answer.

1.  **Tool/Prompt Calls (JSON format):**
    -   If the capability is a prompt, you MUST use the key `"prompt_name"`.
    -   If the capability is a tool, you MUST use the key `"tool_name"`.
    -   Provide all required arguments. Infer values from the conversation history if necessary.
    -   Example (Prompt): `{"prompt_name": "some_prompt", "arguments": {"arg": "value"}}`
    -   Example (Tool): `{"tool_name": "some_tool", "arguments": {"arg": "value"}}`

2.  **Final Answer (Plain Text format):**
    -   When you have sufficient information to fully answer the user's request, you MUST stop using tools.
    -   Your response MUST begin with the exact prefix `FINAL_ANSWER:`, followed by a natural language summary.
    -   Example: `FINAL_ANSWER: I found 48 databases on the system. The details are displayed below.`

# Decision Process
To select the correct capability, you MUST follow this two-step process, governed by one critical rule:

**CRITICAL RULE: Prioritize Specificity and Arguments.** Your primary filter for selecting a capability is its specificity. You MUST select the most granular capability that uses the most entities from the user's request (e.g., prefer a tool that uses a `table_name` over one that only uses a `database_name` if a table is mentioned). For direct actions and single analyses, you MUST select a `tool_name`; only select a `prompt_name` for broad, multi-step tasks explicitly described by the prompt.

1.  **Identify the Category:** First, analyze the user's request to determine which Tool or Prompt Category is the most relevant to their intent. The available categories are listed in the "Capabilities" section below.
2.  **Select the Capability:** Second, from within that single most relevant category, select the best tool or prompt to fulfill the request, adhering to the Critical Rule above.

# Few-Shot Examples
Here are examples of the correct thinking process:

**Example 1:**
- **User Query:** "what is the quality of table 'online' in database 'DEMO_Customer360_db'?"
- **Thought Process:**
    1.  The user's query is about a **table**.
    2.  My critical rule is to prioritize specificity. I must choose a table-level tool.
    3.  The `qlty_databaseQuality` prompt is for databases, not specific tables, so it's incorrect.
    4.  The `qlty_columnSummary` tool takes a `table_name` and is the most specific, correct choice.
- **Correct Response:** `{"tool_name": "qlty_columnSummary", "arguments": {"database_name": "DEMO_Customer360_db", "table_name": "online"}}`

**Example 2:**
- **User Query:** "describe the business purpose of the 'DEMO_Customer360_db' database"
- **Thought Process:**
    1.  The user's query is about a **database**. It's a broad request ("describe").
    2.  A prompt is better for broad tasks.
    3.  The `base_databaseBusinessDesc` prompt takes a `database_name` and is the correct choice.
- **Correct Response:** `{"prompt_name": "base_databaseBusinessDesc", "arguments": {"database_name": "DEMO_Customer360_db"}}`

**Example 3:**
- **User Query:** "what is the system utilization?"
- **Thought Process:**
    1.  The user is asking for a specific metric: "system utilization". This is a direct request for data.
    2.  My critical rule states I must prioritize a `tool_name` for direct actions.
    3.  The `dba_systemVoice` prompt is for adopting a persona, not for fetching specific metrics. It is the incorrect choice.
    4.  The `dba_resusageSummary` tool in the `Performance` category is designed to get system usage summary metrics. This is the correct choice.
- **Correct Response:** `{"tool_name": "dba_resusageSummary", "arguments": {}}`

# Best Practices
- **Context is Key:** Always use information from previous turns to fill in arguments like `db_name` or `table_name`.
- **Error Recovery:** If a tool fails, analyze the error message and attempt to call the tool again with corrected parameters. Only ask the user for clarification if you cannot recover.
- **SQL Generation:** When using the `base_readQuery` tool, you MUST use fully qualified table names in your SQL (e.g., `SELECT ... FROM my_database.my_table`).
- **Time-Sensitive Queries:** For queries involving relative dates (e.g., 'today', 'this week'), you MUST use the `util_getCurrentDate` tool first to determine the current date before proceeding.
- **Out of Scope:** If the user's request is unrelated to the available capabilities, respond with a `FINAL_ANSWER:` that politely explains you cannot fulfill the request and restates your purpose.
- **CRITICAL: Avoid Repetitive Behavior.** You are a highly intelligent agent. Do not get stuck in a loop by repeating the same tool calls or by cycling through the same set of tools. Once a tool has returned a successful result with data that is relevant to the user's request, do not call that same tool again unless there is a new and compelling reason to do so. If you have called a series of tools and believe you have enough information, you must call a FINAL_ANSWER. Do not repeat tool calls just to be "through".


# Capabilities
--- Available Tools ---
--- Category: Data Quality ---
- `qlty_columnSummary` (tool): 
Get the column summary statistics for a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_distinctCategories` (tool): 
Get the destinct categories from column in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_missingValues` (tool): 
Get the column names that having missing values in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_negativeValues` (tool): 
Get the column names that having negative values in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_rowsWithMissingValues` (tool): 
Get the rows with missing values in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_standardDeviation` (tool): 
Get the standard deviation from column in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_univariateStatistics` (tool): 
Get the univariate statistics for a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

--- Category: Data Visualization ---
- `viz_createChart` (tool): Generates a data visualization based on provided data. You must specify the chart type and map the data fields to the appropriate visual roles.
  - Arguments:
    - `chart_type` (string, required): The type of chart to generate (e.g., 'bar', 'pie', 'line', 'scatter'). This MUST be one of the types listed in the 'Charting Guidelines'.
    - `data` (list[dict], required): The data to be visualized, passed directly from the output of another tool.
    - `title` (string, required): A descriptive title for the chart.
    - `mapping` (dict, required): A dictionary that maps data keys to chart axes or roles (e.g., {'x_axis': 'product_name', 'y_axis': 'sales_total'}). The required keys for this mapping depend on the selected chart_type.
--- Category: Database Information ---
- `cust_td_serverInfo` (tool): Get the Teradata software information: demonstrates how to use parameters for prepared statements.
  - Arguments:
    - `infokey` (string, optional): No description.
- `dba_databaseVersion` (tool):  Get Teradata database version information.
- `base_databaseList` (tool): Lists all databases in the Teradata System.
--- Category: Database Space ---
- `dba_databaseSpace` (tool): 
Get database space if database name is provided, otherwise get all databases space allocations.

Arguments:
  database_name - database name

Returns:
  ResponseType: formatted response with query results + metadata

- `get_cube_cust_cube_db_space_metrics` (tool): 
    Tool to query the cube 'table_skew_pct'.
    Get the Teradata database space metrics for tables and databases

    Expected inputs:
        dimensions (str): Comma-separated dimension names to group by. Allowed values:
    - DatabaseName: Name of the database
    - TableName: Name of the table

        measures (str): Comma-separated measure names to aggregate. Allowed values:
    - current_perm: Object perm space in bytes
    - peak_perm: Object peak perm space in bytes
    - table_skew_pct: Object skew percentage

        filters (str): Comma-separated filter expressions to apply to either dimensions or measures selected. The dimension or measure used must be in the dimension list to group by or measure list, use valid SQL expressions, for example:
DatabaseName = 'value'
TableName = 'value'
current_perm > 1000
peak_perm > 1000
table_skew_pct > 1000

    Returns:
        Query result as a formatted response.
    
  - Arguments:
    - `dimensions` (string, optional): No description.
    - `measures` (string, optional): No description.
    - `filters` (string, optional): No description.
- `dba_systemSpace` (tool): Get the Teradata total system database space usage.
--- Category: Performance ---
- `dba_resusageSummary` (tool): 
Get the Teradata system usage summary metrics by weekday and hour for each workload type and query complexity bucket.

Arguments:
  dimensions - list of dimensions to aggregate the resource usage summary. All dimensions are: ["LogDate", "hourOfDay", "dayOfWeek", "workloadType", "workloadComplexity", "UserName", "AppId", "StatementType"]
  user_name - user name
  date - Date to analyze, formatted as `YYYY-MM-DD`
  dayOfWeek - day of the week to analyze
  hourOfDay - hour of day to analyze


- `dba_flowControl` (tool): Get the Teradata flow control metrics for a specified date range.
  - Arguments:
    - `start_date` (string, optional): No description.
    - `end_date` (string, optional): No description.
- `dba_userDelay` (tool): Get the Teradata user delay metrics for a specified date range.
  - Arguments:
    - `start_date` (string, optional): No description.
    - `end_date` (string, optional): No description.
--- Category: Query Execution ---
- `base_readQuery` (tool): 
Execute a SQL query via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  sql    - SQL text, with optional bind-parameter placeholders

Returns:
  ResponseType: formatted response with query results + metadata

--- Category: Sales Analytics ---
- `sales_top_customers` (tool): Get the top 20 customers by lifetime value.
- `sales_customer_profile` (tool): Get customer profile and metrics.
  - Arguments:
    - `customer_key` (string, optional): No description.
- `get_cube_sales_cube` (tool): 
    Tool to query the cube 'order_count'.
    Get the key sales metrics: USD amount and number of orders.

    Expected inputs:
        dimensions (str): Comma-separated dimension names to group by. Allowed values:
    - customer_key: Key for the customer
    - sales_year: Year of the sale
    - sales_month: Month of the sale

        measures (str): Comma-separated measure names to aggregate. Allowed values:
    - gift_amount_usd: Total gift card amount used for the order in USD
    - total_amount_usd: Total order amount in USD
    - order_count: Total number of orders

        filters (str): Comma-separated filter expressions to apply to either dimensions or measures selected. The dimension or measure used must be in the dimension list to group by or measure list, use valid SQL expressions, for example:
customer_key = 'value'
sales_year = 'value'
sales_month = 'value'
gift_amount_usd > 1000
total_amount_usd > 1000
order_count > 1000

    Returns:
        Query result as a formatted response.
    
  - Arguments:
    - `dimensions` (string, optional): No description.
    - `measures` (string, optional): No description.
    - `filters` (string, optional): No description.
--- Category: Security ---
- `sec_rolePermissions` (tool): 
Get permissions for a role.

Arguments:
  role_name - role name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `sec_userDbPermissions` (tool): 
Get permissions for a user.

Arguments:
  user_name - user name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `sec_userRoles` (tool): 
Get roles assigned to a user.

Arguments:
  user_name - user name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

--- Category: Session Management ---
- `dba_sessionInfo` (tool): Get the Teradata session information for user.
  - Arguments:
    - `user_name` (string, optional): No description.
--- Category: Table Management ---
- `dba_tableSpace` (tool): 
Get table space used for a table if table name is provided or get table space for all tables in a database if a database name is provided."

Arguments:
  database_name - database name
  table_name - table name

Returns:
  ResponseType: formatted response with query results + metadata

- `dba_tableSqlList` (tool): 
Get a list of SQL run against a table in the last number of days.

Arguments:
  table_name - table name
  no_days - number of days

Returns:
  ResponseType: formatted response with query results + metadata

- `dba_tableUsageImpact` (tool): 
Measure the usage of a table and views by users, this is helpful to understand what user and tables are driving most resource usage at any point in time.

Arguments:
  database_name - database name to analyze
  user_name - user name to analyze


- `base_columnDescription` (tool): 
Shows detailed column information about a database table via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name
  obj_name - table or view name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableAffinity` (tool): 
Get tables commonly used together by database users, this is helpful to infer relationships between tables via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name
  object_name - table or view name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableDDL` (tool): 
Displays the DDL definition of a table via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name
  table_name - table name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tablePreview` (tool): 
This function returns data sample and inferred structure from a database table or view via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  table_name - table or view name
  database_name - Database name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableUsage` (tool): 
Measure the usage of a table and views by users in a given schema, this is helpful to infer what database objects are most actively used or drive most value via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableList` (tool): Lists all tables in a database.
  - Arguments:
    - `database_name` (string, optional): No description.
--- Category: Usage Tracking ---
- `dba_featureUsage` (tool): Get the user feature usage metrics for a specified date range.
  - Arguments:
    - `start_date` (string, optional): No description.
    - `end_date` (string, optional): No description.
--- Category: User Management ---
- `dba_userSqlList` (tool): 
Get a list of SQL run by a user in the last number of days if a user name is provided, otherwise get list of all SQL in the last number of days.

Arguments:
  user_name - user name
  no_days - number of days

Returns:
  ResponseType: formatted response with query results + metadata

- `cust_activeUsers` (tool): Fetch currently active database users
--- Category: Utilities ---
- `tmpl_nameOfTool` (tool): 
<description of what the tool is for>

Arguments:
  arguments - arguments to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `evs_similarity_search` (tool): 
Enterprise Vector Store similarity search

Arguments:
  question - the query string to search for
  top_k - number of top results to return

Returns:
  ResponseType: formatted response with query results + metadata

- `rag_executeWorkflow` (tool): 
Execute complete RAG workflow to answer user questions based on document context.


This function handles the entire RAG pipeline:
1. Configuration setup (using configurable values from rag_config.yml)
2. Store user query (with /rag prefix stripping)
3. Generate query embeddings (tokenization + embedding)
4. Perform semantic search against chunk embeddings
5. Return retrieved context chunks for answer generation

The function uses configuration values from rag_config.yml with fallback defaults.

Arguments:
  question - user question to process
  k - number of top-k results to return (optional, uses config default if not provided)

Returns:
  Returns the top-k most relevant chunks with metadata for context-grounded answer generation.

- `rag_executeWorkflow_ivsm` (tool): 
Execute complete RAG workflow to answer user questions based on document context.

This function handles the entire RAG pipeline using IVSM functions:
1. Configuration setup (using configurable values from rag_config.yml)
2. Store user query (with /rag prefix stripping)
3. Tokenize query using ivsm.tokenizer_encode
4. Create embedding view using ivsm.IVSM_score
5. Convert embeddings to vector columns using ivsm.vector_to_columns
6. Perform semantic search against chunk embeddings

The function uses configuration values from rag_config.yml with fallback defaults.

Arguments:
  question - user question to process
  k - number of top-k results to return (optional, uses config default if not provided

Returns:
  Returns the top-k most relevant chunks with metadata for context-grounded answer generation.

- `util_getCurrentDate` (tool): Returns the current system date in YYYY-MM-DD format. Use this as the first step for any user query involving relative dates like 'today', 'yesterday', or 'this week'.
- `util_calculateDateRange` (tool): Calculates a list of dates based on a start date and a natural language phrase (e.g., 'past 3 days', 'last week'). This is a necessary second step for multi-day queries.
  - Arguments:
    - `start_date` (string, required): The anchor date for the calculation, usually today's date from `util_getCurrentDate`. Must be in YYYY-MM-DD format.
    - `date_phrase` (string, required): The natural language phrase describing the desired range (e.g., 'past 3 days', 'last 2 weeks').
- `CoreLLMTask` (tool): Performs internal, LLM-driven tasks that are not direct calls to the Teradata database. This tool is used for text synthesis, summarization, and formatting based on a specific 'task_description' provided by the LLM itself.
  - Arguments:
    - `task_description` (string, required): A natural language description of the internal task to be executed (e.g., 'describe the table in a business context', 'format final output'). The LLM infers this from the workflow plan.
    - `source_data` (list[string], required): A list of keys (e.g., 'result_of_phase_1') identifying which data from the workflow history is relevant for this task. This is critical for providing the correct context.
--- Available Prompts ---
--- Category: Prompts ---
- `base_query` (prompt): Help users interact with  Teradata databases effectively.
  - Arguments:
    - `query` (str, required): The problem or question that needs to be solved using Teradata database tools.
- `base_tableBusinessDesc` (prompt): You are a Teradata DBA who is an expert in describing the business use of tables in a database.
  - Arguments:
    - `database_name` (str, required): Database for the table to describe.
    - `table_name` (str, required): Table to describe.


USER PROMPT:

You are an expert strategic planning assistant. Your task is to analyze a user's request or a complex workflow goal and decompose it into a high-level, phased meta-plan. This plan will serve as a state machine executor.

--- GOAL ---
what is the system utilization of the past 3 days?

--- CONTEXT ---
- User's Original Question (for reference): what is the system utilization of the past 3 days?

--- INSTRUCTIONS ---
1.  **Analyze the Goal**: Carefully read the "GOAL" to understand the user's full intent.
2.  **Decompose into Phases**: Break down the overall goal into a sequence of logical phases. Each phase should represent a major step.
3.  **Define Each Phase**: For each phase, create a JSON object with the following keys:
    -   `"phase"`: An integer representing the step number (e.g., 1, 2, 3).
    -   `"goal"`: A clear, concise, and actionable description of what must be accomplished in this phase. This goal will guide a separate, tactical LLM.
    -   `"relevant_tools"`: A list of tool names that are permitted to be used during this phase. You MUST select the most appropriate and specific tools from the full "Capabilities" list provided in the main system prompt to achieve the phase's goal.
    -   (Optional) `"type": "loop"`: If a phase requires iterating over a list of items, you MUST include this key.
    -   (Optional) `"loop_over"`: If `"type"` is `"loop"`, specify the data source for the iteration (e.g., `"result_of_phase_1"`).
4.  **Embed Parameters**: When defining the `"goal"` for a phase, you MUST scan the main "GOAL" for any hardcoded arguments or parameters (e.g., table names, database names) relevant to that phase's task. You MUST embed these found parameters directly into the `"goal"` string to make it self-contained and explicit.
5.  **Final Synthesis and Formatting Phase**: If the main "GOAL" describes a multi-step process with a final reporting requirement, your plan **MUST** conclude with a single, final phase that handles both the synthesis of the final report AND its formatting. The `relevant_tools` for this final phase **MUST** be `["CoreLLMTask"]`.
6.  **CRITICAL RULE (Simplicity)**: If the "GOAL" is a simple, direct request that can be answered with a single tool call (e.g., "list all databases", "what is the system utilization?"), your plan **MUST** consist of only a single phase that calls the one most appropriate tool. Do not add unnecessary synthesis phases for simple data retrieval.
7.  **CRITICAL RULE (Execution Focus)**: Every phase you define **MUST** correspond to a concrete, tool-based action. You **MUST NOT** create phases for simple verification, confirmation, or acknowledgement of known information. Your plan must focus only on the execution steps required to gather new information or process existing data.
8.  **CRITICAL RULE (Capability Types)**: You are generating a plan of executable **tools**. The `relevant_tools` list **MUST ONLY** contain names of capabilities that are explicitly marked as `(tool)` in the system's "Capabilities" list. You **MUST NOT** include the name of any capability marked as `(prompt)`.
9.  **CRITICAL RULE (Efficiency)**: If a phase's `"goal"` already contains all the instructions for the final synthesis and formatting of the report (as specified in the main "GOAL"), you **MUST** make this the last phase of the plan. Do not add a separate, redundant formatting-only phase after it.

--- EXAMPLE (Complex Goal) ---
If the main goal requires getting DDL and then describing/formatting, your output should be a two-phase plan like this:
```json
[
  {
    "phase": 1,
    "goal": "Get the DDL for the table 'customers' in database 'sales' using the `base_tableDDL` tool.",
    "relevant_tools": ["base_tableDDL"]
  },
  {
    "phase": 2,
    "goal": "Synthesize a final report by describing the 'customers' table in a business context and format the output as markdown according to the Final output guidelines, using `***` for keys.",
    "relevant_tools": ["CoreLLMTask"]
  }
]
```

--- EXAMPLE (Simple Goal) ---
If the main goal is "what is the system utilization?", your output should be a single-phase plan like this:
```json
[
  {
    "phase": 1,
    "goal": "Get the system utilization using the `dba_resusageSummary` tool.",
    "relevant_tools": ["dba_resusageSummary"]
  }
]
```

--- EXAMPLE (Date Range Goal) ---
If the main goal is "what is the system utilization for the past 3 days?", your output must be a three-phase plan like this:
```json
[
  {
    "phase": 1,
    "goal": "Get the current date using the `util_getCurrentDate` tool to establish a reference point.",
    "relevant_tools": ["util_getCurrentDate"]
  },
  {
    "phase": 2,
    "goal": "Calculate the list of dates for 'the past 3 days' using the `util_calculateDateRange` tool.",
    "relevant_tools": ["util_calculateDateRange"]
  },
  {
    "phase": 3,
    "goal": "For each date calculated in the previous step, get the system utilization using the `dba_resusageSummary` tool.",
    "relevant_tools": ["dba_resusageSummary"],
    "type": "loop",
    "loop_over": "result_of_phase_2"
  }
]
```

Your response MUST be a single, valid JSON list of phase objects. Do NOT add any extra text, conversation, or markdown.

[model]: ```json
[
  {
    "phase": 1,
    "goal": "Get the current date using the `util_getCurrentDate` tool to establish a reference point.",
    "relevant_tools": ["util_getCurrentDate"]
  },
  {
    "phase": 2,
    "goal": "Calculate the list of dates for 'past 3 days' using the `util_calculateDateRange` tool.",
    "relevant_tools": ["util_calculateDateRange"]
  },
  {
    "phase": 3,
    "goal": "For each date calculated in the previous step, get the system utilization using the `dba_resusageSummary` tool.",
    "relevant_tools": ["dba_resusageSummary"],
    "type": "loop",
    "loop_over": "result_of_phase_2"
  }
]
```
[user]: SYSTEM PROMPT:

You are a tactical assistant executing a single phase of a larger plan. Your task is to decide the single best next action to take to achieve the current phase's goal, strictly adhering to the provided tool constraints.

--- OVERALL WORKFLOW GOAL ---
what is the system utilization of the past 3 days?

--- CURRENT PHASE GOAL ---
Get the current date using the `util_getCurrentDate` tool to establish a reference point.

--- CONSTRAINTS ---
- Permitted Tools for this Phase (You MUST use the exact argument names provided):

- Tool: `util_getCurrentDate`
  - Description: Returns the current system date in YYYY-MM-DD format. Use this as the first step for any user query involving relative dates like 'today', 'yesterday', or 'this week'.

- Previous Attempt (if any): None

--- WORKFLOW STATE & HISTORY ---
- Actions Taken So Far: []
- Data Collected So Far: {}

--- INSTRUCTIONS ---
1.  **Analyze the State**: Review the "CURRENT PHASE GOAL" and the "WORKFLOW STATE & HISTORY" to understand what has been done and what is needed next.
2.  **CRITICAL RULE (Tool Selection & Arguments)**: You **MUST** select your next action from the list of "Permitted Tools for this Phase". You are not allowed to use any other tool. Furthermore, you **MUST** use the exact argument names as they are defined in the tool details above. You **MUST NOT** invent, hallucinate, or use any arguments that are not explicitly listed in the definitions.
3.  **Self-Correction**: If a "Previous Attempt" is noted in the "CONSTRAINTS" section, it means your last choice was invalid. You **MUST** analyze the error and choose a different, valid tool from the permitted list. Do not repeat the invalid choice.
4.  **CoreLLMTask Usage**:
    -   For any task that involves synthesis, analysis, description, or summarization, you **MUST** use the `CoreLLMTask` tool, but only if it is in the permitted tools list.
    -   When calling `CoreLLMTask`, you **MUST** provide the `task_description` argument.
    -   Crucially, you **MUST** also determine which previous phase results are necessary for the task. You **MUST** provide these as a list of strings in the `source_data` argument.
    -   **CONTEXT PRESERVATION RULE**: If the current phase involves creating a final summary or report for the user, you **MUST** ensure you have all the necessary context. Your `source_data` list **MUST** include the results from **ALL** previous data-gathering phases (e.g., `["result_of_phase_1", "result_of_phase_2"]`) to prevent information loss.
5.  **Handle Loops**: If you are in a looping phase (indicated by the presence of a "LOOP CONTEXT" section), you **MUST** focus your action on the single item provided in `current_loop_item`. You **MUST** use the information within that item to formulate the arguments for your tool call.
6.  **Format Response**: Your response MUST be a single JSON object for a tool call.

Your response MUST be a single, valid JSON object for a tool call. Do NOT add any extra text or conversation.


USER PROMPT:
Determine the next action based on the instructions and state provided in the system prompt.
[model]: ```json
{"tool_name": "util_getCurrentDate", "arguments": {}}
```
[user]: SYSTEM PROMPT:

You are a tactical assistant executing a single phase of a larger plan. Your task is to decide the single best next action to take to achieve the current phase's goal, strictly adhering to the provided tool constraints.

--- OVERALL WORKFLOW GOAL ---
what is the system utilization of the past 3 days?

--- CURRENT PHASE GOAL ---
Calculate the list of dates for 'past 3 days' using the `util_calculateDateRange` tool.

--- CONSTRAINTS ---
- Permitted Tools for this Phase (You MUST use the exact argument names provided):

- Tool: `util_calculateDateRange`
  - Description: Calculates a list of dates based on a start date and a natural language phrase (e.g., 'past 3 days', 'last week'). This is a necessary second step for multi-day queries.
  - Arguments:
    - `start_date` (string, required): The anchor date for the calculation, usually today's date from `util_getCurrentDate`. Must be in YYYY-MM-DD format.
    - `date_phrase` (string, required): The natural language phrase describing the desired range (e.g., 'past 3 days', 'last 2 weeks').

- Previous Attempt (if any): None

--- WORKFLOW STATE & HISTORY ---
- Actions Taken So Far: [
  {
    "action": {
      "tool_name": "util_getCurrentDate",
      "arguments": {}
    },
    "result": {
      "status": "success",
      "metadata": {
        "tool_name": "util_getCurrentDate"
      },
      "results": [
        {
          "current_date": "2025-08-21"
        }
      ]
    }
  }
]
- Data Collected So Far: {
  "result_of_phase_1": [
    {
      "status": "success",
      "metadata": {
        "tool_name": "util_getCurrentDate"
      },
      "results": [
        {
          "current_date": "2025-08-21"
        }
      ]
    }
  ]
}

--- INSTRUCTIONS ---
1.  **Analyze the State**: Review the "CURRENT PHASE GOAL" and the "WORKFLOW STATE & HISTORY" to understand what has been done and what is needed next.
2.  **CRITICAL RULE (Tool Selection & Arguments)**: You **MUST** select your next action from the list of "Permitted Tools for this Phase". You are not allowed to use any other tool. Furthermore, you **MUST** use the exact argument names as they are defined in the tool details above. You **MUST NOT** invent, hallucinate, or use any arguments that are not explicitly listed in the definitions.
3.  **Self-Correction**: If a "Previous Attempt" is noted in the "CONSTRAINTS" section, it means your last choice was invalid. You **MUST** analyze the error and choose a different, valid tool from the permitted list. Do not repeat the invalid choice.
4.  **CoreLLMTask Usage**:
    -   For any task that involves synthesis, analysis, description, or summarization, you **MUST** use the `CoreLLMTask` tool, but only if it is in the permitted tools list.
    -   When calling `CoreLLMTask`, you **MUST** provide the `task_description` argument.
    -   Crucially, you **MUST** also determine which previous phase results are necessary for the task. You **MUST** provide these as a list of strings in the `source_data` argument.
    -   **CONTEXT PRESERVATION RULE**: If the current phase involves creating a final summary or report for the user, you **MUST** ensure you have all the necessary context. Your `source_data` list **MUST** include the results from **ALL** previous data-gathering phases (e.g., `["result_of_phase_1", "result_of_phase_2"]`) to prevent information loss.
5.  **Handle Loops**: If you are in a looping phase (indicated by the presence of a "LOOP CONTEXT" section), you **MUST** focus your action on the single item provided in `current_loop_item`. You **MUST** use the information within that item to formulate the arguments for your tool call.
6.  **Format Response**: Your response MUST be a single JSON object for a tool call.

Your response MUST be a single, valid JSON object for a tool call. Do NOT add any extra text or conversation.


USER PROMPT:
Determine the next action based on the instructions and state provided in the system prompt.
[model]: ```json
{"tool_name": "util_calculateDateRange", "arguments": {"start_date": "2025-08-21", "date_phrase": "past 3 days"}}
```
[user]: SYSTEM PROMPT:

# Core Directives
You are a specialized assistant for a Teradata database system. Your primary goal is to fulfill user requests by selecting the best capability (a tool or a prompt) from the categorized lists provided and supplying all necessary arguments.

# Response Format
Your response MUST be a single JSON object for a tool/prompt call OR a single plain text string for a final answer.

1.  **Tool/Prompt Calls (JSON format):**
    -   If the capability is a prompt, you MUST use the key `"prompt_name"`.
    -   If the capability is a tool, you MUST use the key `"tool_name"`.
    -   Provide all required arguments. Infer values from the conversation history if necessary.
    -   Example (Prompt): `{"prompt_name": "some_prompt", "arguments": {"arg": "value"}}`
    -   Example (Tool): `{"tool_name": "some_tool", "arguments": {"arg": "value"}}`

2.  **Final Answer (Plain Text format):**
    -   When you have sufficient information to fully answer the user's request, you MUST stop using tools.
    -   Your response MUST begin with the exact prefix `FINAL_ANSWER:`, followed by a natural language summary.
    -   Example: `FINAL_ANSWER: I found 48 databases on the system. The details are displayed below.`

# Decision Process
To select the correct capability, you MUST follow this two-step process, governed by one critical rule:

**CRITICAL RULE: Prioritize Specificity and Arguments.** Your primary filter for selecting a capability is its specificity. You MUST select the most granular capability that uses the most entities from the user's request (e.g., prefer a tool that uses a `table_name` over one that only uses a `database_name` if a table is mentioned). For direct actions and single analyses, you MUST select a `tool_name`; only select a `prompt_name` for broad, multi-step tasks explicitly described by the prompt.

1.  **Identify the Category:** First, analyze the user's request to determine which Tool or Prompt Category is the most relevant to their intent. The available categories are listed in the "Capabilities" section below.
2.  **Select the Capability:** Second, from within that single most relevant category, select the best tool or prompt to fulfill the request, adhering to the Critical Rule above.

# Few-Shot Examples
Here are examples of the correct thinking process:

**Example 1:**
- **User Query:** "what is the quality of table 'online' in database 'DEMO_Customer360_db'?"
- **Thought Process:**
    1.  The user's query is about a **table**.
    2.  My critical rule is to prioritize specificity. I must choose a table-level tool.
    3.  The `qlty_databaseQuality` prompt is for databases, not specific tables, so it's incorrect.
    4.  The `qlty_columnSummary` tool takes a `table_name` and is the most specific, correct choice.
- **Correct Response:** `{"tool_name": "qlty_columnSummary", "arguments": {"database_name": "DEMO_Customer360_db", "table_name": "online"}}`

**Example 2:**
- **User Query:** "describe the business purpose of the 'DEMO_Customer360_db' database"
- **Thought Process:**
    1.  The user's query is about a **database**. It's a broad request ("describe").
    2.  A prompt is better for broad tasks.
    3.  The `base_databaseBusinessDesc` prompt takes a `database_name` and is the correct choice.
- **Correct Response:** `{"prompt_name": "base_databaseBusinessDesc", "arguments": {"database_name": "DEMO_Customer360_db"}}`

**Example 3:**
- **User Query:** "what is the system utilization?"
- **Thought Process:**
    1.  The user is asking for a specific metric: "system utilization". This is a direct request for data.
    2.  My critical rule states I must prioritize a `tool_name` for direct actions.
    3.  The `dba_systemVoice` prompt is for adopting a persona, not for fetching specific metrics. It is the incorrect choice.
    4.  The `dba_resusageSummary` tool in the `Performance` category is designed to get system usage summary metrics. This is the correct choice.
- **Correct Response:** `{"tool_name": "dba_resusageSummary", "arguments": {}}`

# Best Practices
- **Context is Key:** Always use information from previous turns to fill in arguments like `db_name` or `table_name`.
- **Error Recovery:** If a tool fails, analyze the error message and attempt to call the tool again with corrected parameters. Only ask the user for clarification if you cannot recover.
- **SQL Generation:** When using the `base_readQuery` tool, you MUST use fully qualified table names in your SQL (e.g., `SELECT ... FROM my_database.my_table`).
- **Time-Sensitive Queries:** For queries involving relative dates (e.g., 'today', 'this week'), you MUST use the `util_getCurrentDate` tool first to determine the current date before proceeding.
- **Out of Scope:** If the user's request is unrelated to the available capabilities, respond with a `FINAL_ANSWER:` that politely explains you cannot fulfill the request and restates your purpose.
- **CRITICAL: Avoid Repetitive Behavior.** You are a highly intelligent agent. Do not get stuck in a loop by repeating the same tool calls or by cycling through the same set of tools. Once a tool has returned a successful result with data that is relevant to the user's request, do not call that same tool again unless there is a new and compelling reason to do so. If you have called a series of tools and believe you have enough information, you must call a FINAL_ANSWER. Do not repeat tool calls just to be "through".


# Capabilities
--- Available Tools ---
--- Category: Data Quality ---
- `qlty_columnSummary` (tool): 
Get the column summary statistics for a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_distinctCategories` (tool): 
Get the destinct categories from column in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_missingValues` (tool): 
Get the column names that having missing values in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_negativeValues` (tool): 
Get the column names that having negative values in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_rowsWithMissingValues` (tool): 
Get the rows with missing values in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_standardDeviation` (tool): 
Get the standard deviation from column in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_univariateStatistics` (tool): 
Get the univariate statistics for a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

--- Category: Data Visualization ---
- `viz_createChart` (tool): Generates a data visualization based on provided data. You must specify the chart type and map the data fields to the appropriate visual roles.
  - Arguments:
    - `chart_type` (string, required): The type of chart to generate (e.g., 'bar', 'pie', 'line', 'scatter'). This MUST be one of the types listed in the 'Charting Guidelines'.
    - `data` (list[dict], required): The data to be visualized, passed directly from the output of another tool.
    - `title` (string, required): A descriptive title for the chart.
    - `mapping` (dict, required): A dictionary that maps data keys to chart axes or roles (e.g., {'x_axis': 'product_name', 'y_axis': 'sales_total'}). The required keys for this mapping depend on the selected chart_type.
--- Category: Database Information ---
- `cust_td_serverInfo` (tool): Get the Teradata software information: demonstrates how to use parameters for prepared statements.
  - Arguments:
    - `infokey` (string, optional): No description.
- `dba_databaseVersion` (tool):  Get Teradata database version information.
- `base_databaseList` (tool): Lists all databases in the Teradata System.
--- Category: Database Space ---
- `dba_databaseSpace` (tool): 
Get database space if database name is provided, otherwise get all databases space allocations.

Arguments:
  database_name - database name

Returns:
  ResponseType: formatted response with query results + metadata

- `get_cube_cust_cube_db_space_metrics` (tool): 
    Tool to query the cube 'table_skew_pct'.
    Get the Teradata database space metrics for tables and databases

    Expected inputs:
        dimensions (str): Comma-separated dimension names to group by. Allowed values:
    - DatabaseName: Name of the database
    - TableName: Name of the table

        measures (str): Comma-separated measure names to aggregate. Allowed values:
    - current_perm: Object perm space in bytes
    - peak_perm: Object peak perm space in bytes
    - table_skew_pct: Object skew percentage

        filters (str): Comma-separated filter expressions to apply to either dimensions or measures selected. The dimension or measure used must be in the dimension list to group by or measure list, use valid SQL expressions, for example:
DatabaseName = 'value'
TableName = 'value'
current_perm > 1000
peak_perm > 1000
table_skew_pct > 1000

    Returns:
        Query result as a formatted response.
    
  - Arguments:
    - `dimensions` (string, optional): No description.
    - `measures` (string, optional): No description.
    - `filters` (string, optional): No description.
- `dba_systemSpace` (tool): Get the Teradata total system database space usage.
--- Category: Performance ---
- `dba_resusageSummary` (tool): 
Get the Teradata system usage summary metrics by weekday and hour for each workload type and query complexity bucket.

Arguments:
  dimensions - list of dimensions to aggregate the resource usage summary. All dimensions are: ["LogDate", "hourOfDay", "dayOfWeek", "workloadType", "workloadComplexity", "UserName", "AppId", "StatementType"]
  user_name - user name
  date - Date to analyze, formatted as `YYYY-MM-DD`
  dayOfWeek - day of the week to analyze
  hourOfDay - hour of day to analyze


- `dba_flowControl` (tool): Get the Teradata flow control metrics for a specified date range.
  - Arguments:
    - `start_date` (string, optional): No description.
    - `end_date` (string, optional): No description.
- `dba_userDelay` (tool): Get the Teradata user delay metrics for a specified date range.
  - Arguments:
    - `start_date` (string, optional): No description.
    - `end_date` (string, optional): No description.
--- Category: Query Execution ---
- `base_readQuery` (tool): 
Execute a SQL query via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  sql    - SQL text, with optional bind-parameter placeholders

Returns:
  ResponseType: formatted response with query results + metadata

--- Category: Sales Analytics ---
- `sales_top_customers` (tool): Get the top 20 customers by lifetime value.
- `sales_customer_profile` (tool): Get customer profile and metrics.
  - Arguments:
    - `customer_key` (string, optional): No description.
- `get_cube_sales_cube` (tool): 
    Tool to query the cube 'order_count'.
    Get the key sales metrics: USD amount and number of orders.

    Expected inputs:
        dimensions (str): Comma-separated dimension names to group by. Allowed values:
    - customer_key: Key for the customer
    - sales_year: Year of the sale
    - sales_month: Month of the sale

        measures (str): Comma-separated measure names to aggregate. Allowed values:
    - gift_amount_usd: Total gift card amount used for the order in USD
    - total_amount_usd: Total order amount in USD
    - order_count: Total number of orders

        filters (str): Comma-separated filter expressions to apply to either dimensions or measures selected. The dimension or measure used must be in the dimension list to group by or measure list, use valid SQL expressions, for example:
customer_key = 'value'
sales_year = 'value'
sales_month = 'value'
gift_amount_usd > 1000
total_amount_usd > 1000
order_count > 1000

    Returns:
        Query result as a formatted response.
    
  - Arguments:
    - `dimensions` (string, optional): No description.
    - `measures` (string, optional): No description.
    - `filters` (string, optional): No description.
--- Category: Security ---
- `sec_rolePermissions` (tool): 
Get permissions for a role.

Arguments:
  role_name - role name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `sec_userDbPermissions` (tool): 
Get permissions for a user.

Arguments:
  user_name - user name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `sec_userRoles` (tool): 
Get roles assigned to a user.

Arguments:
  user_name - user name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

--- Category: Session Management ---
- `dba_sessionInfo` (tool): Get the Teradata session information for user.
  - Arguments:
    - `user_name` (string, optional): No description.
--- Category: Table Management ---
- `dba_tableSpace` (tool): 
Get table space used for a table if table name is provided or get table space for all tables in a database if a database name is provided."

Arguments:
  database_name - database name
  table_name - table name

Returns:
  ResponseType: formatted response with query results + metadata

- `dba_tableSqlList` (tool): 
Get a list of SQL run against a table in the last number of days.

Arguments:
  table_name - table name
  no_days - number of days

Returns:
  ResponseType: formatted response with query results + metadata

- `dba_tableUsageImpact` (tool): 
Measure the usage of a table and views by users, this is helpful to understand what user and tables are driving most resource usage at any point in time.

Arguments:
  database_name - database name to analyze
  user_name - user name to analyze


- `base_columnDescription` (tool): 
Shows detailed column information about a database table via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name
  obj_name - table or view name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableAffinity` (tool): 
Get tables commonly used together by database users, this is helpful to infer relationships between tables via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name
  object_name - table or view name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableDDL` (tool): 
Displays the DDL definition of a table via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name
  table_name - table name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tablePreview` (tool): 
This function returns data sample and inferred structure from a database table or view via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  table_name - table or view name
  database_name - Database name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableUsage` (tool): 
Measure the usage of a table and views by users in a given schema, this is helpful to infer what database objects are most actively used or drive most value via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableList` (tool): Lists all tables in a database.
  - Arguments:
    - `database_name` (string, optional): No description.
--- Category: Usage Tracking ---
- `dba_featureUsage` (tool): Get the user feature usage metrics for a specified date range.
  - Arguments:
    - `start_date` (string, optional): No description.
    - `end_date` (string, optional): No description.
--- Category: User Management ---
- `dba_userSqlList` (tool): 
Get a list of SQL run by a user in the last number of days if a user name is provided, otherwise get list of all SQL in the last number of days.

Arguments:
  user_name - user name
  no_days - number of days

Returns:
  ResponseType: formatted response with query results + metadata

- `cust_activeUsers` (tool): Fetch currently active database users
--- Category: Utilities ---
- `tmpl_nameOfTool` (tool): 
<description of what the tool is for>

Arguments:
  arguments - arguments to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `evs_similarity_search` (tool): 
Enterprise Vector Store similarity search

Arguments:
  question - the query string to search for
  top_k - number of top results to return

Returns:
  ResponseType: formatted response with query results + metadata

- `rag_executeWorkflow` (tool): 
Execute complete RAG workflow to answer user questions based on document context.


This function handles the entire RAG pipeline:
1. Configuration setup (using configurable values from rag_config.yml)
2. Store user query (with /rag prefix stripping)
3. Generate query embeddings (tokenization + embedding)
4. Perform semantic search against chunk embeddings
5. Return retrieved context chunks for answer generation

The function uses configuration values from rag_config.yml with fallback defaults.

Arguments:
  question - user question to process
  k - number of top-k results to return (optional, uses config default if not provided)

Returns:
  Returns the top-k most relevant chunks with metadata for context-grounded answer generation.

- `rag_executeWorkflow_ivsm` (tool): 
Execute complete RAG workflow to answer user questions based on document context.

This function handles the entire RAG pipeline using IVSM functions:
1. Configuration setup (using configurable values from rag_config.yml)
2. Store user query (with /rag prefix stripping)
3. Tokenize query using ivsm.tokenizer_encode
4. Create embedding view using ivsm.IVSM_score
5. Convert embeddings to vector columns using ivsm.vector_to_columns
6. Perform semantic search against chunk embeddings

The function uses configuration values from rag_config.yml with fallback defaults.

Arguments:
  question - user question to process
  k - number of top-k results to return (optional, uses config default if not provided

Returns:
  Returns the top-k most relevant chunks with metadata for context-grounded answer generation.

- `util_getCurrentDate` (tool): Returns the current system date in YYYY-MM-DD format. Use this as the first step for any user query involving relative dates like 'today', 'yesterday', or 'this week'.
- `util_calculateDateRange` (tool): Calculates a list of dates based on a start date and a natural language phrase (e.g., 'past 3 days', 'last week'). This is a necessary second step for multi-day queries.
  - Arguments:
    - `start_date` (string, required): The anchor date for the calculation, usually today's date from `util_getCurrentDate`. Must be in YYYY-MM-DD format.
    - `date_phrase` (string, required): The natural language phrase describing the desired range (e.g., 'past 3 days', 'last 2 weeks').
- `CoreLLMTask` (tool): Performs internal, LLM-driven tasks that are not direct calls to the Teradata database. This tool is used for text synthesis, summarization, and formatting based on a specific 'task_description' provided by the LLM itself.
  - Arguments:
    - `task_description` (string, required): A natural language description of the internal task to be executed (e.g., 'describe the table in a business context', 'format final output'). The LLM infers this from the workflow plan.
    - `source_data` (list[string], required): A list of keys (e.g., 'result_of_phase_1') identifying which data from the workflow history is relevant for this task. This is critical for providing the correct context.
--- Available Prompts ---
--- Category: Prompts ---
- `base_query` (prompt): Help users interact with  Teradata databases effectively.
  - Arguments:
    - `query` (str, required): The problem or question that needs to be solved using Teradata database tools.
- `base_tableBusinessDesc` (prompt): You are a Teradata DBA who is an expert in describing the business use of tables in a database.
  - Arguments:
    - `database_name` (str, required): Database for the table to describe.
    - `table_name` (str, required): Table to describe.


USER PROMPT:
You are an expert data analyst. Synthesize all collected data into a clear, concise, and insightful final answer.

--- USER'S QUESTION ---
'what is the system utilization of the past 3 days?'

--- DATA COLLECTED ---
```json
[
  {
    "status": "success",
    "metadata": {
      "tool_name": "util_getCurrentDate"
    },
    "results": [
      {
        "current_date": "2025-08-21"
      }
    ]
  },
  {
    "status": "success",
    "metadata": {
      "tool_name": "util_calculateDateRange"
    },
    "results": [
      {
        "date": "2025-08-18"
      },
      {
        "date": "2025-08-19"
      },
      {
        "date": "2025-08-20"
      }
    ]
  },
  {
    "status": "success",
    "metadata": {
      "tool_name": "dba_resusageSummary",
      "total_rows": 1,
      "comment": "Total system resource usage summary."
    },
    "results": [
      {
        "Request Count": "0",
        "Total AMPCPUTime": "None",
        "Total IOCount": "None",
        "Total ReqIOKB": "None",
        "Total ReqPhysIO": "None",
        "Total ReqPhysIOKB": "None",
        "Total ReqIO GB": "None",
        "Total ReqPhysIOGB": "None",
        "Total Server Byte Count": "None"
      }
    ]
  },
  {
    "status": "success",
    "metadata": {
      "tool_name": "dba_resusageSummary",
      "total_rows": 1,
      "comment": "Total system resource usage summary."
    },
    "results": [
      {
        "Request Count": "283",
        "Total AMPCPUTime": "1.1800000000000002",
        "Total IOCount": "15931.0",
        "Total ReqIOKB": "741228.0",
        "Total ReqPhysIO": "44.0",
        "Total ReqPhysIOKB": "904.0",
        "Total ReqIO GB": "0.7068901062011719",
        "Total ReqPhysIOGB": "0.00086212158203125",
        "Total Server Byte Count": "0"
      }
    ]
  },
  {
    "status": "success",
    "metadata": {
      "tool_name": "dba_resusageSummary",
      "total_rows": 1,
      "comment": "Total system resource usage summary."
    },
    "results": [
      {
        "Request Count": "121",
        "Total AMPCPUTime": "0.316",
        "Total IOCount": "3929.0",
        "Total ReqIOKB": "163096.0",
        "Total ReqPhysIO": "8.0",
        "Total ReqPhysIOKB": "184.0",
        "Total ReqIO GB": "0.15554046630859375",
        "Total ReqPhysIOGB": "0.00017547607421875",
        "Total Server Byte Count": "0"
      }
    ]
  }
]
```

--- INSTRUCTIONS ---
1.  Provide a holistic analysis and actionable insights.
2.  Begin with a high-level summary, then use bullet points for key observations.
3.  Your entire response **MUST** begin with `FINAL_ANSWER:`.

[model]: FINAL_ANSWER: The system utilization for the past 3 days (2025-08-18 to 2025-08-20) shows varying levels of activity.

*   **2025-08-18:** No resource usage data was found for this date.
*   **2025-08-19:** The system processed 283 requests, consuming 1.18 AMP CPU seconds and performing 15931 I/O operations, with a total of 741228 KB of I/O.
*   **2025-08-20:** The system processed 121 requests, consuming 0.316 AMP CPU seconds and performing 3929 I/O operations, with a total of 163096 KB of I/O.


--- Current User Prompt (with System Prompt) ---
SYSTEM PROMPT:

# Core Directives
You are a specialized assistant for a Teradata database system. Your primary goal is to fulfill user requests by selecting the best capability (a tool or a prompt) from the categorized lists provided and supplying all necessary arguments.

# Response Format
Your response MUST be a single JSON object for a tool/prompt call OR a single plain text string for a final answer.

1.  **Tool/Prompt Calls (JSON format):**
    -   If the capability is a prompt, you MUST use the key `"prompt_name"`.
    -   If the capability is a tool, you MUST use the key `"tool_name"`.
    -   Provide all required arguments. Infer values from the conversation history if necessary.
    -   Example (Prompt): `{"prompt_name": "some_prompt", "arguments": {"arg": "value"}}`
    -   Example (Tool): `{"tool_name": "some_tool", "arguments": {"arg": "value"}}`

2.  **Final Answer (Plain Text format):**
    -   When you have sufficient information to fully answer the user's request, you MUST stop using tools.
    -   Your response MUST begin with the exact prefix `FINAL_ANSWER:`, followed by a natural language summary.
    -   Example: `FINAL_ANSWER: I found 48 databases on the system. The details are displayed below.`

# Decision Process
To select the correct capability, you MUST follow this two-step process, governed by one critical rule:

**CRITICAL RULE: Prioritize Specificity and Arguments.** Your primary filter for selecting a capability is its specificity. You MUST select the most granular capability that uses the most entities from the user's request (e.g., prefer a tool that uses a `table_name` over one that only uses a `database_name` if a table is mentioned). For direct actions and single analyses, you MUST select a `tool_name`; only select a `prompt_name` for broad, multi-step tasks explicitly described by the prompt.

1.  **Identify the Category:** First, analyze the user's request to determine which Tool or Prompt Category is the most relevant to their intent. The available categories are listed in the "Capabilities" section below.
2.  **Select the Capability:** Second, from within that single most relevant category, select the best tool or prompt to fulfill the request, adhering to the Critical Rule above.

# Few-Shot Examples
Here are examples of the correct thinking process:

**Example 1:**
- **User Query:** "what is the quality of table 'online' in database 'DEMO_Customer360_db'?"
- **Thought Process:**
    1.  The user's query is about a **table**.
    2.  My critical rule is to prioritize specificity. I must choose a table-level tool.
    3.  The `qlty_databaseQuality` prompt is for databases, not specific tables, so it's incorrect.
    4.  The `qlty_columnSummary` tool takes a `table_name` and is the most specific, correct choice.
- **Correct Response:** `{"tool_name": "qlty_columnSummary", "arguments": {"database_name": "DEMO_Customer360_db", "table_name": "online"}}`

**Example 2:**
- **User Query:** "describe the business purpose of the 'DEMO_Customer360_db' database"
- **Thought Process:**
    1.  The user's query is about a **database**. It's a broad request ("describe").
    2.  A prompt is better for broad tasks.
    3.  The `base_databaseBusinessDesc` prompt takes a `database_name` and is the correct choice.
- **Correct Response:** `{"prompt_name": "base_databaseBusinessDesc", "arguments": {"database_name": "DEMO_Customer360_db"}}`

**Example 3:**
- **User Query:** "what is the system utilization?"
- **Thought Process:**
    1.  The user is asking for a specific metric: "system utilization". This is a direct request for data.
    2.  My critical rule states I must prioritize a `tool_name` for direct actions.
    3.  The `dba_systemVoice` prompt is for adopting a persona, not for fetching specific metrics. It is the incorrect choice.
    4.  The `dba_resusageSummary` tool in the `Performance` category is designed to get system usage summary metrics. This is the correct choice.
- **Correct Response:** `{"tool_name": "dba_resusageSummary", "arguments": {}}`

# Best Practices
- **Context is Key:** Always use information from previous turns to fill in arguments like `db_name` or `table_name`.
- **Error Recovery:** If a tool fails, analyze the error message and attempt to call the tool again with corrected parameters. Only ask the user for clarification if you cannot recover.
- **SQL Generation:** When using the `base_readQuery` tool, you MUST use fully qualified table names in your SQL (e.g., `SELECT ... FROM my_database.my_table`).
- **Time-Sensitive Queries:** For queries involving relative dates (e.g., 'today', 'this week'), you MUST use the `util_getCurrentDate` tool first to determine the current date before proceeding.
- **Out of Scope:** If the user's request is unrelated to the available capabilities, respond with a `FINAL_ANSWER:` that politely explains you cannot fulfill the request and restates your purpose.
- **CRITICAL: Avoid Repetitive Behavior.** You are a highly intelligent agent. Do not get stuck in a loop by repeating the same tool calls or by cycling through the same set of tools. Once a tool has returned a successful result with data that is relevant to the user's request, do not call that same tool again unless there is a new and compelling reason to do so. If you have called a series of tools and believe you have enough information, you must call a FINAL_ANSWER. Do not repeat tool calls just to be "through".


# Capabilities
--- Available Tools ---
--- Category: Data Quality ---
- `qlty_columnSummary` (tool): 
Get the column summary statistics for a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_distinctCategories` (tool): 
Get the destinct categories from column in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_missingValues` (tool): 
Get the column names that having missing values in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_negativeValues` (tool): 
Get the column names that having negative values in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_rowsWithMissingValues` (tool): 
Get the rows with missing values in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_standardDeviation` (tool): 
Get the standard deviation from column in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_univariateStatistics` (tool): 
Get the univariate statistics for a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

--- Category: Data Visualization ---
- `viz_createChart` (tool): Generates a data visualization based on provided data. You must specify the chart type and map the data fields to the appropriate visual roles.
  - Arguments:
    - `chart_type` (string, required): The type of chart to generate (e.g., 'bar', 'pie', 'line', 'scatter'). This MUST be one of the types listed in the 'Charting Guidelines'.
    - `data` (list[dict], required): The data to be visualized, passed directly from the output of another tool.
    - `title` (string, required): A descriptive title for the chart.
    - `mapping` (dict, required): A dictionary that maps data keys to chart axes or roles (e.g., {'x_axis': 'product_name', 'y_axis': 'sales_total'}). The required keys for this mapping depend on the selected chart_type.
--- Category: Database Information ---
- `cust_td_serverInfo` (tool): Get the Teradata software information: demonstrates how to use parameters for prepared statements.
  - Arguments:
    - `infokey` (string, optional): No description.
- `dba_databaseVersion` (tool):  Get Teradata database version information.
- `base_databaseList` (tool): Lists all databases in the Teradata System.
--- Category: Database Space ---
- `dba_databaseSpace` (tool): 
Get database space if database name is provided, otherwise get all databases space allocations.

Arguments:
  database_name - database name

Returns:
  ResponseType: formatted response with query results + metadata

- `get_cube_cust_cube_db_space_metrics` (tool): 
    Tool to query the cube 'table_skew_pct'.
    Get the Teradata database space metrics for tables and databases

    Expected inputs:
        dimensions (str): Comma-separated dimension names to group by. Allowed values:
    - DatabaseName: Name of the database
    - TableName: Name of the table

        measures (str): Comma-separated measure names to aggregate. Allowed values:
    - current_perm: Object perm space in bytes
    - peak_perm: Object peak perm space in bytes
    - table_skew_pct: Object skew percentage

        filters (str): Comma-separated filter expressions to apply to either dimensions or measures selected. The dimension or measure used must be in the dimension list to group by or measure list, use valid SQL expressions, for example:
DatabaseName = 'value'
TableName = 'value'
current_perm > 1000
peak_perm > 1000
table_skew_pct > 1000

    Returns:
        Query result as a formatted response.
    
  - Arguments:
    - `dimensions` (string, optional): No description.
    - `measures` (string, optional): No description.
    - `filters` (string, optional): No description.
- `dba_systemSpace` (tool): Get the Teradata total system database space usage.
--- Category: Performance ---
- `dba_resusageSummary` (tool): 
Get the Teradata system usage summary metrics by weekday and hour for each workload type and query complexity bucket.

Arguments:
  dimensions - list of dimensions to aggregate the resource usage summary. All dimensions are: ["LogDate", "hourOfDay", "dayOfWeek", "workloadType", "workloadComplexity", "UserName", "AppId", "StatementType"]
  user_name - user name
  date - Date to analyze, formatted as `YYYY-MM-DD`
  dayOfWeek - day of the week to analyze
  hourOfDay - hour of day to analyze


- `dba_flowControl` (tool): Get the Teradata flow control metrics for a specified date range.
  - Arguments:
    - `start_date` (string, optional): No description.
    - `end_date` (string, optional): No description.
- `dba_userDelay` (tool): Get the Teradata user delay metrics for a specified date range.
  - Arguments:
    - `start_date` (string, optional): No description.
    - `end_date` (string, optional): No description.
--- Category: Query Execution ---
- `base_readQuery` (tool): 
Execute a SQL query via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  sql    - SQL text, with optional bind-parameter placeholders

Returns:
  ResponseType: formatted response with query results + metadata

--- Category: Sales Analytics ---
- `sales_top_customers` (tool): Get the top 20 customers by lifetime value.
- `sales_customer_profile` (tool): Get customer profile and metrics.
  - Arguments:
    - `customer_key` (string, optional): No description.
- `get_cube_sales_cube` (tool): 
    Tool to query the cube 'order_count'.
    Get the key sales metrics: USD amount and number of orders.

    Expected inputs:
        dimensions (str): Comma-separated dimension names to group by. Allowed values:
    - customer_key: Key for the customer
    - sales_year: Year of the sale
    - sales_month: Month of the sale

        measures (str): Comma-separated measure names to aggregate. Allowed values:
    - gift_amount_usd: Total gift card amount used for the order in USD
    - total_amount_usd: Total order amount in USD
    - order_count: Total number of orders

        filters (str): Comma-separated filter expressions to apply to either dimensions or measures selected. The dimension or measure used must be in the dimension list to group by or measure list, use valid SQL expressions, for example:
customer_key = 'value'
sales_year = 'value'
sales_month = 'value'
gift_amount_usd > 1000
total_amount_usd > 1000
order_count > 1000

    Returns:
        Query result as a formatted response.
    
  - Arguments:
    - `dimensions` (string, optional): No description.
    - `measures` (string, optional): No description.
    - `filters` (string, optional): No description.
--- Category: Security ---
- `sec_rolePermissions` (tool): 
Get permissions for a role.

Arguments:
  role_name - role name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `sec_userDbPermissions` (tool): 
Get permissions for a user.

Arguments:
  user_name - user name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `sec_userRoles` (tool): 
Get roles assigned to a user.

Arguments:
  user_name - user name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

--- Category: Session Management ---
- `dba_sessionInfo` (tool): Get the Teradata session information for user.
  - Arguments:
    - `user_name` (string, optional): No description.
--- Category: Table Management ---
- `dba_tableSpace` (tool): 
Get table space used for a table if table name is provided or get table space for all tables in a database if a database name is provided."

Arguments:
  database_name - database name
  table_name - table name

Returns:
  ResponseType: formatted response with query results + metadata

- `dba_tableSqlList` (tool): 
Get a list of SQL run against a table in the last number of days.

Arguments:
  table_name - table name
  no_days - number of days

Returns:
  ResponseType: formatted response with query results + metadata

- `dba_tableUsageImpact` (tool): 
Measure the usage of a table and views by users, this is helpful to understand what user and tables are driving most resource usage at any point in time.

Arguments:
  database_name - database name to analyze
  user_name - user name to analyze


- `base_columnDescription` (tool): 
Shows detailed column information about a database table via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name
  obj_name - table or view name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableAffinity` (tool): 
Get tables commonly used together by database users, this is helpful to infer relationships between tables via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name
  object_name - table or view name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableDDL` (tool): 
Displays the DDL definition of a table via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name
  table_name - table name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tablePreview` (tool): 
This function returns data sample and inferred structure from a database table or view via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  table_name - table or view name
  database_name - Database name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableUsage` (tool): 
Measure the usage of a table and views by users in a given schema, this is helpful to infer what database objects are most actively used or drive most value via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableList` (tool): Lists all tables in a database.
  - Arguments:
    - `database_name` (string, optional): No description.
--- Category: Usage Tracking ---
- `dba_featureUsage` (tool): Get the user feature usage metrics for a specified date range.
  - Arguments:
    - `start_date` (string, optional): No description.
    - `end_date` (string, optional): No description.
--- Category: User Management ---
- `dba_userSqlList` (tool): 
Get a list of SQL run by a user in the last number of days if a user name is provided, otherwise get list of all SQL in the last number of days.

Arguments:
  user_name - user name
  no_days - number of days

Returns:
  ResponseType: formatted response with query results + metadata

- `cust_activeUsers` (tool): Fetch currently active database users
--- Category: Utilities ---
- `tmpl_nameOfTool` (tool): 
<description of what the tool is for>

Arguments:
  arguments - arguments to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `evs_similarity_search` (tool): 
Enterprise Vector Store similarity search

Arguments:
  question - the query string to search for
  top_k - number of top results to return

Returns:
  ResponseType: formatted response with query results + metadata

- `rag_executeWorkflow` (tool): 
Execute complete RAG workflow to answer user questions based on document context.


This function handles the entire RAG pipeline:
1. Configuration setup (using configurable values from rag_config.yml)
2. Store user query (with /rag prefix stripping)
3. Generate query embeddings (tokenization + embedding)
4. Perform semantic search against chunk embeddings
5. Return retrieved context chunks for answer generation

The function uses configuration values from rag_config.yml with fallback defaults.

Arguments:
  question - user question to process
  k - number of top-k results to return (optional, uses config default if not provided)

Returns:
  Returns the top-k most relevant chunks with metadata for context-grounded answer generation.

- `rag_executeWorkflow_ivsm` (tool): 
Execute complete RAG workflow to answer user questions based on document context.

This function handles the entire RAG pipeline using IVSM functions:
1. Configuration setup (using configurable values from rag_config.yml)
2. Store user query (with /rag prefix stripping)
3. Tokenize query using ivsm.tokenizer_encode
4. Create embedding view using ivsm.IVSM_score
5. Convert embeddings to vector columns using ivsm.vector_to_columns
6. Perform semantic search against chunk embeddings

The function uses configuration values from rag_config.yml with fallback defaults.

Arguments:
  question - user question to process
  k - number of top-k results to return (optional, uses config default if not provided

Returns:
  Returns the top-k most relevant chunks with metadata for context-grounded answer generation.

- `util_getCurrentDate` (tool): Returns the current system date in YYYY-MM-DD format. Use this as the first step for any user query involving relative dates like 'today', 'yesterday', or 'this week'.
- `util_calculateDateRange` (tool): Calculates a list of dates based on a start date and a natural language phrase (e.g., 'past 3 days', 'last week'). This is a necessary second step for multi-day queries.
  - Arguments:
    - `start_date` (string, required): The anchor date for the calculation, usually today's date from `util_getCurrentDate`. Must be in YYYY-MM-DD format.
    - `date_phrase` (string, required): The natural language phrase describing the desired range (e.g., 'past 3 days', 'last 2 weeks').
- `CoreLLMTask` (tool): Performs internal, LLM-driven tasks that are not direct calls to the Teradata database. This tool is used for text synthesis, summarization, and formatting based on a specific 'task_description' provided by the LLM itself.
  - Arguments:
    - `task_description` (string, required): A natural language description of the internal task to be executed (e.g., 'describe the table in a business context', 'format final output'). The LLM infers this from the workflow plan.
    - `source_data` (list[string], required): A list of keys (e.g., 'result_of_phase_1') identifying which data from the workflow history is relevant for this task. This is critical for providing the correct context.
--- Available Prompts ---
--- Category: Prompts ---
- `base_query` (prompt): Help users interact with  Teradata databases effectively.
  - Arguments:
    - `query` (str, required): The problem or question that needs to be solved using Teradata database tools.
- `base_tableBusinessDesc` (prompt): You are a Teradata DBA who is an expert in describing the business use of tables in a database.
  - Arguments:
    - `database_name` (str, required): Database for the table to describe.
    - `table_name` (str, required): Table to describe.


USER PROMPT:

You are an expert strategic planning assistant. Your task is to analyze a user's request or a complex workflow goal and decompose it into a high-level, phased meta-plan. This plan will serve as a state machine executor.

--- GOAL ---
what is the system utilization of the past 2 weeks?

--- CONTEXT ---
- User's Original Question (for reference): what is the system utilization of the past 2 weeks?

--- INSTRUCTIONS ---
1.  **Analyze the Goal**: Carefully read the "GOAL" to understand the user's full intent.
2.  **Decompose into Phases**: Break down the overall goal into a sequence of logical phases. Each phase should represent a major step.
3.  **Define Each Phase**: For each phase, create a JSON object with the following keys:
    -   `"phase"`: An integer representing the step number (e.g., 1, 2, 3).
    -   `"goal"`: A clear, concise, and actionable description of what must be accomplished in this phase. This goal will guide a separate, tactical LLM.
    -   `"relevant_tools"`: A list of tool names that are permitted to be used during this phase. You MUST select the most appropriate and specific tools from the full "Capabilities" list provided in the main system prompt to achieve the phase's goal.
    -   (Optional) `"type": "loop"`: If a phase requires iterating over a list of items, you MUST include this key.
    -   (Optional) `"loop_over"`: If `"type"` is `"loop"`, specify the data source for the iteration (e.g., `"result_of_phase_1"`).
4.  **Embed Parameters**: When defining the `"goal"` for a phase, you MUST scan the main "GOAL" for any hardcoded arguments or parameters (e.g., table names, database names) relevant to that phase's task. You MUST embed these found parameters directly into the `"goal"` string to make it self-contained and explicit.
5.  **Final Synthesis and Formatting Phase**: If the main "GOAL" describes a multi-step process with a final reporting requirement, your plan **MUST** conclude with a single, final phase that handles both the synthesis of the final report AND its formatting. The `relevant_tools` for this final phase **MUST** be `["CoreLLMTask"]`.
6.  **CRITICAL RULE (Simplicity)**: If the "GOAL" is a simple, direct request that can be answered with a single tool call (e.g., "list all databases", "what is the system utilization?"), your plan **MUST** consist of only a single phase that calls the one most appropriate tool. Do not add unnecessary synthesis phases for simple data retrieval.
7.  **CRITICAL RULE (Execution Focus)**: Every phase you define **MUST** correspond to a concrete, tool-based action. You **MUST NOT** create phases for simple verification, confirmation, or acknowledgement of known information. Your plan must focus only on the execution steps required to gather new information or process existing data.
8.  **CRITICAL RULE (Capability Types)**: You are generating a plan of executable **tools**. The `relevant_tools` list **MUST ONLY** contain names of capabilities that are explicitly marked as `(tool)` in the system's "Capabilities" list. You **MUST NOT** include the name of any capability marked as `(prompt)`.
9.  **CRITICAL RULE (Efficiency)**: If a phase's `"goal"` already contains all the instructions for the final synthesis and formatting of the report (as specified in the main "GOAL"), you **MUST** make this the last phase of the plan. Do not add a separate, redundant formatting-only phase after it.

--- EXAMPLE (Complex Goal) ---
If the main goal requires getting DDL and then describing/formatting, your output should be a two-phase plan like this:
```json
[
  {
    "phase": 1,
    "goal": "Get the DDL for the table 'customers' in database 'sales' using the `base_tableDDL` tool.",
    "relevant_tools": ["base_tableDDL"]
  },
  {
    "phase": 2,
    "goal": "Synthesize a final report by describing the 'customers' table in a business context and format the output as markdown according to the Final output guidelines, using `***` for keys.",
    "relevant_tools": ["CoreLLMTask"]
  }
]
```

--- EXAMPLE (Simple Goal) ---
If the main goal is "what is the system utilization?", your output should be a single-phase plan like this:
```json
[
  {
    "phase": 1,
    "goal": "Get the system utilization using the `dba_resusageSummary` tool.",
    "relevant_tools": ["dba_resusageSummary"]
  }
]
```

--- EXAMPLE (Date Range Goal) ---
If the main goal is "what is the system utilization for the past 3 days?", your output must be a three-phase plan like this:
```json
[
  {
    "phase": 1,
    "goal": "Get the current date using the `util_getCurrentDate` tool to establish a reference point.",
    "relevant_tools": ["util_getCurrentDate"]
  },
  {
    "phase": 2,
    "goal": "Calculate the list of dates for 'the past 3 days' using the `util_calculateDateRange` tool.",
    "relevant_tools": ["util_calculateDateRange"]
  },
  {
    "phase": 3,
    "goal": "For each date calculated in the previous step, get the system utilization using the `dba_resusageSummary` tool.",
    "relevant_tools": ["dba_resusageSummary"],
    "type": "loop",
    "loop_over": "result_of_phase_2"
  }
]
```

Your response MUST be a single, valid JSON list of phase objects. Do NOT add any extra text, conversation, or markdown.


2025-08-21 22:46:01,346 - --- RESPONSE ---
```json
[
  {
    "phase": 1,
    "goal": "Get the current date using the `util_getCurrentDate` tool to establish a reference point.",
    "relevant_tools": ["util_getCurrentDate"]
  },
  {
    "phase": 2,
    "goal": "Calculate the list of dates for 'past 2 weeks' using the `util_calculateDateRange` tool.",
    "relevant_tools": ["util_calculateDateRange"]
  },
  {
    "phase": 3,
    "goal": "For each date calculated in the previous step, get the system utilization using the `dba_resusageSummary` tool.",
    "relevant_tools": ["dba_resusageSummary"],
    "type": "loop",
    "loop_over": "result_of_phase_2"
  }
]
```
--------------------------------------------------

2025-08-21 22:46:02,233 - --- FULL CONTEXT (Session: df7e1f03-2ba5-457e-8b31-1a09c2af00c6) ---
--- REASON FOR CALL ---
Deciding next tactical action for phase: Get the current date using the `util_getCurrentDate` tool to establish a reference point.

--- History ---
[user]: You are a helpful assistant.
[model]: Understood.
[user]: SYSTEM PROMPT:

# Core Directives
You are a specialized assistant for a Teradata database system. Your primary goal is to fulfill user requests by selecting the best capability (a tool or a prompt) from the categorized lists provided and supplying all necessary arguments.

# Response Format
Your response MUST be a single JSON object for a tool/prompt call OR a single plain text string for a final answer.

1.  **Tool/Prompt Calls (JSON format):**
    -   If the capability is a prompt, you MUST use the key `"prompt_name"`.
    -   If the capability is a tool, you MUST use the key `"tool_name"`.
    -   Provide all required arguments. Infer values from the conversation history if necessary.
    -   Example (Prompt): `{"prompt_name": "some_prompt", "arguments": {"arg": "value"}}`
    -   Example (Tool): `{"tool_name": "some_tool", "arguments": {"arg": "value"}}`

2.  **Final Answer (Plain Text format):**
    -   When you have sufficient information to fully answer the user's request, you MUST stop using tools.
    -   Your response MUST begin with the exact prefix `FINAL_ANSWER:`, followed by a natural language summary.
    -   Example: `FINAL_ANSWER: I found 48 databases on the system. The details are displayed below.`

# Decision Process
To select the correct capability, you MUST follow this two-step process, governed by one critical rule:

**CRITICAL RULE: Prioritize Specificity and Arguments.** Your primary filter for selecting a capability is its specificity. You MUST select the most granular capability that uses the most entities from the user's request (e.g., prefer a tool that uses a `table_name` over one that only uses a `database_name` if a table is mentioned). For direct actions and single analyses, you MUST select a `tool_name`; only select a `prompt_name` for broad, multi-step tasks explicitly described by the prompt.

1.  **Identify the Category:** First, analyze the user's request to determine which Tool or Prompt Category is the most relevant to their intent. The available categories are listed in the "Capabilities" section below.
2.  **Select the Capability:** Second, from within that single most relevant category, select the best tool or prompt to fulfill the request, adhering to the Critical Rule above.

# Few-Shot Examples
Here are examples of the correct thinking process:

**Example 1:**
- **User Query:** "what is the quality of table 'online' in database 'DEMO_Customer360_db'?"
- **Thought Process:**
    1.  The user's query is about a **table**.
    2.  My critical rule is to prioritize specificity. I must choose a table-level tool.
    3.  The `qlty_databaseQuality` prompt is for databases, not specific tables, so it's incorrect.
    4.  The `qlty_columnSummary` tool takes a `table_name` and is the most specific, correct choice.
- **Correct Response:** `{"tool_name": "qlty_columnSummary", "arguments": {"database_name": "DEMO_Customer360_db", "table_name": "online"}}`

**Example 2:**
- **User Query:** "describe the business purpose of the 'DEMO_Customer360_db' database"
- **Thought Process:**
    1.  The user's query is about a **database**. It's a broad request ("describe").
    2.  A prompt is better for broad tasks.
    3.  The `base_databaseBusinessDesc` prompt takes a `database_name` and is the correct choice.
- **Correct Response:** `{"prompt_name": "base_databaseBusinessDesc", "arguments": {"database_name": "DEMO_Customer360_db"}}`

**Example 3:**
- **User Query:** "what is the system utilization?"
- **Thought Process:**
    1.  The user is asking for a specific metric: "system utilization". This is a direct request for data.
    2.  My critical rule states I must prioritize a `tool_name` for direct actions.
    3.  The `dba_systemVoice` prompt is for adopting a persona, not for fetching specific metrics. It is the incorrect choice.
    4.  The `dba_resusageSummary` tool in the `Performance` category is designed to get system usage summary metrics. This is the correct choice.
- **Correct Response:** `{"tool_name": "dba_resusageSummary", "arguments": {}}`

# Best Practices
- **Context is Key:** Always use information from previous turns to fill in arguments like `db_name` or `table_name`.
- **Error Recovery:** If a tool fails, analyze the error message and attempt to call the tool again with corrected parameters. Only ask the user for clarification if you cannot recover.
- **SQL Generation:** When using the `base_readQuery` tool, you MUST use fully qualified table names in your SQL (e.g., `SELECT ... FROM my_database.my_table`).
- **Time-Sensitive Queries:** For queries involving relative dates (e.g., 'today', 'this week'), you MUST use the `util_getCurrentDate` tool first to determine the current date before proceeding.
- **Out of Scope:** If the user's request is unrelated to the available capabilities, respond with a `FINAL_ANSWER:` that politely explains you cannot fulfill the request and restates your purpose.
- **CRITICAL: Avoid Repetitive Behavior.** You are a highly intelligent agent. Do not get stuck in a loop by repeating the same tool calls or by cycling through the same set of tools. Once a tool has returned a successful result with data that is relevant to the user's request, do not call that same tool again unless there is a new and compelling reason to do so. If you have called a series of tools and believe you have enough information, you must call a FINAL_ANSWER. Do not repeat tool calls just to be "through".


# Capabilities
--- Available Tools ---
--- Category: Data Quality ---
- `qlty_columnSummary` (tool): 
Get the column summary statistics for a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_distinctCategories` (tool): 
Get the destinct categories from column in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_missingValues` (tool): 
Get the column names that having missing values in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_negativeValues` (tool): 
Get the column names that having negative values in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_rowsWithMissingValues` (tool): 
Get the rows with missing values in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_standardDeviation` (tool): 
Get the standard deviation from column in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_univariateStatistics` (tool): 
Get the univariate statistics for a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

--- Category: Data Visualization ---
- `viz_createChart` (tool): Generates a data visualization based on provided data. You must specify the chart type and map the data fields to the appropriate visual roles.
  - Arguments:
    - `chart_type` (string, required): The type of chart to generate (e.g., 'bar', 'pie', 'line', 'scatter'). This MUST be one of the types listed in the 'Charting Guidelines'.
    - `data` (list[dict], required): The data to be visualized, passed directly from the output of another tool.
    - `title` (string, required): A descriptive title for the chart.
    - `mapping` (dict, required): A dictionary that maps data keys to chart axes or roles (e.g., {'x_axis': 'product_name', 'y_axis': 'sales_total'}). The required keys for this mapping depend on the selected chart_type.
--- Category: Database Information ---
- `cust_td_serverInfo` (tool): Get the Teradata software information: demonstrates how to use parameters for prepared statements.
  - Arguments:
    - `infokey` (string, optional): No description.
- `dba_databaseVersion` (tool):  Get Teradata database version information.
- `base_databaseList` (tool): Lists all databases in the Teradata System.
--- Category: Database Space ---
- `dba_databaseSpace` (tool): 
Get database space if database name is provided, otherwise get all databases space allocations.

Arguments:
  database_name - database name

Returns:
  ResponseType: formatted response with query results + metadata

- `get_cube_cust_cube_db_space_metrics` (tool): 
    Tool to query the cube 'table_skew_pct'.
    Get the Teradata database space metrics for tables and databases

    Expected inputs:
        dimensions (str): Comma-separated dimension names to group by. Allowed values:
    - DatabaseName: Name of the database
    - TableName: Name of the table

        measures (str): Comma-separated measure names to aggregate. Allowed values:
    - current_perm: Object perm space in bytes
    - peak_perm: Object peak perm space in bytes
    - table_skew_pct: Object skew percentage

        filters (str): Comma-separated filter expressions to apply to either dimensions or measures selected. The dimension or measure used must be in the dimension list to group by or measure list, use valid SQL expressions, for example:
DatabaseName = 'value'
TableName = 'value'
current_perm > 1000
peak_perm > 1000
table_skew_pct > 1000

    Returns:
        Query result as a formatted response.
    
  - Arguments:
    - `dimensions` (string, optional): No description.
    - `measures` (string, optional): No description.
    - `filters` (string, optional): No description.
- `dba_systemSpace` (tool): Get the Teradata total system database space usage.
--- Category: Performance ---
- `dba_resusageSummary` (tool): 
Get the Teradata system usage summary metrics by weekday and hour for each workload type and query complexity bucket.

Arguments:
  dimensions - list of dimensions to aggregate the resource usage summary. All dimensions are: ["LogDate", "hourOfDay", "dayOfWeek", "workloadType", "workloadComplexity", "UserName", "AppId", "StatementType"]
  user_name - user name
  date - Date to analyze, formatted as `YYYY-MM-DD`
  dayOfWeek - day of the week to analyze
  hourOfDay - hour of day to analyze


- `dba_flowControl` (tool): Get the Teradata flow control metrics for a specified date range.
  - Arguments:
    - `start_date` (string, optional): No description.
    - `end_date` (string, optional): No description.
- `dba_userDelay` (tool): Get the Teradata user delay metrics for a specified date range.
  - Arguments:
    - `start_date` (string, optional): No description.
    - `end_date` (string, optional): No description.
--- Category: Query Execution ---
- `base_readQuery` (tool): 
Execute a SQL query via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  sql    - SQL text, with optional bind-parameter placeholders

Returns:
  ResponseType: formatted response with query results + metadata

--- Category: Sales Analytics ---
- `sales_top_customers` (tool): Get the top 20 customers by lifetime value.
- `sales_customer_profile` (tool): Get customer profile and metrics.
  - Arguments:
    - `customer_key` (string, optional): No description.
- `get_cube_sales_cube` (tool): 
    Tool to query the cube 'order_count'.
    Get the key sales metrics: USD amount and number of orders.

    Expected inputs:
        dimensions (str): Comma-separated dimension names to group by. Allowed values:
    - customer_key: Key for the customer
    - sales_year: Year of the sale
    - sales_month: Month of the sale

        measures (str): Comma-separated measure names to aggregate. Allowed values:
    - gift_amount_usd: Total gift card amount used for the order in USD
    - total_amount_usd: Total order amount in USD
    - order_count: Total number of orders

        filters (str): Comma-separated filter expressions to apply to either dimensions or measures selected. The dimension or measure used must be in the dimension list to group by or measure list, use valid SQL expressions, for example:
customer_key = 'value'
sales_year = 'value'
sales_month = 'value'
gift_amount_usd > 1000
total_amount_usd > 1000
order_count > 1000

    Returns:
        Query result as a formatted response.
    
  - Arguments:
    - `dimensions` (string, optional): No description.
    - `measures` (string, optional): No description.
    - `filters` (string, optional): No description.
--- Category: Security ---
- `sec_rolePermissions` (tool): 
Get permissions for a role.

Arguments:
  role_name - role name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `sec_userDbPermissions` (tool): 
Get permissions for a user.

Arguments:
  user_name - user name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `sec_userRoles` (tool): 
Get roles assigned to a user.

Arguments:
  user_name - user name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

--- Category: Session Management ---
- `dba_sessionInfo` (tool): Get the Teradata session information for user.
  - Arguments:
    - `user_name` (string, optional): No description.
--- Category: Table Management ---
- `dba_tableSpace` (tool): 
Get table space used for a table if table name is provided or get table space for all tables in a database if a database name is provided."

Arguments:
  database_name - database name
  table_name - table name

Returns:
  ResponseType: formatted response with query results + metadata

- `dba_tableSqlList` (tool): 
Get a list of SQL run against a table in the last number of days.

Arguments:
  table_name - table name
  no_days - number of days

Returns:
  ResponseType: formatted response with query results + metadata

- `dba_tableUsageImpact` (tool): 
Measure the usage of a table and views by users, this is helpful to understand what user and tables are driving most resource usage at any point in time.

Arguments:
  database_name - database name to analyze
  user_name - user name to analyze


- `base_columnDescription` (tool): 
Shows detailed column information about a database table via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name
  obj_name - table or view name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableAffinity` (tool): 
Get tables commonly used together by database users, this is helpful to infer relationships between tables via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name
  object_name - table or view name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableDDL` (tool): 
Displays the DDL definition of a table via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name
  table_name - table name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tablePreview` (tool): 
This function returns data sample and inferred structure from a database table or view via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  table_name - table or view name
  database_name - Database name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableUsage` (tool): 
Measure the usage of a table and views by users in a given schema, this is helpful to infer what database objects are most actively used or drive most value via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableList` (tool): Lists all tables in a database.
  - Arguments:
    - `database_name` (string, optional): No description.
--- Category: Usage Tracking ---
- `dba_featureUsage` (tool): Get the user feature usage metrics for a specified date range.
  - Arguments:
    - `start_date` (string, optional): No description.
    - `end_date` (string, optional): No description.
--- Category: User Management ---
- `dba_userSqlList` (tool): 
Get a list of SQL run by a user in the last number of days if a user name is provided, otherwise get list of all SQL in the last number of days.

Arguments:
  user_name - user name
  no_days - number of days

Returns:
  ResponseType: formatted response with query results + metadata

- `cust_activeUsers` (tool): Fetch currently active database users
--- Category: Utilities ---
- `tmpl_nameOfTool` (tool): 
<description of what the tool is for>

Arguments:
  arguments - arguments to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `evs_similarity_search` (tool): 
Enterprise Vector Store similarity search

Arguments:
  question - the query string to search for
  top_k - number of top results to return

Returns:
  ResponseType: formatted response with query results + metadata

- `rag_executeWorkflow` (tool): 
Execute complete RAG workflow to answer user questions based on document context.


This function handles the entire RAG pipeline:
1. Configuration setup (using configurable values from rag_config.yml)
2. Store user query (with /rag prefix stripping)
3. Generate query embeddings (tokenization + embedding)
4. Perform semantic search against chunk embeddings
5. Return retrieved context chunks for answer generation

The function uses configuration values from rag_config.yml with fallback defaults.

Arguments:
  question - user question to process
  k - number of top-k results to return (optional, uses config default if not provided)

Returns:
  Returns the top-k most relevant chunks with metadata for context-grounded answer generation.

- `rag_executeWorkflow_ivsm` (tool): 
Execute complete RAG workflow to answer user questions based on document context.

This function handles the entire RAG pipeline using IVSM functions:
1. Configuration setup (using configurable values from rag_config.yml)
2. Store user query (with /rag prefix stripping)
3. Tokenize query using ivsm.tokenizer_encode
4. Create embedding view using ivsm.IVSM_score
5. Convert embeddings to vector columns using ivsm.vector_to_columns
6. Perform semantic search against chunk embeddings

The function uses configuration values from rag_config.yml with fallback defaults.

Arguments:
  question - user question to process
  k - number of top-k results to return (optional, uses config default if not provided

Returns:
  Returns the top-k most relevant chunks with metadata for context-grounded answer generation.

- `util_getCurrentDate` (tool): Returns the current system date in YYYY-MM-DD format. Use this as the first step for any user query involving relative dates like 'today', 'yesterday', or 'this week'.
- `util_calculateDateRange` (tool): Calculates a list of dates based on a start date and a natural language phrase (e.g., 'past 3 days', 'last week'). This is a necessary second step for multi-day queries.
  - Arguments:
    - `start_date` (string, required): The anchor date for the calculation, usually today's date from `util_getCurrentDate`. Must be in YYYY-MM-DD format.
    - `date_phrase` (string, required): The natural language phrase describing the desired range (e.g., 'past 3 days', 'last 2 weeks').
- `CoreLLMTask` (tool): Performs internal, LLM-driven tasks that are not direct calls to the Teradata database. This tool is used for text synthesis, summarization, and formatting based on a specific 'task_description' provided by the LLM itself.
  - Arguments:
    - `task_description` (string, required): A natural language description of the internal task to be executed (e.g., 'describe the table in a business context', 'format final output'). The LLM infers this from the workflow plan.
    - `source_data` (list[string], required): A list of keys (e.g., 'result_of_phase_1') identifying which data from the workflow history is relevant for this task. This is critical for providing the correct context.
--- Available Prompts ---
--- Category: Prompts ---
- `base_query` (prompt): Help users interact with  Teradata databases effectively.
  - Arguments:
    - `query` (str, required): The problem or question that needs to be solved using Teradata database tools.
- `base_tableBusinessDesc` (prompt): You are a Teradata DBA who is an expert in describing the business use of tables in a database.
  - Arguments:
    - `database_name` (str, required): Database for the table to describe.
    - `table_name` (str, required): Table to describe.


USER PROMPT:

You are an expert strategic planning assistant. Your task is to analyze a user's request or a complex workflow goal and decompose it into a high-level, phased meta-plan. This plan will serve as a state machine executor.

--- GOAL ---
what is the system utilization of the past 3 days?

--- CONTEXT ---
- User's Original Question (for reference): what is the system utilization of the past 3 days?

--- INSTRUCTIONS ---
1.  **Analyze the Goal**: Carefully read the "GOAL" to understand the user's full intent.
2.  **Decompose into Phases**: Break down the overall goal into a sequence of logical phases. Each phase should represent a major step.
3.  **Define Each Phase**: For each phase, create a JSON object with the following keys:
    -   `"phase"`: An integer representing the step number (e.g., 1, 2, 3).
    -   `"goal"`: A clear, concise, and actionable description of what must be accomplished in this phase. This goal will guide a separate, tactical LLM.
    -   `"relevant_tools"`: A list of tool names that are permitted to be used during this phase. You MUST select the most appropriate and specific tools from the full "Capabilities" list provided in the main system prompt to achieve the phase's goal.
    -   (Optional) `"type": "loop"`: If a phase requires iterating over a list of items, you MUST include this key.
    -   (Optional) `"loop_over"`: If `"type"` is `"loop"`, specify the data source for the iteration (e.g., `"result_of_phase_1"`).
4.  **Embed Parameters**: When defining the `"goal"` for a phase, you MUST scan the main "GOAL" for any hardcoded arguments or parameters (e.g., table names, database names) relevant to that phase's task. You MUST embed these found parameters directly into the `"goal"` string to make it self-contained and explicit.
5.  **Final Synthesis and Formatting Phase**: If the main "GOAL" describes a multi-step process with a final reporting requirement, your plan **MUST** conclude with a single, final phase that handles both the synthesis of the final report AND its formatting. The `relevant_tools` for this final phase **MUST** be `["CoreLLMTask"]`.
6.  **CRITICAL RULE (Simplicity)**: If the "GOAL" is a simple, direct request that can be answered with a single tool call (e.g., "list all databases", "what is the system utilization?"), your plan **MUST** consist of only a single phase that calls the one most appropriate tool. Do not add unnecessary synthesis phases for simple data retrieval.
7.  **CRITICAL RULE (Execution Focus)**: Every phase you define **MUST** correspond to a concrete, tool-based action. You **MUST NOT** create phases for simple verification, confirmation, or acknowledgement of known information. Your plan must focus only on the execution steps required to gather new information or process existing data.
8.  **CRITICAL RULE (Capability Types)**: You are generating a plan of executable **tools**. The `relevant_tools` list **MUST ONLY** contain names of capabilities that are explicitly marked as `(tool)` in the system's "Capabilities" list. You **MUST NOT** include the name of any capability marked as `(prompt)`.
9.  **CRITICAL RULE (Efficiency)**: If a phase's `"goal"` already contains all the instructions for the final synthesis and formatting of the report (as specified in the main "GOAL"), you **MUST** make this the last phase of the plan. Do not add a separate, redundant formatting-only phase after it.

--- EXAMPLE (Complex Goal) ---
If the main goal requires getting DDL and then describing/formatting, your output should be a two-phase plan like this:
```json
[
  {
    "phase": 1,
    "goal": "Get the DDL for the table 'customers' in database 'sales' using the `base_tableDDL` tool.",
    "relevant_tools": ["base_tableDDL"]
  },
  {
    "phase": 2,
    "goal": "Synthesize a final report by describing the 'customers' table in a business context and format the output as markdown according to the Final output guidelines, using `***` for keys.",
    "relevant_tools": ["CoreLLMTask"]
  }
]
```

--- EXAMPLE (Simple Goal) ---
If the main goal is "what is the system utilization?", your output should be a single-phase plan like this:
```json
[
  {
    "phase": 1,
    "goal": "Get the system utilization using the `dba_resusageSummary` tool.",
    "relevant_tools": ["dba_resusageSummary"]
  }
]
```

--- EXAMPLE (Date Range Goal) ---
If the main goal is "what is the system utilization for the past 3 days?", your output must be a three-phase plan like this:
```json
[
  {
    "phase": 1,
    "goal": "Get the current date using the `util_getCurrentDate` tool to establish a reference point.",
    "relevant_tools": ["util_getCurrentDate"]
  },
  {
    "phase": 2,
    "goal": "Calculate the list of dates for 'the past 3 days' using the `util_calculateDateRange` tool.",
    "relevant_tools": ["util_calculateDateRange"]
  },
  {
    "phase": 3,
    "goal": "For each date calculated in the previous step, get the system utilization using the `dba_resusageSummary` tool.",
    "relevant_tools": ["dba_resusageSummary"],
    "type": "loop",
    "loop_over": "result_of_phase_2"
  }
]
```

Your response MUST be a single, valid JSON list of phase objects. Do NOT add any extra text, conversation, or markdown.

[model]: ```json
[
  {
    "phase": 1,
    "goal": "Get the current date using the `util_getCurrentDate` tool to establish a reference point.",
    "relevant_tools": ["util_getCurrentDate"]
  },
  {
    "phase": 2,
    "goal": "Calculate the list of dates for 'past 3 days' using the `util_calculateDateRange` tool.",
    "relevant_tools": ["util_calculateDateRange"]
  },
  {
    "phase": 3,
    "goal": "For each date calculated in the previous step, get the system utilization using the `dba_resusageSummary` tool.",
    "relevant_tools": ["dba_resusageSummary"],
    "type": "loop",
    "loop_over": "result_of_phase_2"
  }
]
```
[user]: SYSTEM PROMPT:

You are a tactical assistant executing a single phase of a larger plan. Your task is to decide the single best next action to take to achieve the current phase's goal, strictly adhering to the provided tool constraints.

--- OVERALL WORKFLOW GOAL ---
what is the system utilization of the past 3 days?

--- CURRENT PHASE GOAL ---
Get the current date using the `util_getCurrentDate` tool to establish a reference point.

--- CONSTRAINTS ---
- Permitted Tools for this Phase (You MUST use the exact argument names provided):

- Tool: `util_getCurrentDate`
  - Description: Returns the current system date in YYYY-MM-DD format. Use this as the first step for any user query involving relative dates like 'today', 'yesterday', or 'this week'.

- Previous Attempt (if any): None

--- WORKFLOW STATE & HISTORY ---
- Actions Taken So Far: []
- Data Collected So Far: {}

--- INSTRUCTIONS ---
1.  **Analyze the State**: Review the "CURRENT PHASE GOAL" and the "WORKFLOW STATE & HISTORY" to understand what has been done and what is needed next.
2.  **CRITICAL RULE (Tool Selection & Arguments)**: You **MUST** select your next action from the list of "Permitted Tools for this Phase". You are not allowed to use any other tool. Furthermore, you **MUST** use the exact argument names as they are defined in the tool details above. You **MUST NOT** invent, hallucinate, or use any arguments that are not explicitly listed in the definitions.
3.  **Self-Correction**: If a "Previous Attempt" is noted in the "CONSTRAINTS" section, it means your last choice was invalid. You **MUST** analyze the error and choose a different, valid tool from the permitted list. Do not repeat the invalid choice.
4.  **CoreLLMTask Usage**:
    -   For any task that involves synthesis, analysis, description, or summarization, you **MUST** use the `CoreLLMTask` tool, but only if it is in the permitted tools list.
    -   When calling `CoreLLMTask`, you **MUST** provide the `task_description` argument.
    -   Crucially, you **MUST** also determine which previous phase results are necessary for the task. You **MUST** provide these as a list of strings in the `source_data` argument.
    -   **CONTEXT PRESERVATION RULE**: If the current phase involves creating a final summary or report for the user, you **MUST** ensure you have all the necessary context. Your `source_data` list **MUST** include the results from **ALL** previous data-gathering phases (e.g., `["result_of_phase_1", "result_of_phase_2"]`) to prevent information loss.
5.  **Handle Loops**: If you are in a looping phase (indicated by the presence of a "LOOP CONTEXT" section), you **MUST** focus your action on the single item provided in `current_loop_item`. You **MUST** use the information within that item to formulate the arguments for your tool call.
6.  **Format Response**: Your response MUST be a single JSON object for a tool call.

Your response MUST be a single, valid JSON object for a tool call. Do NOT add any extra text or conversation.


USER PROMPT:
Determine the next action based on the instructions and state provided in the system prompt.
[model]: ```json
{"tool_name": "util_getCurrentDate", "arguments": {}}
```
[user]: SYSTEM PROMPT:

You are a tactical assistant executing a single phase of a larger plan. Your task is to decide the single best next action to take to achieve the current phase's goal, strictly adhering to the provided tool constraints.

--- OVERALL WORKFLOW GOAL ---
what is the system utilization of the past 3 days?

--- CURRENT PHASE GOAL ---
Calculate the list of dates for 'past 3 days' using the `util_calculateDateRange` tool.

--- CONSTRAINTS ---
- Permitted Tools for this Phase (You MUST use the exact argument names provided):

- Tool: `util_calculateDateRange`
  - Description: Calculates a list of dates based on a start date and a natural language phrase (e.g., 'past 3 days', 'last week'). This is a necessary second step for multi-day queries.
  - Arguments:
    - `start_date` (string, required): The anchor date for the calculation, usually today's date from `util_getCurrentDate`. Must be in YYYY-MM-DD format.
    - `date_phrase` (string, required): The natural language phrase describing the desired range (e.g., 'past 3 days', 'last 2 weeks').

- Previous Attempt (if any): None

--- WORKFLOW STATE & HISTORY ---
- Actions Taken So Far: [
  {
    "action": {
      "tool_name": "util_getCurrentDate",
      "arguments": {}
    },
    "result": {
      "status": "success",
      "metadata": {
        "tool_name": "util_getCurrentDate"
      },
      "results": [
        {
          "current_date": "2025-08-21"
        }
      ]
    }
  }
]
- Data Collected So Far: {
  "result_of_phase_1": [
    {
      "status": "success",
      "metadata": {
        "tool_name": "util_getCurrentDate"
      },
      "results": [
        {
          "current_date": "2025-08-21"
        }
      ]
    }
  ]
}

--- INSTRUCTIONS ---
1.  **Analyze the State**: Review the "CURRENT PHASE GOAL" and the "WORKFLOW STATE & HISTORY" to understand what has been done and what is needed next.
2.  **CRITICAL RULE (Tool Selection & Arguments)**: You **MUST** select your next action from the list of "Permitted Tools for this Phase". You are not allowed to use any other tool. Furthermore, you **MUST** use the exact argument names as they are defined in the tool details above. You **MUST NOT** invent, hallucinate, or use any arguments that are not explicitly listed in the definitions.
3.  **Self-Correction**: If a "Previous Attempt" is noted in the "CONSTRAINTS" section, it means your last choice was invalid. You **MUST** analyze the error and choose a different, valid tool from the permitted list. Do not repeat the invalid choice.
4.  **CoreLLMTask Usage**:
    -   For any task that involves synthesis, analysis, description, or summarization, you **MUST** use the `CoreLLMTask` tool, but only if it is in the permitted tools list.
    -   When calling `CoreLLMTask`, you **MUST** provide the `task_description` argument.
    -   Crucially, you **MUST** also determine which previous phase results are necessary for the task. You **MUST** provide these as a list of strings in the `source_data` argument.
    -   **CONTEXT PRESERVATION RULE**: If the current phase involves creating a final summary or report for the user, you **MUST** ensure you have all the necessary context. Your `source_data` list **MUST** include the results from **ALL** previous data-gathering phases (e.g., `["result_of_phase_1", "result_of_phase_2"]`) to prevent information loss.
5.  **Handle Loops**: If you are in a looping phase (indicated by the presence of a "LOOP CONTEXT" section), you **MUST** focus your action on the single item provided in `current_loop_item`. You **MUST** use the information within that item to formulate the arguments for your tool call.
6.  **Format Response**: Your response MUST be a single JSON object for a tool call.

Your response MUST be a single, valid JSON object for a tool call. Do NOT add any extra text or conversation.


USER PROMPT:
Determine the next action based on the instructions and state provided in the system prompt.
[model]: ```json
{"tool_name": "util_calculateDateRange", "arguments": {"start_date": "2025-08-21", "date_phrase": "past 3 days"}}
```
[user]: SYSTEM PROMPT:

# Core Directives
You are a specialized assistant for a Teradata database system. Your primary goal is to fulfill user requests by selecting the best capability (a tool or a prompt) from the categorized lists provided and supplying all necessary arguments.

# Response Format
Your response MUST be a single JSON object for a tool/prompt call OR a single plain text string for a final answer.

1.  **Tool/Prompt Calls (JSON format):**
    -   If the capability is a prompt, you MUST use the key `"prompt_name"`.
    -   If the capability is a tool, you MUST use the key `"tool_name"`.
    -   Provide all required arguments. Infer values from the conversation history if necessary.
    -   Example (Prompt): `{"prompt_name": "some_prompt", "arguments": {"arg": "value"}}`
    -   Example (Tool): `{"tool_name": "some_tool", "arguments": {"arg": "value"}}`

2.  **Final Answer (Plain Text format):**
    -   When you have sufficient information to fully answer the user's request, you MUST stop using tools.
    -   Your response MUST begin with the exact prefix `FINAL_ANSWER:`, followed by a natural language summary.
    -   Example: `FINAL_ANSWER: I found 48 databases on the system. The details are displayed below.`

# Decision Process
To select the correct capability, you MUST follow this two-step process, governed by one critical rule:

**CRITICAL RULE: Prioritize Specificity and Arguments.** Your primary filter for selecting a capability is its specificity. You MUST select the most granular capability that uses the most entities from the user's request (e.g., prefer a tool that uses a `table_name` over one that only uses a `database_name` if a table is mentioned). For direct actions and single analyses, you MUST select a `tool_name`; only select a `prompt_name` for broad, multi-step tasks explicitly described by the prompt.

1.  **Identify the Category:** First, analyze the user's request to determine which Tool or Prompt Category is the most relevant to their intent. The available categories are listed in the "Capabilities" section below.
2.  **Select the Capability:** Second, from within that single most relevant category, select the best tool or prompt to fulfill the request, adhering to the Critical Rule above.

# Few-Shot Examples
Here are examples of the correct thinking process:

**Example 1:**
- **User Query:** "what is the quality of table 'online' in database 'DEMO_Customer360_db'?"
- **Thought Process:**
    1.  The user's query is about a **table**.
    2.  My critical rule is to prioritize specificity. I must choose a table-level tool.
    3.  The `qlty_databaseQuality` prompt is for databases, not specific tables, so it's incorrect.
    4.  The `qlty_columnSummary` tool takes a `table_name` and is the most specific, correct choice.
- **Correct Response:** `{"tool_name": "qlty_columnSummary", "arguments": {"database_name": "DEMO_Customer360_db", "table_name": "online"}}`

**Example 2:**
- **User Query:** "describe the business purpose of the 'DEMO_Customer360_db' database"
- **Thought Process:**
    1.  The user's query is about a **database**. It's a broad request ("describe").
    2.  A prompt is better for broad tasks.
    3.  The `base_databaseBusinessDesc` prompt takes a `database_name` and is the correct choice.
- **Correct Response:** `{"prompt_name": "base_databaseBusinessDesc", "arguments": {"database_name": "DEMO_Customer360_db"}}`

**Example 3:**
- **User Query:** "what is the system utilization?"
- **Thought Process:**
    1.  The user is asking for a specific metric: "system utilization". This is a direct request for data.
    2.  My critical rule states I must prioritize a `tool_name` for direct actions.
    3.  The `dba_systemVoice` prompt is for adopting a persona, not for fetching specific metrics. It is the incorrect choice.
    4.  The `dba_resusageSummary` tool in the `Performance` category is designed to get system usage summary metrics. This is the correct choice.
- **Correct Response:** `{"tool_name": "dba_resusageSummary", "arguments": {}}`

# Best Practices
- **Context is Key:** Always use information from previous turns to fill in arguments like `db_name` or `table_name`.
- **Error Recovery:** If a tool fails, analyze the error message and attempt to call the tool again with corrected parameters. Only ask the user for clarification if you cannot recover.
- **SQL Generation:** When using the `base_readQuery` tool, you MUST use fully qualified table names in your SQL (e.g., `SELECT ... FROM my_database.my_table`).
- **Time-Sensitive Queries:** For queries involving relative dates (e.g., 'today', 'this week'), you MUST use the `util_getCurrentDate` tool first to determine the current date before proceeding.
- **Out of Scope:** If the user's request is unrelated to the available capabilities, respond with a `FINAL_ANSWER:` that politely explains you cannot fulfill the request and restates your purpose.
- **CRITICAL: Avoid Repetitive Behavior.** You are a highly intelligent agent. Do not get stuck in a loop by repeating the same tool calls or by cycling through the same set of tools. Once a tool has returned a successful result with data that is relevant to the user's request, do not call that same tool again unless there is a new and compelling reason to do so. If you have called a series of tools and believe you have enough information, you must call a FINAL_ANSWER. Do not repeat tool calls just to be "through".


# Capabilities
--- Available Tools ---
--- Category: Data Quality ---
- `qlty_columnSummary` (tool): 
Get the column summary statistics for a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_distinctCategories` (tool): 
Get the destinct categories from column in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_missingValues` (tool): 
Get the column names that having missing values in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_negativeValues` (tool): 
Get the column names that having negative values in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_rowsWithMissingValues` (tool): 
Get the rows with missing values in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_standardDeviation` (tool): 
Get the standard deviation from column in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_univariateStatistics` (tool): 
Get the univariate statistics for a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

--- Category: Data Visualization ---
- `viz_createChart` (tool): Generates a data visualization based on provided data. You must specify the chart type and map the data fields to the appropriate visual roles.
  - Arguments:
    - `chart_type` (string, required): The type of chart to generate (e.g., 'bar', 'pie', 'line', 'scatter'). This MUST be one of the types listed in the 'Charting Guidelines'.
    - `data` (list[dict], required): The data to be visualized, passed directly from the output of another tool.
    - `title` (string, required): A descriptive title for the chart.
    - `mapping` (dict, required): A dictionary that maps data keys to chart axes or roles (e.g., {'x_axis': 'product_name', 'y_axis': 'sales_total'}). The required keys for this mapping depend on the selected chart_type.
--- Category: Database Information ---
- `cust_td_serverInfo` (tool): Get the Teradata software information: demonstrates how to use parameters for prepared statements.
  - Arguments:
    - `infokey` (string, optional): No description.
- `dba_databaseVersion` (tool):  Get Teradata database version information.
- `base_databaseList` (tool): Lists all databases in the Teradata System.
--- Category: Database Space ---
- `dba_databaseSpace` (tool): 
Get database space if database name is provided, otherwise get all databases space allocations.

Arguments:
  database_name - database name

Returns:
  ResponseType: formatted response with query results + metadata

- `get_cube_cust_cube_db_space_metrics` (tool): 
    Tool to query the cube 'table_skew_pct'.
    Get the Teradata database space metrics for tables and databases

    Expected inputs:
        dimensions (str): Comma-separated dimension names to group by. Allowed values:
    - DatabaseName: Name of the database
    - TableName: Name of the table

        measures (str): Comma-separated measure names to aggregate. Allowed values:
    - current_perm: Object perm space in bytes
    - peak_perm: Object peak perm space in bytes
    - table_skew_pct: Object skew percentage

        filters (str): Comma-separated filter expressions to apply to either dimensions or measures selected. The dimension or measure used must be in the dimension list to group by or measure list, use valid SQL expressions, for example:
DatabaseName = 'value'
TableName = 'value'
current_perm > 1000
peak_perm > 1000
table_skew_pct > 1000

    Returns:
        Query result as a formatted response.
    
  - Arguments:
    - `dimensions` (string, optional): No description.
    - `measures` (string, optional): No description.
    - `filters` (string, optional): No description.
- `dba_systemSpace` (tool): Get the Teradata total system database space usage.
--- Category: Performance ---
- `dba_resusageSummary` (tool): 
Get the Teradata system usage summary metrics by weekday and hour for each workload type and query complexity bucket.

Arguments:
  dimensions - list of dimensions to aggregate the resource usage summary. All dimensions are: ["LogDate", "hourOfDay", "dayOfWeek", "workloadType", "workloadComplexity", "UserName", "AppId", "StatementType"]
  user_name - user name
  date - Date to analyze, formatted as `YYYY-MM-DD`
  dayOfWeek - day of the week to analyze
  hourOfDay - hour of day to analyze


- `dba_flowControl` (tool): Get the Teradata flow control metrics for a specified date range.
  - Arguments:
    - `start_date` (string, optional): No description.
    - `end_date` (string, optional): No description.
- `dba_userDelay` (tool): Get the Teradata user delay metrics for a specified date range.
  - Arguments:
    - `start_date` (string, optional): No description.
    - `end_date` (string, optional): No description.
--- Category: Query Execution ---
- `base_readQuery` (tool): 
Execute a SQL query via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  sql    - SQL text, with optional bind-parameter placeholders

Returns:
  ResponseType: formatted response with query results + metadata

--- Category: Sales Analytics ---
- `sales_top_customers` (tool): Get the top 20 customers by lifetime value.
- `sales_customer_profile` (tool): Get customer profile and metrics.
  - Arguments:
    - `customer_key` (string, optional): No description.
- `get_cube_sales_cube` (tool): 
    Tool to query the cube 'order_count'.
    Get the key sales metrics: USD amount and number of orders.

    Expected inputs:
        dimensions (str): Comma-separated dimension names to group by. Allowed values:
    - customer_key: Key for the customer
    - sales_year: Year of the sale
    - sales_month: Month of the sale

        measures (str): Comma-separated measure names to aggregate. Allowed values:
    - gift_amount_usd: Total gift card amount used for the order in USD
    - total_amount_usd: Total order amount in USD
    - order_count: Total number of orders

        filters (str): Comma-separated filter expressions to apply to either dimensions or measures selected. The dimension or measure used must be in the dimension list to group by or measure list, use valid SQL expressions, for example:
customer_key = 'value'
sales_year = 'value'
sales_month = 'value'
gift_amount_usd > 1000
total_amount_usd > 1000
order_count > 1000

    Returns:
        Query result as a formatted response.
    
  - Arguments:
    - `dimensions` (string, optional): No description.
    - `measures` (string, optional): No description.
    - `filters` (string, optional): No description.
--- Category: Security ---
- `sec_rolePermissions` (tool): 
Get permissions for a role.

Arguments:
  role_name - role name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `sec_userDbPermissions` (tool): 
Get permissions for a user.

Arguments:
  user_name - user name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `sec_userRoles` (tool): 
Get roles assigned to a user.

Arguments:
  user_name - user name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

--- Category: Session Management ---
- `dba_sessionInfo` (tool): Get the Teradata session information for user.
  - Arguments:
    - `user_name` (string, optional): No description.
--- Category: Table Management ---
- `dba_tableSpace` (tool): 
Get table space used for a table if table name is provided or get table space for all tables in a database if a database name is provided."

Arguments:
  database_name - database name
  table_name - table name

Returns:
  ResponseType: formatted response with query results + metadata

- `dba_tableSqlList` (tool): 
Get a list of SQL run against a table in the last number of days.

Arguments:
  table_name - table name
  no_days - number of days

Returns:
  ResponseType: formatted response with query results + metadata

- `dba_tableUsageImpact` (tool): 
Measure the usage of a table and views by users, this is helpful to understand what user and tables are driving most resource usage at any point in time.

Arguments:
  database_name - database name to analyze
  user_name - user name to analyze


- `base_columnDescription` (tool): 
Shows detailed column information about a database table via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name
  obj_name - table or view name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableAffinity` (tool): 
Get tables commonly used together by database users, this is helpful to infer relationships between tables via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name
  object_name - table or view name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableDDL` (tool): 
Displays the DDL definition of a table via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name
  table_name - table name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tablePreview` (tool): 
This function returns data sample and inferred structure from a database table or view via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  table_name - table or view name
  database_name - Database name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableUsage` (tool): 
Measure the usage of a table and views by users in a given schema, this is helpful to infer what database objects are most actively used or drive most value via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableList` (tool): Lists all tables in a database.
  - Arguments:
    - `database_name` (string, optional): No description.
--- Category: Usage Tracking ---
- `dba_featureUsage` (tool): Get the user feature usage metrics for a specified date range.
  - Arguments:
    - `start_date` (string, optional): No description.
    - `end_date` (string, optional): No description.
--- Category: User Management ---
- `dba_userSqlList` (tool): 
Get a list of SQL run by a user in the last number of days if a user name is provided, otherwise get list of all SQL in the last number of days.

Arguments:
  user_name - user name
  no_days - number of days

Returns:
  ResponseType: formatted response with query results + metadata

- `cust_activeUsers` (tool): Fetch currently active database users
--- Category: Utilities ---
- `tmpl_nameOfTool` (tool): 
<description of what the tool is for>

Arguments:
  arguments - arguments to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `evs_similarity_search` (tool): 
Enterprise Vector Store similarity search

Arguments:
  question - the query string to search for
  top_k - number of top results to return

Returns:
  ResponseType: formatted response with query results + metadata

- `rag_executeWorkflow` (tool): 
Execute complete RAG workflow to answer user questions based on document context.


This function handles the entire RAG pipeline:
1. Configuration setup (using configurable values from rag_config.yml)
2. Store user query (with /rag prefix stripping)
3. Generate query embeddings (tokenization + embedding)
4. Perform semantic search against chunk embeddings
5. Return retrieved context chunks for answer generation

The function uses configuration values from rag_config.yml with fallback defaults.

Arguments:
  question - user question to process
  k - number of top-k results to return (optional, uses config default if not provided)

Returns:
  Returns the top-k most relevant chunks with metadata for context-grounded answer generation.

- `rag_executeWorkflow_ivsm` (tool): 
Execute complete RAG workflow to answer user questions based on document context.

This function handles the entire RAG pipeline using IVSM functions:
1. Configuration setup (using configurable values from rag_config.yml)
2. Store user query (with /rag prefix stripping)
3. Tokenize query using ivsm.tokenizer_encode
4. Create embedding view using ivsm.IVSM_score
5. Convert embeddings to vector columns using ivsm.vector_to_columns
6. Perform semantic search against chunk embeddings

The function uses configuration values from rag_config.yml with fallback defaults.

Arguments:
  question - user question to process
  k - number of top-k results to return (optional, uses config default if not provided

Returns:
  Returns the top-k most relevant chunks with metadata for context-grounded answer generation.

- `util_getCurrentDate` (tool): Returns the current system date in YYYY-MM-DD format. Use this as the first step for any user query involving relative dates like 'today', 'yesterday', or 'this week'.
- `util_calculateDateRange` (tool): Calculates a list of dates based on a start date and a natural language phrase (e.g., 'past 3 days', 'last week'). This is a necessary second step for multi-day queries.
  - Arguments:
    - `start_date` (string, required): The anchor date for the calculation, usually today's date from `util_getCurrentDate`. Must be in YYYY-MM-DD format.
    - `date_phrase` (string, required): The natural language phrase describing the desired range (e.g., 'past 3 days', 'last 2 weeks').
- `CoreLLMTask` (tool): Performs internal, LLM-driven tasks that are not direct calls to the Teradata database. This tool is used for text synthesis, summarization, and formatting based on a specific 'task_description' provided by the LLM itself.
  - Arguments:
    - `task_description` (string, required): A natural language description of the internal task to be executed (e.g., 'describe the table in a business context', 'format final output'). The LLM infers this from the workflow plan.
    - `source_data` (list[string], required): A list of keys (e.g., 'result_of_phase_1') identifying which data from the workflow history is relevant for this task. This is critical for providing the correct context.
--- Available Prompts ---
--- Category: Prompts ---
- `base_query` (prompt): Help users interact with  Teradata databases effectively.
  - Arguments:
    - `query` (str, required): The problem or question that needs to be solved using Teradata database tools.
- `base_tableBusinessDesc` (prompt): You are a Teradata DBA who is an expert in describing the business use of tables in a database.
  - Arguments:
    - `database_name` (str, required): Database for the table to describe.
    - `table_name` (str, required): Table to describe.


USER PROMPT:
You are an expert data analyst. Synthesize all collected data into a clear, concise, and insightful final answer.

--- USER'S QUESTION ---
'what is the system utilization of the past 3 days?'

--- DATA COLLECTED ---
```json
[
  {
    "status": "success",
    "metadata": {
      "tool_name": "util_getCurrentDate"
    },
    "results": [
      {
        "current_date": "2025-08-21"
      }
    ]
  },
  {
    "status": "success",
    "metadata": {
      "tool_name": "util_calculateDateRange"
    },
    "results": [
      {
        "date": "2025-08-18"
      },
      {
        "date": "2025-08-19"
      },
      {
        "date": "2025-08-20"
      }
    ]
  },
  {
    "status": "success",
    "metadata": {
      "tool_name": "dba_resusageSummary",
      "total_rows": 1,
      "comment": "Total system resource usage summary."
    },
    "results": [
      {
        "Request Count": "0",
        "Total AMPCPUTime": "None",
        "Total IOCount": "None",
        "Total ReqIOKB": "None",
        "Total ReqPhysIO": "None",
        "Total ReqPhysIOKB": "None",
        "Total ReqIO GB": "None",
        "Total ReqPhysIOGB": "None",
        "Total Server Byte Count": "None"
      }
    ]
  },
  {
    "status": "success",
    "metadata": {
      "tool_name": "dba_resusageSummary",
      "total_rows": 1,
      "comment": "Total system resource usage summary."
    },
    "results": [
      {
        "Request Count": "283",
        "Total AMPCPUTime": "1.1800000000000002",
        "Total IOCount": "15931.0",
        "Total ReqIOKB": "741228.0",
        "Total ReqPhysIO": "44.0",
        "Total ReqPhysIOKB": "904.0",
        "Total ReqIO GB": "0.7068901062011719",
        "Total ReqPhysIOGB": "0.00086212158203125",
        "Total Server Byte Count": "0"
      }
    ]
  },
  {
    "status": "success",
    "metadata": {
      "tool_name": "dba_resusageSummary",
      "total_rows": 1,
      "comment": "Total system resource usage summary."
    },
    "results": [
      {
        "Request Count": "121",
        "Total AMPCPUTime": "0.316",
        "Total IOCount": "3929.0",
        "Total ReqIOKB": "163096.0",
        "Total ReqPhysIO": "8.0",
        "Total ReqPhysIOKB": "184.0",
        "Total ReqIO GB": "0.15554046630859375",
        "Total ReqPhysIOGB": "0.00017547607421875",
        "Total Server Byte Count": "0"
      }
    ]
  }
]
```

--- INSTRUCTIONS ---
1.  Provide a holistic analysis and actionable insights.
2.  Begin with a high-level summary, then use bullet points for key observations.
3.  Your entire response **MUST** begin with `FINAL_ANSWER:`.

[model]: FINAL_ANSWER: The system utilization for the past 3 days (2025-08-18 to 2025-08-20) shows varying levels of activity.

*   **2025-08-18:** No resource usage data was found for this date.
*   **2025-08-19:** The system processed 283 requests, consuming 1.18 AMP CPU seconds and performing 15931 I/O operations, with a total of 741228 KB of I/O.
*   **2025-08-20:** The system processed 121 requests, consuming 0.316 AMP CPU seconds and performing 3929 I/O operations, with a total of 163096 KB of I/O.

[user]: SYSTEM PROMPT:

# Core Directives
You are a specialized assistant for a Teradata database system. Your primary goal is to fulfill user requests by selecting the best capability (a tool or a prompt) from the categorized lists provided and supplying all necessary arguments.

# Response Format
Your response MUST be a single JSON object for a tool/prompt call OR a single plain text string for a final answer.

1.  **Tool/Prompt Calls (JSON format):**
    -   If the capability is a prompt, you MUST use the key `"prompt_name"`.
    -   If the capability is a tool, you MUST use the key `"tool_name"`.
    -   Provide all required arguments. Infer values from the conversation history if necessary.
    -   Example (Prompt): `{"prompt_name": "some_prompt", "arguments": {"arg": "value"}}`
    -   Example (Tool): `{"tool_name": "some_tool", "arguments": {"arg": "value"}}`

2.  **Final Answer (Plain Text format):**
    -   When you have sufficient information to fully answer the user's request, you MUST stop using tools.
    -   Your response MUST begin with the exact prefix `FINAL_ANSWER:`, followed by a natural language summary.
    -   Example: `FINAL_ANSWER: I found 48 databases on the system. The details are displayed below.`

# Decision Process
To select the correct capability, you MUST follow this two-step process, governed by one critical rule:

**CRITICAL RULE: Prioritize Specificity and Arguments.** Your primary filter for selecting a capability is its specificity. You MUST select the most granular capability that uses the most entities from the user's request (e.g., prefer a tool that uses a `table_name` over one that only uses a `database_name` if a table is mentioned). For direct actions and single analyses, you MUST select a `tool_name`; only select a `prompt_name` for broad, multi-step tasks explicitly described by the prompt.

1.  **Identify the Category:** First, analyze the user's request to determine which Tool or Prompt Category is the most relevant to their intent. The available categories are listed in the "Capabilities" section below.
2.  **Select the Capability:** Second, from within that single most relevant category, select the best tool or prompt to fulfill the request, adhering to the Critical Rule above.

# Few-Shot Examples
Here are examples of the correct thinking process:

**Example 1:**
- **User Query:** "what is the quality of table 'online' in database 'DEMO_Customer360_db'?"
- **Thought Process:**
    1.  The user's query is about a **table**.
    2.  My critical rule is to prioritize specificity. I must choose a table-level tool.
    3.  The `qlty_databaseQuality` prompt is for databases, not specific tables, so it's incorrect.
    4.  The `qlty_columnSummary` tool takes a `table_name` and is the most specific, correct choice.
- **Correct Response:** `{"tool_name": "qlty_columnSummary", "arguments": {"database_name": "DEMO_Customer360_db", "table_name": "online"}}`

**Example 2:**
- **User Query:** "describe the business purpose of the 'DEMO_Customer360_db' database"
- **Thought Process:**
    1.  The user's query is about a **database**. It's a broad request ("describe").
    2.  A prompt is better for broad tasks.
    3.  The `base_databaseBusinessDesc` prompt takes a `database_name` and is the correct choice.
- **Correct Response:** `{"prompt_name": "base_databaseBusinessDesc", "arguments": {"database_name": "DEMO_Customer360_db"}}`

**Example 3:**
- **User Query:** "what is the system utilization?"
- **Thought Process:**
    1.  The user is asking for a specific metric: "system utilization". This is a direct request for data.
    2.  My critical rule states I must prioritize a `tool_name` for direct actions.
    3.  The `dba_systemVoice` prompt is for adopting a persona, not for fetching specific metrics. It is the incorrect choice.
    4.  The `dba_resusageSummary` tool in the `Performance` category is designed to get system usage summary metrics. This is the correct choice.
- **Correct Response:** `{"tool_name": "dba_resusageSummary", "arguments": {}}`

# Best Practices
- **Context is Key:** Always use information from previous turns to fill in arguments like `db_name` or `table_name`.
- **Error Recovery:** If a tool fails, analyze the error message and attempt to call the tool again with corrected parameters. Only ask the user for clarification if you cannot recover.
- **SQL Generation:** When using the `base_readQuery` tool, you MUST use fully qualified table names in your SQL (e.g., `SELECT ... FROM my_database.my_table`).
- **Time-Sensitive Queries:** For queries involving relative dates (e.g., 'today', 'this week'), you MUST use the `util_getCurrentDate` tool first to determine the current date before proceeding.
- **Out of Scope:** If the user's request is unrelated to the available capabilities, respond with a `FINAL_ANSWER:` that politely explains you cannot fulfill the request and restates your purpose.
- **CRITICAL: Avoid Repetitive Behavior.** You are a highly intelligent agent. Do not get stuck in a loop by repeating the same tool calls or by cycling through the same set of tools. Once a tool has returned a successful result with data that is relevant to the user's request, do not call that same tool again unless there is a new and compelling reason to do so. If you have called a series of tools and believe you have enough information, you must call a FINAL_ANSWER. Do not repeat tool calls just to be "through".


# Capabilities
--- Available Tools ---
--- Category: Data Quality ---
- `qlty_columnSummary` (tool): 
Get the column summary statistics for a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_distinctCategories` (tool): 
Get the destinct categories from column in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_missingValues` (tool): 
Get the column names that having missing values in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_negativeValues` (tool): 
Get the column names that having negative values in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_rowsWithMissingValues` (tool): 
Get the rows with missing values in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_standardDeviation` (tool): 
Get the standard deviation from column in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_univariateStatistics` (tool): 
Get the univariate statistics for a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

--- Category: Data Visualization ---
- `viz_createChart` (tool): Generates a data visualization based on provided data. You must specify the chart type and map the data fields to the appropriate visual roles.
  - Arguments:
    - `chart_type` (string, required): The type of chart to generate (e.g., 'bar', 'pie', 'line', 'scatter'). This MUST be one of the types listed in the 'Charting Guidelines'.
    - `data` (list[dict], required): The data to be visualized, passed directly from the output of another tool.
    - `title` (string, required): A descriptive title for the chart.
    - `mapping` (dict, required): A dictionary that maps data keys to chart axes or roles (e.g., {'x_axis': 'product_name', 'y_axis': 'sales_total'}). The required keys for this mapping depend on the selected chart_type.
--- Category: Database Information ---
- `cust_td_serverInfo` (tool): Get the Teradata software information: demonstrates how to use parameters for prepared statements.
  - Arguments:
    - `infokey` (string, optional): No description.
- `dba_databaseVersion` (tool):  Get Teradata database version information.
- `base_databaseList` (tool): Lists all databases in the Teradata System.
--- Category: Database Space ---
- `dba_databaseSpace` (tool): 
Get database space if database name is provided, otherwise get all databases space allocations.

Arguments:
  database_name - database name

Returns:
  ResponseType: formatted response with query results + metadata

- `get_cube_cust_cube_db_space_metrics` (tool): 
    Tool to query the cube 'table_skew_pct'.
    Get the Teradata database space metrics for tables and databases

    Expected inputs:
        dimensions (str): Comma-separated dimension names to group by. Allowed values:
    - DatabaseName: Name of the database
    - TableName: Name of the table

        measures (str): Comma-separated measure names to aggregate. Allowed values:
    - current_perm: Object perm space in bytes
    - peak_perm: Object peak perm space in bytes
    - table_skew_pct: Object skew percentage

        filters (str): Comma-separated filter expressions to apply to either dimensions or measures selected. The dimension or measure used must be in the dimension list to group by or measure list, use valid SQL expressions, for example:
DatabaseName = 'value'
TableName = 'value'
current_perm > 1000
peak_perm > 1000
table_skew_pct > 1000

    Returns:
        Query result as a formatted response.
    
  - Arguments:
    - `dimensions` (string, optional): No description.
    - `measures` (string, optional): No description.
    - `filters` (string, optional): No description.
- `dba_systemSpace` (tool): Get the Teradata total system database space usage.
--- Category: Performance ---
- `dba_resusageSummary` (tool): 
Get the Teradata system usage summary metrics by weekday and hour for each workload type and query complexity bucket.

Arguments:
  dimensions - list of dimensions to aggregate the resource usage summary. All dimensions are: ["LogDate", "hourOfDay", "dayOfWeek", "workloadType", "workloadComplexity", "UserName", "AppId", "StatementType"]
  user_name - user name
  date - Date to analyze, formatted as `YYYY-MM-DD`
  dayOfWeek - day of the week to analyze
  hourOfDay - hour of day to analyze


- `dba_flowControl` (tool): Get the Teradata flow control metrics for a specified date range.
  - Arguments:
    - `start_date` (string, optional): No description.
    - `end_date` (string, optional): No description.
- `dba_userDelay` (tool): Get the Teradata user delay metrics for a specified date range.
  - Arguments:
    - `start_date` (string, optional): No description.
    - `end_date` (string, optional): No description.
--- Category: Query Execution ---
- `base_readQuery` (tool): 
Execute a SQL query via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  sql    - SQL text, with optional bind-parameter placeholders

Returns:
  ResponseType: formatted response with query results + metadata

--- Category: Sales Analytics ---
- `sales_top_customers` (tool): Get the top 20 customers by lifetime value.
- `sales_customer_profile` (tool): Get customer profile and metrics.
  - Arguments:
    - `customer_key` (string, optional): No description.
- `get_cube_sales_cube` (tool): 
    Tool to query the cube 'order_count'.
    Get the key sales metrics: USD amount and number of orders.

    Expected inputs:
        dimensions (str): Comma-separated dimension names to group by. Allowed values:
    - customer_key: Key for the customer
    - sales_year: Year of the sale
    - sales_month: Month of the sale

        measures (str): Comma-separated measure names to aggregate. Allowed values:
    - gift_amount_usd: Total gift card amount used for the order in USD
    - total_amount_usd: Total order amount in USD
    - order_count: Total number of orders

        filters (str): Comma-separated filter expressions to apply to either dimensions or measures selected. The dimension or measure used must be in the dimension list to group by or measure list, use valid SQL expressions, for example:
customer_key = 'value'
sales_year = 'value'
sales_month = 'value'
gift_amount_usd > 1000
total_amount_usd > 1000
order_count > 1000

    Returns:
        Query result as a formatted response.
    
  - Arguments:
    - `dimensions` (string, optional): No description.
    - `measures` (string, optional): No description.
    - `filters` (string, optional): No description.
--- Category: Security ---
- `sec_rolePermissions` (tool): 
Get permissions for a role.

Arguments:
  role_name - role name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `sec_userDbPermissions` (tool): 
Get permissions for a user.

Arguments:
  user_name - user name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `sec_userRoles` (tool): 
Get roles assigned to a user.

Arguments:
  user_name - user name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

--- Category: Session Management ---
- `dba_sessionInfo` (tool): Get the Teradata session information for user.
  - Arguments:
    - `user_name` (string, optional): No description.
--- Category: Table Management ---
- `dba_tableSpace` (tool): 
Get table space used for a table if table name is provided or get table space for all tables in a database if a database name is provided."

Arguments:
  database_name - database name
  table_name - table name

Returns:
  ResponseType: formatted response with query results + metadata

- `dba_tableSqlList` (tool): 
Get a list of SQL run against a table in the last number of days.

Arguments:
  table_name - table name
  no_days - number of days

Returns:
  ResponseType: formatted response with query results + metadata

- `dba_tableUsageImpact` (tool): 
Measure the usage of a table and views by users, this is helpful to understand what user and tables are driving most resource usage at any point in time.

Arguments:
  database_name - database name to analyze
  user_name - user name to analyze


- `base_columnDescription` (tool): 
Shows detailed column information about a database table via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name
  obj_name - table or view name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableAffinity` (tool): 
Get tables commonly used together by database users, this is helpful to infer relationships between tables via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name
  object_name - table or view name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableDDL` (tool): 
Displays the DDL definition of a table via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name
  table_name - table name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tablePreview` (tool): 
This function returns data sample and inferred structure from a database table or view via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  table_name - table or view name
  database_name - Database name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableUsage` (tool): 
Measure the usage of a table and views by users in a given schema, this is helpful to infer what database objects are most actively used or drive most value via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableList` (tool): Lists all tables in a database.
  - Arguments:
    - `database_name` (string, optional): No description.
--- Category: Usage Tracking ---
- `dba_featureUsage` (tool): Get the user feature usage metrics for a specified date range.
  - Arguments:
    - `start_date` (string, optional): No description.
    - `end_date` (string, optional): No description.
--- Category: User Management ---
- `dba_userSqlList` (tool): 
Get a list of SQL run by a user in the last number of days if a user name is provided, otherwise get list of all SQL in the last number of days.

Arguments:
  user_name - user name
  no_days - number of days

Returns:
  ResponseType: formatted response with query results + metadata

- `cust_activeUsers` (tool): Fetch currently active database users
--- Category: Utilities ---
- `tmpl_nameOfTool` (tool): 
<description of what the tool is for>

Arguments:
  arguments - arguments to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `evs_similarity_search` (tool): 
Enterprise Vector Store similarity search

Arguments:
  question - the query string to search for
  top_k - number of top results to return

Returns:
  ResponseType: formatted response with query results + metadata

- `rag_executeWorkflow` (tool): 
Execute complete RAG workflow to answer user questions based on document context.


This function handles the entire RAG pipeline:
1. Configuration setup (using configurable values from rag_config.yml)
2. Store user query (with /rag prefix stripping)
3. Generate query embeddings (tokenization + embedding)
4. Perform semantic search against chunk embeddings
5. Return retrieved context chunks for answer generation

The function uses configuration values from rag_config.yml with fallback defaults.

Arguments:
  question - user question to process
  k - number of top-k results to return (optional, uses config default if not provided)

Returns:
  Returns the top-k most relevant chunks with metadata for context-grounded answer generation.

- `rag_executeWorkflow_ivsm` (tool): 
Execute complete RAG workflow to answer user questions based on document context.

This function handles the entire RAG pipeline using IVSM functions:
1. Configuration setup (using configurable values from rag_config.yml)
2. Store user query (with /rag prefix stripping)
3. Tokenize query using ivsm.tokenizer_encode
4. Create embedding view using ivsm.IVSM_score
5. Convert embeddings to vector columns using ivsm.vector_to_columns
6. Perform semantic search against chunk embeddings

The function uses configuration values from rag_config.yml with fallback defaults.

Arguments:
  question - user question to process
  k - number of top-k results to return (optional, uses config default if not provided

Returns:
  Returns the top-k most relevant chunks with metadata for context-grounded answer generation.

- `util_getCurrentDate` (tool): Returns the current system date in YYYY-MM-DD format. Use this as the first step for any user query involving relative dates like 'today', 'yesterday', or 'this week'.
- `util_calculateDateRange` (tool): Calculates a list of dates based on a start date and a natural language phrase (e.g., 'past 3 days', 'last week'). This is a necessary second step for multi-day queries.
  - Arguments:
    - `start_date` (string, required): The anchor date for the calculation, usually today's date from `util_getCurrentDate`. Must be in YYYY-MM-DD format.
    - `date_phrase` (string, required): The natural language phrase describing the desired range (e.g., 'past 3 days', 'last 2 weeks').
- `CoreLLMTask` (tool): Performs internal, LLM-driven tasks that are not direct calls to the Teradata database. This tool is used for text synthesis, summarization, and formatting based on a specific 'task_description' provided by the LLM itself.
  - Arguments:
    - `task_description` (string, required): A natural language description of the internal task to be executed (e.g., 'describe the table in a business context', 'format final output'). The LLM infers this from the workflow plan.
    - `source_data` (list[string], required): A list of keys (e.g., 'result_of_phase_1') identifying which data from the workflow history is relevant for this task. This is critical for providing the correct context.
--- Available Prompts ---
--- Category: Prompts ---
- `base_query` (prompt): Help users interact with  Teradata databases effectively.
  - Arguments:
    - `query` (str, required): The problem or question that needs to be solved using Teradata database tools.
- `base_tableBusinessDesc` (prompt): You are a Teradata DBA who is an expert in describing the business use of tables in a database.
  - Arguments:
    - `database_name` (str, required): Database for the table to describe.
    - `table_name` (str, required): Table to describe.


USER PROMPT:

You are an expert strategic planning assistant. Your task is to analyze a user's request or a complex workflow goal and decompose it into a high-level, phased meta-plan. This plan will serve as a state machine executor.

--- GOAL ---
what is the system utilization of the past 2 weeks?

--- CONTEXT ---
- User's Original Question (for reference): what is the system utilization of the past 2 weeks?

--- INSTRUCTIONS ---
1.  **Analyze the Goal**: Carefully read the "GOAL" to understand the user's full intent.
2.  **Decompose into Phases**: Break down the overall goal into a sequence of logical phases. Each phase should represent a major step.
3.  **Define Each Phase**: For each phase, create a JSON object with the following keys:
    -   `"phase"`: An integer representing the step number (e.g., 1, 2, 3).
    -   `"goal"`: A clear, concise, and actionable description of what must be accomplished in this phase. This goal will guide a separate, tactical LLM.
    -   `"relevant_tools"`: A list of tool names that are permitted to be used during this phase. You MUST select the most appropriate and specific tools from the full "Capabilities" list provided in the main system prompt to achieve the phase's goal.
    -   (Optional) `"type": "loop"`: If a phase requires iterating over a list of items, you MUST include this key.
    -   (Optional) `"loop_over"`: If `"type"` is `"loop"`, specify the data source for the iteration (e.g., `"result_of_phase_1"`).
4.  **Embed Parameters**: When defining the `"goal"` for a phase, you MUST scan the main "GOAL" for any hardcoded arguments or parameters (e.g., table names, database names) relevant to that phase's task. You MUST embed these found parameters directly into the `"goal"` string to make it self-contained and explicit.
5.  **Final Synthesis and Formatting Phase**: If the main "GOAL" describes a multi-step process with a final reporting requirement, your plan **MUST** conclude with a single, final phase that handles both the synthesis of the final report AND its formatting. The `relevant_tools` for this final phase **MUST** be `["CoreLLMTask"]`.
6.  **CRITICAL RULE (Simplicity)**: If the "GOAL" is a simple, direct request that can be answered with a single tool call (e.g., "list all databases", "what is the system utilization?"), your plan **MUST** consist of only a single phase that calls the one most appropriate tool. Do not add unnecessary synthesis phases for simple data retrieval.
7.  **CRITICAL RULE (Execution Focus)**: Every phase you define **MUST** correspond to a concrete, tool-based action. You **MUST NOT** create phases for simple verification, confirmation, or acknowledgement of known information. Your plan must focus only on the execution steps required to gather new information or process existing data.
8.  **CRITICAL RULE (Capability Types)**: You are generating a plan of executable **tools**. The `relevant_tools` list **MUST ONLY** contain names of capabilities that are explicitly marked as `(tool)` in the system's "Capabilities" list. You **MUST NOT** include the name of any capability marked as `(prompt)`.
9.  **CRITICAL RULE (Efficiency)**: If a phase's `"goal"` already contains all the instructions for the final synthesis and formatting of the report (as specified in the main "GOAL"), you **MUST** make this the last phase of the plan. Do not add a separate, redundant formatting-only phase after it.

--- EXAMPLE (Complex Goal) ---
If the main goal requires getting DDL and then describing/formatting, your output should be a two-phase plan like this:
```json
[
  {
    "phase": 1,
    "goal": "Get the DDL for the table 'customers' in database 'sales' using the `base_tableDDL` tool.",
    "relevant_tools": ["base_tableDDL"]
  },
  {
    "phase": 2,
    "goal": "Synthesize a final report by describing the 'customers' table in a business context and format the output as markdown according to the Final output guidelines, using `***` for keys.",
    "relevant_tools": ["CoreLLMTask"]
  }
]
```

--- EXAMPLE (Simple Goal) ---
If the main goal is "what is the system utilization?", your output should be a single-phase plan like this:
```json
[
  {
    "phase": 1,
    "goal": "Get the system utilization using the `dba_resusageSummary` tool.",
    "relevant_tools": ["dba_resusageSummary"]
  }
]
```

--- EXAMPLE (Date Range Goal) ---
If the main goal is "what is the system utilization for the past 3 days?", your output must be a three-phase plan like this:
```json
[
  {
    "phase": 1,
    "goal": "Get the current date using the `util_getCurrentDate` tool to establish a reference point.",
    "relevant_tools": ["util_getCurrentDate"]
  },
  {
    "phase": 2,
    "goal": "Calculate the list of dates for 'the past 3 days' using the `util_calculateDateRange` tool.",
    "relevant_tools": ["util_calculateDateRange"]
  },
  {
    "phase": 3,
    "goal": "For each date calculated in the previous step, get the system utilization using the `dba_resusageSummary` tool.",
    "relevant_tools": ["dba_resusageSummary"],
    "type": "loop",
    "loop_over": "result_of_phase_2"
  }
]
```

Your response MUST be a single, valid JSON list of phase objects. Do NOT add any extra text, conversation, or markdown.

[model]: ```json
[
  {
    "phase": 1,
    "goal": "Get the current date using the `util_getCurrentDate` tool to establish a reference point.",
    "relevant_tools": ["util_getCurrentDate"]
  },
  {
    "phase": 2,
    "goal": "Calculate the list of dates for 'past 2 weeks' using the `util_calculateDateRange` tool.",
    "relevant_tools": ["util_calculateDateRange"]
  },
  {
    "phase": 3,
    "goal": "For each date calculated in the previous step, get the system utilization using the `dba_resusageSummary` tool.",
    "relevant_tools": ["dba_resusageSummary"],
    "type": "loop",
    "loop_over": "result_of_phase_2"
  }
]
```

--- Current User Prompt (with System Prompt) ---
SYSTEM PROMPT:

You are a tactical assistant executing a single phase of a larger plan. Your task is to decide the single best next action to take to achieve the current phase's goal, strictly adhering to the provided tool constraints.

--- OVERALL WORKFLOW GOAL ---
what is the system utilization of the past 2 weeks?

--- CURRENT PHASE GOAL ---
Get the current date using the `util_getCurrentDate` tool to establish a reference point.

--- CONSTRAINTS ---
- Permitted Tools for this Phase (You MUST use the exact argument names provided):

- Tool: `util_getCurrentDate`
  - Description: Returns the current system date in YYYY-MM-DD format. Use this as the first step for any user query involving relative dates like 'today', 'yesterday', or 'this week'.

- Previous Attempt (if any): None

--- WORKFLOW STATE & HISTORY ---
- Actions Taken So Far: []
- Data Collected So Far: {}

--- INSTRUCTIONS ---
1.  **Analyze the State**: Review the "CURRENT PHASE GOAL" and the "WORKFLOW STATE & HISTORY" to understand what has been done and what is needed next.
2.  **CRITICAL RULE (Tool Selection & Arguments)**: You **MUST** select your next action from the list of "Permitted Tools for this Phase". You are not allowed to use any other tool. Furthermore, you **MUST** use the exact argument names as they are defined in the tool details above. You **MUST NOT** invent, hallucinate, or use any arguments that are not explicitly listed in the definitions.
3.  **Self-Correction**: If a "Previous Attempt" is noted in the "CONSTRAINTS" section, it means your last choice was invalid. You **MUST** analyze the error and choose a different, valid tool from the permitted list. Do not repeat the invalid choice.
4.  **CoreLLMTask Usage**:
    -   For any task that involves synthesis, analysis, description, or summarization, you **MUST** use the `CoreLLMTask` tool, but only if it is in the permitted tools list.
    -   When calling `CoreLLMTask`, you **MUST** provide the `task_description` argument.
    -   Crucially, you **MUST** also determine which previous phase results are necessary for the task. You **MUST** provide these as a list of strings in the `source_data` argument.
    -   **CONTEXT PRESERVATION RULE**: If the current phase involves creating a final summary or report for the user, you **MUST** ensure you have all the necessary context. Your `source_data` list **MUST** include the results from **ALL** previous data-gathering phases (e.g., `["result_of_phase_1", "result_of_phase_2"]`) to prevent information loss.
5.  **Handle Loops**: If you are in a looping phase (indicated by the presence of a "LOOP CONTEXT" section), you **MUST** focus your action on the single item provided in `current_loop_item`. You **MUST** use the information within that item to formulate the arguments for your tool call.
6.  **Format Response**: Your response MUST be a single JSON object for a tool call.

Your response MUST be a single, valid JSON object for a tool call. Do NOT add any extra text or conversation.


USER PROMPT:
Determine the next action based on the instructions and state provided in the system prompt.

2025-08-21 22:46:02,234 - --- RESPONSE ---
```json
{"tool_name": "util_getCurrentDate", "arguments": {}}
```
--------------------------------------------------

2025-08-21 22:46:03,217 - --- FULL CONTEXT (Session: df7e1f03-2ba5-457e-8b31-1a09c2af00c6) ---
--- REASON FOR CALL ---
Deciding next tactical action for phase: Calculate the list of dates for 'past 2 weeks' using the `util_calculateDateRange` tool.

--- History ---
[user]: You are a helpful assistant.
[model]: Understood.
[user]: SYSTEM PROMPT:

# Core Directives
You are a specialized assistant for a Teradata database system. Your primary goal is to fulfill user requests by selecting the best capability (a tool or a prompt) from the categorized lists provided and supplying all necessary arguments.

# Response Format
Your response MUST be a single JSON object for a tool/prompt call OR a single plain text string for a final answer.

1.  **Tool/Prompt Calls (JSON format):**
    -   If the capability is a prompt, you MUST use the key `"prompt_name"`.
    -   If the capability is a tool, you MUST use the key `"tool_name"`.
    -   Provide all required arguments. Infer values from the conversation history if necessary.
    -   Example (Prompt): `{"prompt_name": "some_prompt", "arguments": {"arg": "value"}}`
    -   Example (Tool): `{"tool_name": "some_tool", "arguments": {"arg": "value"}}`

2.  **Final Answer (Plain Text format):**
    -   When you have sufficient information to fully answer the user's request, you MUST stop using tools.
    -   Your response MUST begin with the exact prefix `FINAL_ANSWER:`, followed by a natural language summary.
    -   Example: `FINAL_ANSWER: I found 48 databases on the system. The details are displayed below.`

# Decision Process
To select the correct capability, you MUST follow this two-step process, governed by one critical rule:

**CRITICAL RULE: Prioritize Specificity and Arguments.** Your primary filter for selecting a capability is its specificity. You MUST select the most granular capability that uses the most entities from the user's request (e.g., prefer a tool that uses a `table_name` over one that only uses a `database_name` if a table is mentioned). For direct actions and single analyses, you MUST select a `tool_name`; only select a `prompt_name` for broad, multi-step tasks explicitly described by the prompt.

1.  **Identify the Category:** First, analyze the user's request to determine which Tool or Prompt Category is the most relevant to their intent. The available categories are listed in the "Capabilities" section below.
2.  **Select the Capability:** Second, from within that single most relevant category, select the best tool or prompt to fulfill the request, adhering to the Critical Rule above.

# Few-Shot Examples
Here are examples of the correct thinking process:

**Example 1:**
- **User Query:** "what is the quality of table 'online' in database 'DEMO_Customer360_db'?"
- **Thought Process:**
    1.  The user's query is about a **table**.
    2.  My critical rule is to prioritize specificity. I must choose a table-level tool.
    3.  The `qlty_databaseQuality` prompt is for databases, not specific tables, so it's incorrect.
    4.  The `qlty_columnSummary` tool takes a `table_name` and is the most specific, correct choice.
- **Correct Response:** `{"tool_name": "qlty_columnSummary", "arguments": {"database_name": "DEMO_Customer360_db", "table_name": "online"}}`

**Example 2:**
- **User Query:** "describe the business purpose of the 'DEMO_Customer360_db' database"
- **Thought Process:**
    1.  The user's query is about a **database**. It's a broad request ("describe").
    2.  A prompt is better for broad tasks.
    3.  The `base_databaseBusinessDesc` prompt takes a `database_name` and is the correct choice.
- **Correct Response:** `{"prompt_name": "base_databaseBusinessDesc", "arguments": {"database_name": "DEMO_Customer360_db"}}`

**Example 3:**
- **User Query:** "what is the system utilization?"
- **Thought Process:**
    1.  The user is asking for a specific metric: "system utilization". This is a direct request for data.
    2.  My critical rule states I must prioritize a `tool_name` for direct actions.
    3.  The `dba_systemVoice` prompt is for adopting a persona, not for fetching specific metrics. It is the incorrect choice.
    4.  The `dba_resusageSummary` tool in the `Performance` category is designed to get system usage summary metrics. This is the correct choice.
- **Correct Response:** `{"tool_name": "dba_resusageSummary", "arguments": {}}`

# Best Practices
- **Context is Key:** Always use information from previous turns to fill in arguments like `db_name` or `table_name`.
- **Error Recovery:** If a tool fails, analyze the error message and attempt to call the tool again with corrected parameters. Only ask the user for clarification if you cannot recover.
- **SQL Generation:** When using the `base_readQuery` tool, you MUST use fully qualified table names in your SQL (e.g., `SELECT ... FROM my_database.my_table`).
- **Time-Sensitive Queries:** For queries involving relative dates (e.g., 'today', 'this week'), you MUST use the `util_getCurrentDate` tool first to determine the current date before proceeding.
- **Out of Scope:** If the user's request is unrelated to the available capabilities, respond with a `FINAL_ANSWER:` that politely explains you cannot fulfill the request and restates your purpose.
- **CRITICAL: Avoid Repetitive Behavior.** You are a highly intelligent agent. Do not get stuck in a loop by repeating the same tool calls or by cycling through the same set of tools. Once a tool has returned a successful result with data that is relevant to the user's request, do not call that same tool again unless there is a new and compelling reason to do so. If you have called a series of tools and believe you have enough information, you must call a FINAL_ANSWER. Do not repeat tool calls just to be "through".


# Capabilities
--- Available Tools ---
--- Category: Data Quality ---
- `qlty_columnSummary` (tool): 
Get the column summary statistics for a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_distinctCategories` (tool): 
Get the destinct categories from column in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_missingValues` (tool): 
Get the column names that having missing values in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_negativeValues` (tool): 
Get the column names that having negative values in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_rowsWithMissingValues` (tool): 
Get the rows with missing values in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_standardDeviation` (tool): 
Get the standard deviation from column in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_univariateStatistics` (tool): 
Get the univariate statistics for a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

--- Category: Data Visualization ---
- `viz_createChart` (tool): Generates a data visualization based on provided data. You must specify the chart type and map the data fields to the appropriate visual roles.
  - Arguments:
    - `chart_type` (string, required): The type of chart to generate (e.g., 'bar', 'pie', 'line', 'scatter'). This MUST be one of the types listed in the 'Charting Guidelines'.
    - `data` (list[dict], required): The data to be visualized, passed directly from the output of another tool.
    - `title` (string, required): A descriptive title for the chart.
    - `mapping` (dict, required): A dictionary that maps data keys to chart axes or roles (e.g., {'x_axis': 'product_name', 'y_axis': 'sales_total'}). The required keys for this mapping depend on the selected chart_type.
--- Category: Database Information ---
- `cust_td_serverInfo` (tool): Get the Teradata software information: demonstrates how to use parameters for prepared statements.
  - Arguments:
    - `infokey` (string, optional): No description.
- `dba_databaseVersion` (tool):  Get Teradata database version information.
- `base_databaseList` (tool): Lists all databases in the Teradata System.
--- Category: Database Space ---
- `dba_databaseSpace` (tool): 
Get database space if database name is provided, otherwise get all databases space allocations.

Arguments:
  database_name - database name

Returns:
  ResponseType: formatted response with query results + metadata

- `get_cube_cust_cube_db_space_metrics` (tool): 
    Tool to query the cube 'table_skew_pct'.
    Get the Teradata database space metrics for tables and databases

    Expected inputs:
        dimensions (str): Comma-separated dimension names to group by. Allowed values:
    - DatabaseName: Name of the database
    - TableName: Name of the table

        measures (str): Comma-separated measure names to aggregate. Allowed values:
    - current_perm: Object perm space in bytes
    - peak_perm: Object peak perm space in bytes
    - table_skew_pct: Object skew percentage

        filters (str): Comma-separated filter expressions to apply to either dimensions or measures selected. The dimension or measure used must be in the dimension list to group by or measure list, use valid SQL expressions, for example:
DatabaseName = 'value'
TableName = 'value'
current_perm > 1000
peak_perm > 1000
table_skew_pct > 1000

    Returns:
        Query result as a formatted response.
    
  - Arguments:
    - `dimensions` (string, optional): No description.
    - `measures` (string, optional): No description.
    - `filters` (string, optional): No description.
- `dba_systemSpace` (tool): Get the Teradata total system database space usage.
--- Category: Performance ---
- `dba_resusageSummary` (tool): 
Get the Teradata system usage summary metrics by weekday and hour for each workload type and query complexity bucket.

Arguments:
  dimensions - list of dimensions to aggregate the resource usage summary. All dimensions are: ["LogDate", "hourOfDay", "dayOfWeek", "workloadType", "workloadComplexity", "UserName", "AppId", "StatementType"]
  user_name - user name
  date - Date to analyze, formatted as `YYYY-MM-DD`
  dayOfWeek - day of the week to analyze
  hourOfDay - hour of day to analyze


- `dba_flowControl` (tool): Get the Teradata flow control metrics for a specified date range.
  - Arguments:
    - `start_date` (string, optional): No description.
    - `end_date` (string, optional): No description.
- `dba_userDelay` (tool): Get the Teradata user delay metrics for a specified date range.
  - Arguments:
    - `start_date` (string, optional): No description.
    - `end_date` (string, optional): No description.
--- Category: Query Execution ---
- `base_readQuery` (tool): 
Execute a SQL query via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  sql    - SQL text, with optional bind-parameter placeholders

Returns:
  ResponseType: formatted response with query results + metadata

--- Category: Sales Analytics ---
- `sales_top_customers` (tool): Get the top 20 customers by lifetime value.
- `sales_customer_profile` (tool): Get customer profile and metrics.
  - Arguments:
    - `customer_key` (string, optional): No description.
- `get_cube_sales_cube` (tool): 
    Tool to query the cube 'order_count'.
    Get the key sales metrics: USD amount and number of orders.

    Expected inputs:
        dimensions (str): Comma-separated dimension names to group by. Allowed values:
    - customer_key: Key for the customer
    - sales_year: Year of the sale
    - sales_month: Month of the sale

        measures (str): Comma-separated measure names to aggregate. Allowed values:
    - gift_amount_usd: Total gift card amount used for the order in USD
    - total_amount_usd: Total order amount in USD
    - order_count: Total number of orders

        filters (str): Comma-separated filter expressions to apply to either dimensions or measures selected. The dimension or measure used must be in the dimension list to group by or measure list, use valid SQL expressions, for example:
customer_key = 'value'
sales_year = 'value'
sales_month = 'value'
gift_amount_usd > 1000
total_amount_usd > 1000
order_count > 1000

    Returns:
        Query result as a formatted response.
    
  - Arguments:
    - `dimensions` (string, optional): No description.
    - `measures` (string, optional): No description.
    - `filters` (string, optional): No description.
--- Category: Security ---
- `sec_rolePermissions` (tool): 
Get permissions for a role.

Arguments:
  role_name - role name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `sec_userDbPermissions` (tool): 
Get permissions for a user.

Arguments:
  user_name - user name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `sec_userRoles` (tool): 
Get roles assigned to a user.

Arguments:
  user_name - user name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

--- Category: Session Management ---
- `dba_sessionInfo` (tool): Get the Teradata session information for user.
  - Arguments:
    - `user_name` (string, optional): No description.
--- Category: Table Management ---
- `dba_tableSpace` (tool): 
Get table space used for a table if table name is provided or get table space for all tables in a database if a database name is provided."

Arguments:
  database_name - database name
  table_name - table name

Returns:
  ResponseType: formatted response with query results + metadata

- `dba_tableSqlList` (tool): 
Get a list of SQL run against a table in the last number of days.

Arguments:
  table_name - table name
  no_days - number of days

Returns:
  ResponseType: formatted response with query results + metadata

- `dba_tableUsageImpact` (tool): 
Measure the usage of a table and views by users, this is helpful to understand what user and tables are driving most resource usage at any point in time.

Arguments:
  database_name - database name to analyze
  user_name - user name to analyze


- `base_columnDescription` (tool): 
Shows detailed column information about a database table via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name
  obj_name - table or view name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableAffinity` (tool): 
Get tables commonly used together by database users, this is helpful to infer relationships between tables via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name
  object_name - table or view name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableDDL` (tool): 
Displays the DDL definition of a table via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name
  table_name - table name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tablePreview` (tool): 
This function returns data sample and inferred structure from a database table or view via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  table_name - table or view name
  database_name - Database name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableUsage` (tool): 
Measure the usage of a table and views by users in a given schema, this is helpful to infer what database objects are most actively used or drive most value via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableList` (tool): Lists all tables in a database.
  - Arguments:
    - `database_name` (string, optional): No description.
--- Category: Usage Tracking ---
- `dba_featureUsage` (tool): Get the user feature usage metrics for a specified date range.
  - Arguments:
    - `start_date` (string, optional): No description.
    - `end_date` (string, optional): No description.
--- Category: User Management ---
- `dba_userSqlList` (tool): 
Get a list of SQL run by a user in the last number of days if a user name is provided, otherwise get list of all SQL in the last number of days.

Arguments:
  user_name - user name
  no_days - number of days

Returns:
  ResponseType: formatted response with query results + metadata

- `cust_activeUsers` (tool): Fetch currently active database users
--- Category: Utilities ---
- `tmpl_nameOfTool` (tool): 
<description of what the tool is for>

Arguments:
  arguments - arguments to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `evs_similarity_search` (tool): 
Enterprise Vector Store similarity search

Arguments:
  question - the query string to search for
  top_k - number of top results to return

Returns:
  ResponseType: formatted response with query results + metadata

- `rag_executeWorkflow` (tool): 
Execute complete RAG workflow to answer user questions based on document context.


This function handles the entire RAG pipeline:
1. Configuration setup (using configurable values from rag_config.yml)
2. Store user query (with /rag prefix stripping)
3. Generate query embeddings (tokenization + embedding)
4. Perform semantic search against chunk embeddings
5. Return retrieved context chunks for answer generation

The function uses configuration values from rag_config.yml with fallback defaults.

Arguments:
  question - user question to process
  k - number of top-k results to return (optional, uses config default if not provided)

Returns:
  Returns the top-k most relevant chunks with metadata for context-grounded answer generation.

- `rag_executeWorkflow_ivsm` (tool): 
Execute complete RAG workflow to answer user questions based on document context.

This function handles the entire RAG pipeline using IVSM functions:
1. Configuration setup (using configurable values from rag_config.yml)
2. Store user query (with /rag prefix stripping)
3. Tokenize query using ivsm.tokenizer_encode
4. Create embedding view using ivsm.IVSM_score
5. Convert embeddings to vector columns using ivsm.vector_to_columns
6. Perform semantic search against chunk embeddings

The function uses configuration values from rag_config.yml with fallback defaults.

Arguments:
  question - user question to process
  k - number of top-k results to return (optional, uses config default if not provided

Returns:
  Returns the top-k most relevant chunks with metadata for context-grounded answer generation.

- `util_getCurrentDate` (tool): Returns the current system date in YYYY-MM-DD format. Use this as the first step for any user query involving relative dates like 'today', 'yesterday', or 'this week'.
- `util_calculateDateRange` (tool): Calculates a list of dates based on a start date and a natural language phrase (e.g., 'past 3 days', 'last week'). This is a necessary second step for multi-day queries.
  - Arguments:
    - `start_date` (string, required): The anchor date for the calculation, usually today's date from `util_getCurrentDate`. Must be in YYYY-MM-DD format.
    - `date_phrase` (string, required): The natural language phrase describing the desired range (e.g., 'past 3 days', 'last 2 weeks').
- `CoreLLMTask` (tool): Performs internal, LLM-driven tasks that are not direct calls to the Teradata database. This tool is used for text synthesis, summarization, and formatting based on a specific 'task_description' provided by the LLM itself.
  - Arguments:
    - `task_description` (string, required): A natural language description of the internal task to be executed (e.g., 'describe the table in a business context', 'format final output'). The LLM infers this from the workflow plan.
    - `source_data` (list[string], required): A list of keys (e.g., 'result_of_phase_1') identifying which data from the workflow history is relevant for this task. This is critical for providing the correct context.
--- Available Prompts ---
--- Category: Prompts ---
- `base_query` (prompt): Help users interact with  Teradata databases effectively.
  - Arguments:
    - `query` (str, required): The problem or question that needs to be solved using Teradata database tools.
- `base_tableBusinessDesc` (prompt): You are a Teradata DBA who is an expert in describing the business use of tables in a database.
  - Arguments:
    - `database_name` (str, required): Database for the table to describe.
    - `table_name` (str, required): Table to describe.


USER PROMPT:

You are an expert strategic planning assistant. Your task is to analyze a user's request or a complex workflow goal and decompose it into a high-level, phased meta-plan. This plan will serve as a state machine executor.

--- GOAL ---
what is the system utilization of the past 3 days?

--- CONTEXT ---
- User's Original Question (for reference): what is the system utilization of the past 3 days?

--- INSTRUCTIONS ---
1.  **Analyze the Goal**: Carefully read the "GOAL" to understand the user's full intent.
2.  **Decompose into Phases**: Break down the overall goal into a sequence of logical phases. Each phase should represent a major step.
3.  **Define Each Phase**: For each phase, create a JSON object with the following keys:
    -   `"phase"`: An integer representing the step number (e.g., 1, 2, 3).
    -   `"goal"`: A clear, concise, and actionable description of what must be accomplished in this phase. This goal will guide a separate, tactical LLM.
    -   `"relevant_tools"`: A list of tool names that are permitted to be used during this phase. You MUST select the most appropriate and specific tools from the full "Capabilities" list provided in the main system prompt to achieve the phase's goal.
    -   (Optional) `"type": "loop"`: If a phase requires iterating over a list of items, you MUST include this key.
    -   (Optional) `"loop_over"`: If `"type"` is `"loop"`, specify the data source for the iteration (e.g., `"result_of_phase_1"`).
4.  **Embed Parameters**: When defining the `"goal"` for a phase, you MUST scan the main "GOAL" for any hardcoded arguments or parameters (e.g., table names, database names) relevant to that phase's task. You MUST embed these found parameters directly into the `"goal"` string to make it self-contained and explicit.
5.  **Final Synthesis and Formatting Phase**: If the main "GOAL" describes a multi-step process with a final reporting requirement, your plan **MUST** conclude with a single, final phase that handles both the synthesis of the final report AND its formatting. The `relevant_tools` for this final phase **MUST** be `["CoreLLMTask"]`.
6.  **CRITICAL RULE (Simplicity)**: If the "GOAL" is a simple, direct request that can be answered with a single tool call (e.g., "list all databases", "what is the system utilization?"), your plan **MUST** consist of only a single phase that calls the one most appropriate tool. Do not add unnecessary synthesis phases for simple data retrieval.
7.  **CRITICAL RULE (Execution Focus)**: Every phase you define **MUST** correspond to a concrete, tool-based action. You **MUST NOT** create phases for simple verification, confirmation, or acknowledgement of known information. Your plan must focus only on the execution steps required to gather new information or process existing data.
8.  **CRITICAL RULE (Capability Types)**: You are generating a plan of executable **tools**. The `relevant_tools` list **MUST ONLY** contain names of capabilities that are explicitly marked as `(tool)` in the system's "Capabilities" list. You **MUST NOT** include the name of any capability marked as `(prompt)`.
9.  **CRITICAL RULE (Efficiency)**: If a phase's `"goal"` already contains all the instructions for the final synthesis and formatting of the report (as specified in the main "GOAL"), you **MUST** make this the last phase of the plan. Do not add a separate, redundant formatting-only phase after it.

--- EXAMPLE (Complex Goal) ---
If the main goal requires getting DDL and then describing/formatting, your output should be a two-phase plan like this:
```json
[
  {
    "phase": 1,
    "goal": "Get the DDL for the table 'customers' in database 'sales' using the `base_tableDDL` tool.",
    "relevant_tools": ["base_tableDDL"]
  },
  {
    "phase": 2,
    "goal": "Synthesize a final report by describing the 'customers' table in a business context and format the output as markdown according to the Final output guidelines, using `***` for keys.",
    "relevant_tools": ["CoreLLMTask"]
  }
]
```

--- EXAMPLE (Simple Goal) ---
If the main goal is "what is the system utilization?", your output should be a single-phase plan like this:
```json
[
  {
    "phase": 1,
    "goal": "Get the system utilization using the `dba_resusageSummary` tool.",
    "relevant_tools": ["dba_resusageSummary"]
  }
]
```

--- EXAMPLE (Date Range Goal) ---
If the main goal is "what is the system utilization for the past 3 days?", your output must be a three-phase plan like this:
```json
[
  {
    "phase": 1,
    "goal": "Get the current date using the `util_getCurrentDate` tool to establish a reference point.",
    "relevant_tools": ["util_getCurrentDate"]
  },
  {
    "phase": 2,
    "goal": "Calculate the list of dates for 'the past 3 days' using the `util_calculateDateRange` tool.",
    "relevant_tools": ["util_calculateDateRange"]
  },
  {
    "phase": 3,
    "goal": "For each date calculated in the previous step, get the system utilization using the `dba_resusageSummary` tool.",
    "relevant_tools": ["dba_resusageSummary"],
    "type": "loop",
    "loop_over": "result_of_phase_2"
  }
]
```

Your response MUST be a single, valid JSON list of phase objects. Do NOT add any extra text, conversation, or markdown.

[model]: ```json
[
  {
    "phase": 1,
    "goal": "Get the current date using the `util_getCurrentDate` tool to establish a reference point.",
    "relevant_tools": ["util_getCurrentDate"]
  },
  {
    "phase": 2,
    "goal": "Calculate the list of dates for 'past 3 days' using the `util_calculateDateRange` tool.",
    "relevant_tools": ["util_calculateDateRange"]
  },
  {
    "phase": 3,
    "goal": "For each date calculated in the previous step, get the system utilization using the `dba_resusageSummary` tool.",
    "relevant_tools": ["dba_resusageSummary"],
    "type": "loop",
    "loop_over": "result_of_phase_2"
  }
]
```
[user]: SYSTEM PROMPT:

You are a tactical assistant executing a single phase of a larger plan. Your task is to decide the single best next action to take to achieve the current phase's goal, strictly adhering to the provided tool constraints.

--- OVERALL WORKFLOW GOAL ---
what is the system utilization of the past 3 days?

--- CURRENT PHASE GOAL ---
Get the current date using the `util_getCurrentDate` tool to establish a reference point.

--- CONSTRAINTS ---
- Permitted Tools for this Phase (You MUST use the exact argument names provided):

- Tool: `util_getCurrentDate`
  - Description: Returns the current system date in YYYY-MM-DD format. Use this as the first step for any user query involving relative dates like 'today', 'yesterday', or 'this week'.

- Previous Attempt (if any): None

--- WORKFLOW STATE & HISTORY ---
- Actions Taken So Far: []
- Data Collected So Far: {}

--- INSTRUCTIONS ---
1.  **Analyze the State**: Review the "CURRENT PHASE GOAL" and the "WORKFLOW STATE & HISTORY" to understand what has been done and what is needed next.
2.  **CRITICAL RULE (Tool Selection & Arguments)**: You **MUST** select your next action from the list of "Permitted Tools for this Phase". You are not allowed to use any other tool. Furthermore, you **MUST** use the exact argument names as they are defined in the tool details above. You **MUST NOT** invent, hallucinate, or use any arguments that are not explicitly listed in the definitions.
3.  **Self-Correction**: If a "Previous Attempt" is noted in the "CONSTRAINTS" section, it means your last choice was invalid. You **MUST** analyze the error and choose a different, valid tool from the permitted list. Do not repeat the invalid choice.
4.  **CoreLLMTask Usage**:
    -   For any task that involves synthesis, analysis, description, or summarization, you **MUST** use the `CoreLLMTask` tool, but only if it is in the permitted tools list.
    -   When calling `CoreLLMTask`, you **MUST** provide the `task_description` argument.
    -   Crucially, you **MUST** also determine which previous phase results are necessary for the task. You **MUST** provide these as a list of strings in the `source_data` argument.
    -   **CONTEXT PRESERVATION RULE**: If the current phase involves creating a final summary or report for the user, you **MUST** ensure you have all the necessary context. Your `source_data` list **MUST** include the results from **ALL** previous data-gathering phases (e.g., `["result_of_phase_1", "result_of_phase_2"]`) to prevent information loss.
5.  **Handle Loops**: If you are in a looping phase (indicated by the presence of a "LOOP CONTEXT" section), you **MUST** focus your action on the single item provided in `current_loop_item`. You **MUST** use the information within that item to formulate the arguments for your tool call.
6.  **Format Response**: Your response MUST be a single JSON object for a tool call.

Your response MUST be a single, valid JSON object for a tool call. Do NOT add any extra text or conversation.


USER PROMPT:
Determine the next action based on the instructions and state provided in the system prompt.
[model]: ```json
{"tool_name": "util_getCurrentDate", "arguments": {}}
```
[user]: SYSTEM PROMPT:

You are a tactical assistant executing a single phase of a larger plan. Your task is to decide the single best next action to take to achieve the current phase's goal, strictly adhering to the provided tool constraints.

--- OVERALL WORKFLOW GOAL ---
what is the system utilization of the past 3 days?

--- CURRENT PHASE GOAL ---
Calculate the list of dates for 'past 3 days' using the `util_calculateDateRange` tool.

--- CONSTRAINTS ---
- Permitted Tools for this Phase (You MUST use the exact argument names provided):

- Tool: `util_calculateDateRange`
  - Description: Calculates a list of dates based on a start date and a natural language phrase (e.g., 'past 3 days', 'last week'). This is a necessary second step for multi-day queries.
  - Arguments:
    - `start_date` (string, required): The anchor date for the calculation, usually today's date from `util_getCurrentDate`. Must be in YYYY-MM-DD format.
    - `date_phrase` (string, required): The natural language phrase describing the desired range (e.g., 'past 3 days', 'last 2 weeks').

- Previous Attempt (if any): None

--- WORKFLOW STATE & HISTORY ---
- Actions Taken So Far: [
  {
    "action": {
      "tool_name": "util_getCurrentDate",
      "arguments": {}
    },
    "result": {
      "status": "success",
      "metadata": {
        "tool_name": "util_getCurrentDate"
      },
      "results": [
        {
          "current_date": "2025-08-21"
        }
      ]
    }
  }
]
- Data Collected So Far: {
  "result_of_phase_1": [
    {
      "status": "success",
      "metadata": {
        "tool_name": "util_getCurrentDate"
      },
      "results": [
        {
          "current_date": "2025-08-21"
        }
      ]
    }
  ]
}

--- INSTRUCTIONS ---
1.  **Analyze the State**: Review the "CURRENT PHASE GOAL" and the "WORKFLOW STATE & HISTORY" to understand what has been done and what is needed next.
2.  **CRITICAL RULE (Tool Selection & Arguments)**: You **MUST** select your next action from the list of "Permitted Tools for this Phase". You are not allowed to use any other tool. Furthermore, you **MUST** use the exact argument names as they are defined in the tool details above. You **MUST NOT** invent, hallucinate, or use any arguments that are not explicitly listed in the definitions.
3.  **Self-Correction**: If a "Previous Attempt" is noted in the "CONSTRAINTS" section, it means your last choice was invalid. You **MUST** analyze the error and choose a different, valid tool from the permitted list. Do not repeat the invalid choice.
4.  **CoreLLMTask Usage**:
    -   For any task that involves synthesis, analysis, description, or summarization, you **MUST** use the `CoreLLMTask` tool, but only if it is in the permitted tools list.
    -   When calling `CoreLLMTask`, you **MUST** provide the `task_description` argument.
    -   Crucially, you **MUST** also determine which previous phase results are necessary for the task. You **MUST** provide these as a list of strings in the `source_data` argument.
    -   **CONTEXT PRESERVATION RULE**: If the current phase involves creating a final summary or report for the user, you **MUST** ensure you have all the necessary context. Your `source_data` list **MUST** include the results from **ALL** previous data-gathering phases (e.g., `["result_of_phase_1", "result_of_phase_2"]`) to prevent information loss.
5.  **Handle Loops**: If you are in a looping phase (indicated by the presence of a "LOOP CONTEXT" section), you **MUST** focus your action on the single item provided in `current_loop_item`. You **MUST** use the information within that item to formulate the arguments for your tool call.
6.  **Format Response**: Your response MUST be a single JSON object for a tool call.

Your response MUST be a single, valid JSON object for a tool call. Do NOT add any extra text or conversation.


USER PROMPT:
Determine the next action based on the instructions and state provided in the system prompt.
[model]: ```json
{"tool_name": "util_calculateDateRange", "arguments": {"start_date": "2025-08-21", "date_phrase": "past 3 days"}}
```
[user]: SYSTEM PROMPT:

# Core Directives
You are a specialized assistant for a Teradata database system. Your primary goal is to fulfill user requests by selecting the best capability (a tool or a prompt) from the categorized lists provided and supplying all necessary arguments.

# Response Format
Your response MUST be a single JSON object for a tool/prompt call OR a single plain text string for a final answer.

1.  **Tool/Prompt Calls (JSON format):**
    -   If the capability is a prompt, you MUST use the key `"prompt_name"`.
    -   If the capability is a tool, you MUST use the key `"tool_name"`.
    -   Provide all required arguments. Infer values from the conversation history if necessary.
    -   Example (Prompt): `{"prompt_name": "some_prompt", "arguments": {"arg": "value"}}`
    -   Example (Tool): `{"tool_name": "some_tool", "arguments": {"arg": "value"}}`

2.  **Final Answer (Plain Text format):**
    -   When you have sufficient information to fully answer the user's request, you MUST stop using tools.
    -   Your response MUST begin with the exact prefix `FINAL_ANSWER:`, followed by a natural language summary.
    -   Example: `FINAL_ANSWER: I found 48 databases on the system. The details are displayed below.`

# Decision Process
To select the correct capability, you MUST follow this two-step process, governed by one critical rule:

**CRITICAL RULE: Prioritize Specificity and Arguments.** Your primary filter for selecting a capability is its specificity. You MUST select the most granular capability that uses the most entities from the user's request (e.g., prefer a tool that uses a `table_name` over one that only uses a `database_name` if a table is mentioned). For direct actions and single analyses, you MUST select a `tool_name`; only select a `prompt_name` for broad, multi-step tasks explicitly described by the prompt.

1.  **Identify the Category:** First, analyze the user's request to determine which Tool or Prompt Category is the most relevant to their intent. The available categories are listed in the "Capabilities" section below.
2.  **Select the Capability:** Second, from within that single most relevant category, select the best tool or prompt to fulfill the request, adhering to the Critical Rule above.

# Few-Shot Examples
Here are examples of the correct thinking process:

**Example 1:**
- **User Query:** "what is the quality of table 'online' in database 'DEMO_Customer360_db'?"
- **Thought Process:**
    1.  The user's query is about a **table**.
    2.  My critical rule is to prioritize specificity. I must choose a table-level tool.
    3.  The `qlty_databaseQuality` prompt is for databases, not specific tables, so it's incorrect.
    4.  The `qlty_columnSummary` tool takes a `table_name` and is the most specific, correct choice.
- **Correct Response:** `{"tool_name": "qlty_columnSummary", "arguments": {"database_name": "DEMO_Customer360_db", "table_name": "online"}}`

**Example 2:**
- **User Query:** "describe the business purpose of the 'DEMO_Customer360_db' database"
- **Thought Process:**
    1.  The user's query is about a **database**. It's a broad request ("describe").
    2.  A prompt is better for broad tasks.
    3.  The `base_databaseBusinessDesc` prompt takes a `database_name` and is the correct choice.
- **Correct Response:** `{"prompt_name": "base_databaseBusinessDesc", "arguments": {"database_name": "DEMO_Customer360_db"}}`

**Example 3:**
- **User Query:** "what is the system utilization?"
- **Thought Process:**
    1.  The user is asking for a specific metric: "system utilization". This is a direct request for data.
    2.  My critical rule states I must prioritize a `tool_name` for direct actions.
    3.  The `dba_systemVoice` prompt is for adopting a persona, not for fetching specific metrics. It is the incorrect choice.
    4.  The `dba_resusageSummary` tool in the `Performance` category is designed to get system usage summary metrics. This is the correct choice.
- **Correct Response:** `{"tool_name": "dba_resusageSummary", "arguments": {}}`

# Best Practices
- **Context is Key:** Always use information from previous turns to fill in arguments like `db_name` or `table_name`.
- **Error Recovery:** If a tool fails, analyze the error message and attempt to call the tool again with corrected parameters. Only ask the user for clarification if you cannot recover.
- **SQL Generation:** When using the `base_readQuery` tool, you MUST use fully qualified table names in your SQL (e.g., `SELECT ... FROM my_database.my_table`).
- **Time-Sensitive Queries:** For queries involving relative dates (e.g., 'today', 'this week'), you MUST use the `util_getCurrentDate` tool first to determine the current date before proceeding.
- **Out of Scope:** If the user's request is unrelated to the available capabilities, respond with a `FINAL_ANSWER:` that politely explains you cannot fulfill the request and restates your purpose.
- **CRITICAL: Avoid Repetitive Behavior.** You are a highly intelligent agent. Do not get stuck in a loop by repeating the same tool calls or by cycling through the same set of tools. Once a tool has returned a successful result with data that is relevant to the user's request, do not call that same tool again unless there is a new and compelling reason to do so. If you have called a series of tools and believe you have enough information, you must call a FINAL_ANSWER. Do not repeat tool calls just to be "through".


# Capabilities
--- Available Tools ---
--- Category: Data Quality ---
- `qlty_columnSummary` (tool): 
Get the column summary statistics for a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_distinctCategories` (tool): 
Get the destinct categories from column in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_missingValues` (tool): 
Get the column names that having missing values in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_negativeValues` (tool): 
Get the column names that having negative values in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_rowsWithMissingValues` (tool): 
Get the rows with missing values in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_standardDeviation` (tool): 
Get the standard deviation from column in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_univariateStatistics` (tool): 
Get the univariate statistics for a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

--- Category: Data Visualization ---
- `viz_createChart` (tool): Generates a data visualization based on provided data. You must specify the chart type and map the data fields to the appropriate visual roles.
  - Arguments:
    - `chart_type` (string, required): The type of chart to generate (e.g., 'bar', 'pie', 'line', 'scatter'). This MUST be one of the types listed in the 'Charting Guidelines'.
    - `data` (list[dict], required): The data to be visualized, passed directly from the output of another tool.
    - `title` (string, required): A descriptive title for the chart.
    - `mapping` (dict, required): A dictionary that maps data keys to chart axes or roles (e.g., {'x_axis': 'product_name', 'y_axis': 'sales_total'}). The required keys for this mapping depend on the selected chart_type.
--- Category: Database Information ---
- `cust_td_serverInfo` (tool): Get the Teradata software information: demonstrates how to use parameters for prepared statements.
  - Arguments:
    - `infokey` (string, optional): No description.
- `dba_databaseVersion` (tool):  Get Teradata database version information.
- `base_databaseList` (tool): Lists all databases in the Teradata System.
--- Category: Database Space ---
- `dba_databaseSpace` (tool): 
Get database space if database name is provided, otherwise get all databases space allocations.

Arguments:
  database_name - database name

Returns:
  ResponseType: formatted response with query results + metadata

- `get_cube_cust_cube_db_space_metrics` (tool): 
    Tool to query the cube 'table_skew_pct'.
    Get the Teradata database space metrics for tables and databases

    Expected inputs:
        dimensions (str): Comma-separated dimension names to group by. Allowed values:
    - DatabaseName: Name of the database
    - TableName: Name of the table

        measures (str): Comma-separated measure names to aggregate. Allowed values:
    - current_perm: Object perm space in bytes
    - peak_perm: Object peak perm space in bytes
    - table_skew_pct: Object skew percentage

        filters (str): Comma-separated filter expressions to apply to either dimensions or measures selected. The dimension or measure used must be in the dimension list to group by or measure list, use valid SQL expressions, for example:
DatabaseName = 'value'
TableName = 'value'
current_perm > 1000
peak_perm > 1000
table_skew_pct > 1000

    Returns:
        Query result as a formatted response.
    
  - Arguments:
    - `dimensions` (string, optional): No description.
    - `measures` (string, optional): No description.
    - `filters` (string, optional): No description.
- `dba_systemSpace` (tool): Get the Teradata total system database space usage.
--- Category: Performance ---
- `dba_resusageSummary` (tool): 
Get the Teradata system usage summary metrics by weekday and hour for each workload type and query complexity bucket.

Arguments:
  dimensions - list of dimensions to aggregate the resource usage summary. All dimensions are: ["LogDate", "hourOfDay", "dayOfWeek", "workloadType", "workloadComplexity", "UserName", "AppId", "StatementType"]
  user_name - user name
  date - Date to analyze, formatted as `YYYY-MM-DD`
  dayOfWeek - day of the week to analyze
  hourOfDay - hour of day to analyze


- `dba_flowControl` (tool): Get the Teradata flow control metrics for a specified date range.
  - Arguments:
    - `start_date` (string, optional): No description.
    - `end_date` (string, optional): No description.
- `dba_userDelay` (tool): Get the Teradata user delay metrics for a specified date range.
  - Arguments:
    - `start_date` (string, optional): No description.
    - `end_date` (string, optional): No description.
--- Category: Query Execution ---
- `base_readQuery` (tool): 
Execute a SQL query via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  sql    - SQL text, with optional bind-parameter placeholders

Returns:
  ResponseType: formatted response with query results + metadata

--- Category: Sales Analytics ---
- `sales_top_customers` (tool): Get the top 20 customers by lifetime value.
- `sales_customer_profile` (tool): Get customer profile and metrics.
  - Arguments:
    - `customer_key` (string, optional): No description.
- `get_cube_sales_cube` (tool): 
    Tool to query the cube 'order_count'.
    Get the key sales metrics: USD amount and number of orders.

    Expected inputs:
        dimensions (str): Comma-separated dimension names to group by. Allowed values:
    - customer_key: Key for the customer
    - sales_year: Year of the sale
    - sales_month: Month of the sale

        measures (str): Comma-separated measure names to aggregate. Allowed values:
    - gift_amount_usd: Total gift card amount used for the order in USD
    - total_amount_usd: Total order amount in USD
    - order_count: Total number of orders

        filters (str): Comma-separated filter expressions to apply to either dimensions or measures selected. The dimension or measure used must be in the dimension list to group by or measure list, use valid SQL expressions, for example:
customer_key = 'value'
sales_year = 'value'
sales_month = 'value'
gift_amount_usd > 1000
total_amount_usd > 1000
order_count > 1000

    Returns:
        Query result as a formatted response.
    
  - Arguments:
    - `dimensions` (string, optional): No description.
    - `measures` (string, optional): No description.
    - `filters` (string, optional): No description.
--- Category: Security ---
- `sec_rolePermissions` (tool): 
Get permissions for a role.

Arguments:
  role_name - role name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `sec_userDbPermissions` (tool): 
Get permissions for a user.

Arguments:
  user_name - user name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `sec_userRoles` (tool): 
Get roles assigned to a user.

Arguments:
  user_name - user name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

--- Category: Session Management ---
- `dba_sessionInfo` (tool): Get the Teradata session information for user.
  - Arguments:
    - `user_name` (string, optional): No description.
--- Category: Table Management ---
- `dba_tableSpace` (tool): 
Get table space used for a table if table name is provided or get table space for all tables in a database if a database name is provided."

Arguments:
  database_name - database name
  table_name - table name

Returns:
  ResponseType: formatted response with query results + metadata

- `dba_tableSqlList` (tool): 
Get a list of SQL run against a table in the last number of days.

Arguments:
  table_name - table name
  no_days - number of days

Returns:
  ResponseType: formatted response with query results + metadata

- `dba_tableUsageImpact` (tool): 
Measure the usage of a table and views by users, this is helpful to understand what user and tables are driving most resource usage at any point in time.

Arguments:
  database_name - database name to analyze
  user_name - user name to analyze


- `base_columnDescription` (tool): 
Shows detailed column information about a database table via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name
  obj_name - table or view name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableAffinity` (tool): 
Get tables commonly used together by database users, this is helpful to infer relationships between tables via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name
  object_name - table or view name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableDDL` (tool): 
Displays the DDL definition of a table via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name
  table_name - table name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tablePreview` (tool): 
This function returns data sample and inferred structure from a database table or view via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  table_name - table or view name
  database_name - Database name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableUsage` (tool): 
Measure the usage of a table and views by users in a given schema, this is helpful to infer what database objects are most actively used or drive most value via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableList` (tool): Lists all tables in a database.
  - Arguments:
    - `database_name` (string, optional): No description.
--- Category: Usage Tracking ---
- `dba_featureUsage` (tool): Get the user feature usage metrics for a specified date range.
  - Arguments:
    - `start_date` (string, optional): No description.
    - `end_date` (string, optional): No description.
--- Category: User Management ---
- `dba_userSqlList` (tool): 
Get a list of SQL run by a user in the last number of days if a user name is provided, otherwise get list of all SQL in the last number of days.

Arguments:
  user_name - user name
  no_days - number of days

Returns:
  ResponseType: formatted response with query results + metadata

- `cust_activeUsers` (tool): Fetch currently active database users
--- Category: Utilities ---
- `tmpl_nameOfTool` (tool): 
<description of what the tool is for>

Arguments:
  arguments - arguments to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `evs_similarity_search` (tool): 
Enterprise Vector Store similarity search

Arguments:
  question - the query string to search for
  top_k - number of top results to return

Returns:
  ResponseType: formatted response with query results + metadata

- `rag_executeWorkflow` (tool): 
Execute complete RAG workflow to answer user questions based on document context.


This function handles the entire RAG pipeline:
1. Configuration setup (using configurable values from rag_config.yml)
2. Store user query (with /rag prefix stripping)
3. Generate query embeddings (tokenization + embedding)
4. Perform semantic search against chunk embeddings
5. Return retrieved context chunks for answer generation

The function uses configuration values from rag_config.yml with fallback defaults.

Arguments:
  question - user question to process
  k - number of top-k results to return (optional, uses config default if not provided)

Returns:
  Returns the top-k most relevant chunks with metadata for context-grounded answer generation.

- `rag_executeWorkflow_ivsm` (tool): 
Execute complete RAG workflow to answer user questions based on document context.

This function handles the entire RAG pipeline using IVSM functions:
1. Configuration setup (using configurable values from rag_config.yml)
2. Store user query (with /rag prefix stripping)
3. Tokenize query using ivsm.tokenizer_encode
4. Create embedding view using ivsm.IVSM_score
5. Convert embeddings to vector columns using ivsm.vector_to_columns
6. Perform semantic search against chunk embeddings

The function uses configuration values from rag_config.yml with fallback defaults.

Arguments:
  question - user question to process
  k - number of top-k results to return (optional, uses config default if not provided

Returns:
  Returns the top-k most relevant chunks with metadata for context-grounded answer generation.

- `util_getCurrentDate` (tool): Returns the current system date in YYYY-MM-DD format. Use this as the first step for any user query involving relative dates like 'today', 'yesterday', or 'this week'.
- `util_calculateDateRange` (tool): Calculates a list of dates based on a start date and a natural language phrase (e.g., 'past 3 days', 'last week'). This is a necessary second step for multi-day queries.
  - Arguments:
    - `start_date` (string, required): The anchor date for the calculation, usually today's date from `util_getCurrentDate`. Must be in YYYY-MM-DD format.
    - `date_phrase` (string, required): The natural language phrase describing the desired range (e.g., 'past 3 days', 'last 2 weeks').
- `CoreLLMTask` (tool): Performs internal, LLM-driven tasks that are not direct calls to the Teradata database. This tool is used for text synthesis, summarization, and formatting based on a specific 'task_description' provided by the LLM itself.
  - Arguments:
    - `task_description` (string, required): A natural language description of the internal task to be executed (e.g., 'describe the table in a business context', 'format final output'). The LLM infers this from the workflow plan.
    - `source_data` (list[string], required): A list of keys (e.g., 'result_of_phase_1') identifying which data from the workflow history is relevant for this task. This is critical for providing the correct context.
--- Available Prompts ---
--- Category: Prompts ---
- `base_query` (prompt): Help users interact with  Teradata databases effectively.
  - Arguments:
    - `query` (str, required): The problem or question that needs to be solved using Teradata database tools.
- `base_tableBusinessDesc` (prompt): You are a Teradata DBA who is an expert in describing the business use of tables in a database.
  - Arguments:
    - `database_name` (str, required): Database for the table to describe.
    - `table_name` (str, required): Table to describe.


USER PROMPT:
You are an expert data analyst. Synthesize all collected data into a clear, concise, and insightful final answer.

--- USER'S QUESTION ---
'what is the system utilization of the past 3 days?'

--- DATA COLLECTED ---
```json
[
  {
    "status": "success",
    "metadata": {
      "tool_name": "util_getCurrentDate"
    },
    "results": [
      {
        "current_date": "2025-08-21"
      }
    ]
  },
  {
    "status": "success",
    "metadata": {
      "tool_name": "util_calculateDateRange"
    },
    "results": [
      {
        "date": "2025-08-18"
      },
      {
        "date": "2025-08-19"
      },
      {
        "date": "2025-08-20"
      }
    ]
  },
  {
    "status": "success",
    "metadata": {
      "tool_name": "dba_resusageSummary",
      "total_rows": 1,
      "comment": "Total system resource usage summary."
    },
    "results": [
      {
        "Request Count": "0",
        "Total AMPCPUTime": "None",
        "Total IOCount": "None",
        "Total ReqIOKB": "None",
        "Total ReqPhysIO": "None",
        "Total ReqPhysIOKB": "None",
        "Total ReqIO GB": "None",
        "Total ReqPhysIOGB": "None",
        "Total Server Byte Count": "None"
      }
    ]
  },
  {
    "status": "success",
    "metadata": {
      "tool_name": "dba_resusageSummary",
      "total_rows": 1,
      "comment": "Total system resource usage summary."
    },
    "results": [
      {
        "Request Count": "283",
        "Total AMPCPUTime": "1.1800000000000002",
        "Total IOCount": "15931.0",
        "Total ReqIOKB": "741228.0",
        "Total ReqPhysIO": "44.0",
        "Total ReqPhysIOKB": "904.0",
        "Total ReqIO GB": "0.7068901062011719",
        "Total ReqPhysIOGB": "0.00086212158203125",
        "Total Server Byte Count": "0"
      }
    ]
  },
  {
    "status": "success",
    "metadata": {
      "tool_name": "dba_resusageSummary",
      "total_rows": 1,
      "comment": "Total system resource usage summary."
    },
    "results": [
      {
        "Request Count": "121",
        "Total AMPCPUTime": "0.316",
        "Total IOCount": "3929.0",
        "Total ReqIOKB": "163096.0",
        "Total ReqPhysIO": "8.0",
        "Total ReqPhysIOKB": "184.0",
        "Total ReqIO GB": "0.15554046630859375",
        "Total ReqPhysIOGB": "0.00017547607421875",
        "Total Server Byte Count": "0"
      }
    ]
  }
]
```

--- INSTRUCTIONS ---
1.  Provide a holistic analysis and actionable insights.
2.  Begin with a high-level summary, then use bullet points for key observations.
3.  Your entire response **MUST** begin with `FINAL_ANSWER:`.

[model]: FINAL_ANSWER: The system utilization for the past 3 days (2025-08-18 to 2025-08-20) shows varying levels of activity.

*   **2025-08-18:** No resource usage data was found for this date.
*   **2025-08-19:** The system processed 283 requests, consuming 1.18 AMP CPU seconds and performing 15931 I/O operations, with a total of 741228 KB of I/O.
*   **2025-08-20:** The system processed 121 requests, consuming 0.316 AMP CPU seconds and performing 3929 I/O operations, with a total of 163096 KB of I/O.

[user]: SYSTEM PROMPT:

# Core Directives
You are a specialized assistant for a Teradata database system. Your primary goal is to fulfill user requests by selecting the best capability (a tool or a prompt) from the categorized lists provided and supplying all necessary arguments.

# Response Format
Your response MUST be a single JSON object for a tool/prompt call OR a single plain text string for a final answer.

1.  **Tool/Prompt Calls (JSON format):**
    -   If the capability is a prompt, you MUST use the key `"prompt_name"`.
    -   If the capability is a tool, you MUST use the key `"tool_name"`.
    -   Provide all required arguments. Infer values from the conversation history if necessary.
    -   Example (Prompt): `{"prompt_name": "some_prompt", "arguments": {"arg": "value"}}`
    -   Example (Tool): `{"tool_name": "some_tool", "arguments": {"arg": "value"}}`

2.  **Final Answer (Plain Text format):**
    -   When you have sufficient information to fully answer the user's request, you MUST stop using tools.
    -   Your response MUST begin with the exact prefix `FINAL_ANSWER:`, followed by a natural language summary.
    -   Example: `FINAL_ANSWER: I found 48 databases on the system. The details are displayed below.`

# Decision Process
To select the correct capability, you MUST follow this two-step process, governed by one critical rule:

**CRITICAL RULE: Prioritize Specificity and Arguments.** Your primary filter for selecting a capability is its specificity. You MUST select the most granular capability that uses the most entities from the user's request (e.g., prefer a tool that uses a `table_name` over one that only uses a `database_name` if a table is mentioned). For direct actions and single analyses, you MUST select a `tool_name`; only select a `prompt_name` for broad, multi-step tasks explicitly described by the prompt.

1.  **Identify the Category:** First, analyze the user's request to determine which Tool or Prompt Category is the most relevant to their intent. The available categories are listed in the "Capabilities" section below.
2.  **Select the Capability:** Second, from within that single most relevant category, select the best tool or prompt to fulfill the request, adhering to the Critical Rule above.

# Few-Shot Examples
Here are examples of the correct thinking process:

**Example 1:**
- **User Query:** "what is the quality of table 'online' in database 'DEMO_Customer360_db'?"
- **Thought Process:**
    1.  The user's query is about a **table**.
    2.  My critical rule is to prioritize specificity. I must choose a table-level tool.
    3.  The `qlty_databaseQuality` prompt is for databases, not specific tables, so it's incorrect.
    4.  The `qlty_columnSummary` tool takes a `table_name` and is the most specific, correct choice.
- **Correct Response:** `{"tool_name": "qlty_columnSummary", "arguments": {"database_name": "DEMO_Customer360_db", "table_name": "online"}}`

**Example 2:**
- **User Query:** "describe the business purpose of the 'DEMO_Customer360_db' database"
- **Thought Process:**
    1.  The user's query is about a **database**. It's a broad request ("describe").
    2.  A prompt is better for broad tasks.
    3.  The `base_databaseBusinessDesc` prompt takes a `database_name` and is the correct choice.
- **Correct Response:** `{"prompt_name": "base_databaseBusinessDesc", "arguments": {"database_name": "DEMO_Customer360_db"}}`

**Example 3:**
- **User Query:** "what is the system utilization?"
- **Thought Process:**
    1.  The user is asking for a specific metric: "system utilization". This is a direct request for data.
    2.  My critical rule states I must prioritize a `tool_name` for direct actions.
    3.  The `dba_systemVoice` prompt is for adopting a persona, not for fetching specific metrics. It is the incorrect choice.
    4.  The `dba_resusageSummary` tool in the `Performance` category is designed to get system usage summary metrics. This is the correct choice.
- **Correct Response:** `{"tool_name": "dba_resusageSummary", "arguments": {}}`

# Best Practices
- **Context is Key:** Always use information from previous turns to fill in arguments like `db_name` or `table_name`.
- **Error Recovery:** If a tool fails, analyze the error message and attempt to call the tool again with corrected parameters. Only ask the user for clarification if you cannot recover.
- **SQL Generation:** When using the `base_readQuery` tool, you MUST use fully qualified table names in your SQL (e.g., `SELECT ... FROM my_database.my_table`).
- **Time-Sensitive Queries:** For queries involving relative dates (e.g., 'today', 'this week'), you MUST use the `util_getCurrentDate` tool first to determine the current date before proceeding.
- **Out of Scope:** If the user's request is unrelated to the available capabilities, respond with a `FINAL_ANSWER:` that politely explains you cannot fulfill the request and restates your purpose.
- **CRITICAL: Avoid Repetitive Behavior.** You are a highly intelligent agent. Do not get stuck in a loop by repeating the same tool calls or by cycling through the same set of tools. Once a tool has returned a successful result with data that is relevant to the user's request, do not call that same tool again unless there is a new and compelling reason to do so. If you have called a series of tools and believe you have enough information, you must call a FINAL_ANSWER. Do not repeat tool calls just to be "through".


# Capabilities
--- Available Tools ---
--- Category: Data Quality ---
- `qlty_columnSummary` (tool): 
Get the column summary statistics for a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_distinctCategories` (tool): 
Get the destinct categories from column in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_missingValues` (tool): 
Get the column names that having missing values in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_negativeValues` (tool): 
Get the column names that having negative values in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_rowsWithMissingValues` (tool): 
Get the rows with missing values in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_standardDeviation` (tool): 
Get the standard deviation from column in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_univariateStatistics` (tool): 
Get the univariate statistics for a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

--- Category: Data Visualization ---
- `viz_createChart` (tool): Generates a data visualization based on provided data. You must specify the chart type and map the data fields to the appropriate visual roles.
  - Arguments:
    - `chart_type` (string, required): The type of chart to generate (e.g., 'bar', 'pie', 'line', 'scatter'). This MUST be one of the types listed in the 'Charting Guidelines'.
    - `data` (list[dict], required): The data to be visualized, passed directly from the output of another tool.
    - `title` (string, required): A descriptive title for the chart.
    - `mapping` (dict, required): A dictionary that maps data keys to chart axes or roles (e.g., {'x_axis': 'product_name', 'y_axis': 'sales_total'}). The required keys for this mapping depend on the selected chart_type.
--- Category: Database Information ---
- `cust_td_serverInfo` (tool): Get the Teradata software information: demonstrates how to use parameters for prepared statements.
  - Arguments:
    - `infokey` (string, optional): No description.
- `dba_databaseVersion` (tool):  Get Teradata database version information.
- `base_databaseList` (tool): Lists all databases in the Teradata System.
--- Category: Database Space ---
- `dba_databaseSpace` (tool): 
Get database space if database name is provided, otherwise get all databases space allocations.

Arguments:
  database_name - database name

Returns:
  ResponseType: formatted response with query results + metadata

- `get_cube_cust_cube_db_space_metrics` (tool): 
    Tool to query the cube 'table_skew_pct'.
    Get the Teradata database space metrics for tables and databases

    Expected inputs:
        dimensions (str): Comma-separated dimension names to group by. Allowed values:
    - DatabaseName: Name of the database
    - TableName: Name of the table

        measures (str): Comma-separated measure names to aggregate. Allowed values:
    - current_perm: Object perm space in bytes
    - peak_perm: Object peak perm space in bytes
    - table_skew_pct: Object skew percentage

        filters (str): Comma-separated filter expressions to apply to either dimensions or measures selected. The dimension or measure used must be in the dimension list to group by or measure list, use valid SQL expressions, for example:
DatabaseName = 'value'
TableName = 'value'
current_perm > 1000
peak_perm > 1000
table_skew_pct > 1000

    Returns:
        Query result as a formatted response.
    
  - Arguments:
    - `dimensions` (string, optional): No description.
    - `measures` (string, optional): No description.
    - `filters` (string, optional): No description.
- `dba_systemSpace` (tool): Get the Teradata total system database space usage.
--- Category: Performance ---
- `dba_resusageSummary` (tool): 
Get the Teradata system usage summary metrics by weekday and hour for each workload type and query complexity bucket.

Arguments:
  dimensions - list of dimensions to aggregate the resource usage summary. All dimensions are: ["LogDate", "hourOfDay", "dayOfWeek", "workloadType", "workloadComplexity", "UserName", "AppId", "StatementType"]
  user_name - user name
  date - Date to analyze, formatted as `YYYY-MM-DD`
  dayOfWeek - day of the week to analyze
  hourOfDay - hour of day to analyze


- `dba_flowControl` (tool): Get the Teradata flow control metrics for a specified date range.
  - Arguments:
    - `start_date` (string, optional): No description.
    - `end_date` (string, optional): No description.
- `dba_userDelay` (tool): Get the Teradata user delay metrics for a specified date range.
  - Arguments:
    - `start_date` (string, optional): No description.
    - `end_date` (string, optional): No description.
--- Category: Query Execution ---
- `base_readQuery` (tool): 
Execute a SQL query via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  sql    - SQL text, with optional bind-parameter placeholders

Returns:
  ResponseType: formatted response with query results + metadata

--- Category: Sales Analytics ---
- `sales_top_customers` (tool): Get the top 20 customers by lifetime value.
- `sales_customer_profile` (tool): Get customer profile and metrics.
  - Arguments:
    - `customer_key` (string, optional): No description.
- `get_cube_sales_cube` (tool): 
    Tool to query the cube 'order_count'.
    Get the key sales metrics: USD amount and number of orders.

    Expected inputs:
        dimensions (str): Comma-separated dimension names to group by. Allowed values:
    - customer_key: Key for the customer
    - sales_year: Year of the sale
    - sales_month: Month of the sale

        measures (str): Comma-separated measure names to aggregate. Allowed values:
    - gift_amount_usd: Total gift card amount used for the order in USD
    - total_amount_usd: Total order amount in USD
    - order_count: Total number of orders

        filters (str): Comma-separated filter expressions to apply to either dimensions or measures selected. The dimension or measure used must be in the dimension list to group by or measure list, use valid SQL expressions, for example:
customer_key = 'value'
sales_year = 'value'
sales_month = 'value'
gift_amount_usd > 1000
total_amount_usd > 1000
order_count > 1000

    Returns:
        Query result as a formatted response.
    
  - Arguments:
    - `dimensions` (string, optional): No description.
    - `measures` (string, optional): No description.
    - `filters` (string, optional): No description.
--- Category: Security ---
- `sec_rolePermissions` (tool): 
Get permissions for a role.

Arguments:
  role_name - role name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `sec_userDbPermissions` (tool): 
Get permissions for a user.

Arguments:
  user_name - user name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `sec_userRoles` (tool): 
Get roles assigned to a user.

Arguments:
  user_name - user name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

--- Category: Session Management ---
- `dba_sessionInfo` (tool): Get the Teradata session information for user.
  - Arguments:
    - `user_name` (string, optional): No description.
--- Category: Table Management ---
- `dba_tableSpace` (tool): 
Get table space used for a table if table name is provided or get table space for all tables in a database if a database name is provided."

Arguments:
  database_name - database name
  table_name - table name

Returns:
  ResponseType: formatted response with query results + metadata

- `dba_tableSqlList` (tool): 
Get a list of SQL run against a table in the last number of days.

Arguments:
  table_name - table name
  no_days - number of days

Returns:
  ResponseType: formatted response with query results + metadata

- `dba_tableUsageImpact` (tool): 
Measure the usage of a table and views by users, this is helpful to understand what user and tables are driving most resource usage at any point in time.

Arguments:
  database_name - database name to analyze
  user_name - user name to analyze


- `base_columnDescription` (tool): 
Shows detailed column information about a database table via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name
  obj_name - table or view name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableAffinity` (tool): 
Get tables commonly used together by database users, this is helpful to infer relationships between tables via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name
  object_name - table or view name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableDDL` (tool): 
Displays the DDL definition of a table via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name
  table_name - table name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tablePreview` (tool): 
This function returns data sample and inferred structure from a database table or view via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  table_name - table or view name
  database_name - Database name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableUsage` (tool): 
Measure the usage of a table and views by users in a given schema, this is helpful to infer what database objects are most actively used or drive most value via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableList` (tool): Lists all tables in a database.
  - Arguments:
    - `database_name` (string, optional): No description.
--- Category: Usage Tracking ---
- `dba_featureUsage` (tool): Get the user feature usage metrics for a specified date range.
  - Arguments:
    - `start_date` (string, optional): No description.
    - `end_date` (string, optional): No description.
--- Category: User Management ---
- `dba_userSqlList` (tool): 
Get a list of SQL run by a user in the last number of days if a user name is provided, otherwise get list of all SQL in the last number of days.

Arguments:
  user_name - user name
  no_days - number of days

Returns:
  ResponseType: formatted response with query results + metadata

- `cust_activeUsers` (tool): Fetch currently active database users
--- Category: Utilities ---
- `tmpl_nameOfTool` (tool): 
<description of what the tool is for>

Arguments:
  arguments - arguments to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `evs_similarity_search` (tool): 
Enterprise Vector Store similarity search

Arguments:
  question - the query string to search for
  top_k - number of top results to return

Returns:
  ResponseType: formatted response with query results + metadata

- `rag_executeWorkflow` (tool): 
Execute complete RAG workflow to answer user questions based on document context.


This function handles the entire RAG pipeline:
1. Configuration setup (using configurable values from rag_config.yml)
2. Store user query (with /rag prefix stripping)
3. Generate query embeddings (tokenization + embedding)
4. Perform semantic search against chunk embeddings
5. Return retrieved context chunks for answer generation

The function uses configuration values from rag_config.yml with fallback defaults.

Arguments:
  question - user question to process
  k - number of top-k results to return (optional, uses config default if not provided)

Returns:
  Returns the top-k most relevant chunks with metadata for context-grounded answer generation.

- `rag_executeWorkflow_ivsm` (tool): 
Execute complete RAG workflow to answer user questions based on document context.

This function handles the entire RAG pipeline using IVSM functions:
1. Configuration setup (using configurable values from rag_config.yml)
2. Store user query (with /rag prefix stripping)
3. Tokenize query using ivsm.tokenizer_encode
4. Create embedding view using ivsm.IVSM_score
5. Convert embeddings to vector columns using ivsm.vector_to_columns
6. Perform semantic search against chunk embeddings

The function uses configuration values from rag_config.yml with fallback defaults.

Arguments:
  question - user question to process
  k - number of top-k results to return (optional, uses config default if not provided

Returns:
  Returns the top-k most relevant chunks with metadata for context-grounded answer generation.

- `util_getCurrentDate` (tool): Returns the current system date in YYYY-MM-DD format. Use this as the first step for any user query involving relative dates like 'today', 'yesterday', or 'this week'.
- `util_calculateDateRange` (tool): Calculates a list of dates based on a start date and a natural language phrase (e.g., 'past 3 days', 'last week'). This is a necessary second step for multi-day queries.
  - Arguments:
    - `start_date` (string, required): The anchor date for the calculation, usually today's date from `util_getCurrentDate`. Must be in YYYY-MM-DD format.
    - `date_phrase` (string, required): The natural language phrase describing the desired range (e.g., 'past 3 days', 'last 2 weeks').
- `CoreLLMTask` (tool): Performs internal, LLM-driven tasks that are not direct calls to the Teradata database. This tool is used for text synthesis, summarization, and formatting based on a specific 'task_description' provided by the LLM itself.
  - Arguments:
    - `task_description` (string, required): A natural language description of the internal task to be executed (e.g., 'describe the table in a business context', 'format final output'). The LLM infers this from the workflow plan.
    - `source_data` (list[string], required): A list of keys (e.g., 'result_of_phase_1') identifying which data from the workflow history is relevant for this task. This is critical for providing the correct context.
--- Available Prompts ---
--- Category: Prompts ---
- `base_query` (prompt): Help users interact with  Teradata databases effectively.
  - Arguments:
    - `query` (str, required): The problem or question that needs to be solved using Teradata database tools.
- `base_tableBusinessDesc` (prompt): You are a Teradata DBA who is an expert in describing the business use of tables in a database.
  - Arguments:
    - `database_name` (str, required): Database for the table to describe.
    - `table_name` (str, required): Table to describe.


USER PROMPT:

You are an expert strategic planning assistant. Your task is to analyze a user's request or a complex workflow goal and decompose it into a high-level, phased meta-plan. This plan will serve as a state machine executor.

--- GOAL ---
what is the system utilization of the past 2 weeks?

--- CONTEXT ---
- User's Original Question (for reference): what is the system utilization of the past 2 weeks?

--- INSTRUCTIONS ---
1.  **Analyze the Goal**: Carefully read the "GOAL" to understand the user's full intent.
2.  **Decompose into Phases**: Break down the overall goal into a sequence of logical phases. Each phase should represent a major step.
3.  **Define Each Phase**: For each phase, create a JSON object with the following keys:
    -   `"phase"`: An integer representing the step number (e.g., 1, 2, 3).
    -   `"goal"`: A clear, concise, and actionable description of what must be accomplished in this phase. This goal will guide a separate, tactical LLM.
    -   `"relevant_tools"`: A list of tool names that are permitted to be used during this phase. You MUST select the most appropriate and specific tools from the full "Capabilities" list provided in the main system prompt to achieve the phase's goal.
    -   (Optional) `"type": "loop"`: If a phase requires iterating over a list of items, you MUST include this key.
    -   (Optional) `"loop_over"`: If `"type"` is `"loop"`, specify the data source for the iteration (e.g., `"result_of_phase_1"`).
4.  **Embed Parameters**: When defining the `"goal"` for a phase, you MUST scan the main "GOAL" for any hardcoded arguments or parameters (e.g., table names, database names) relevant to that phase's task. You MUST embed these found parameters directly into the `"goal"` string to make it self-contained and explicit.
5.  **Final Synthesis and Formatting Phase**: If the main "GOAL" describes a multi-step process with a final reporting requirement, your plan **MUST** conclude with a single, final phase that handles both the synthesis of the final report AND its formatting. The `relevant_tools` for this final phase **MUST** be `["CoreLLMTask"]`.
6.  **CRITICAL RULE (Simplicity)**: If the "GOAL" is a simple, direct request that can be answered with a single tool call (e.g., "list all databases", "what is the system utilization?"), your plan **MUST** consist of only a single phase that calls the one most appropriate tool. Do not add unnecessary synthesis phases for simple data retrieval.
7.  **CRITICAL RULE (Execution Focus)**: Every phase you define **MUST** correspond to a concrete, tool-based action. You **MUST NOT** create phases for simple verification, confirmation, or acknowledgement of known information. Your plan must focus only on the execution steps required to gather new information or process existing data.
8.  **CRITICAL RULE (Capability Types)**: You are generating a plan of executable **tools**. The `relevant_tools` list **MUST ONLY** contain names of capabilities that are explicitly marked as `(tool)` in the system's "Capabilities" list. You **MUST NOT** include the name of any capability marked as `(prompt)`.
9.  **CRITICAL RULE (Efficiency)**: If a phase's `"goal"` already contains all the instructions for the final synthesis and formatting of the report (as specified in the main "GOAL"), you **MUST** make this the last phase of the plan. Do not add a separate, redundant formatting-only phase after it.

--- EXAMPLE (Complex Goal) ---
If the main goal requires getting DDL and then describing/formatting, your output should be a two-phase plan like this:
```json
[
  {
    "phase": 1,
    "goal": "Get the DDL for the table 'customers' in database 'sales' using the `base_tableDDL` tool.",
    "relevant_tools": ["base_tableDDL"]
  },
  {
    "phase": 2,
    "goal": "Synthesize a final report by describing the 'customers' table in a business context and format the output as markdown according to the Final output guidelines, using `***` for keys.",
    "relevant_tools": ["CoreLLMTask"]
  }
]
```

--- EXAMPLE (Simple Goal) ---
If the main goal is "what is the system utilization?", your output should be a single-phase plan like this:
```json
[
  {
    "phase": 1,
    "goal": "Get the system utilization using the `dba_resusageSummary` tool.",
    "relevant_tools": ["dba_resusageSummary"]
  }
]
```

--- EXAMPLE (Date Range Goal) ---
If the main goal is "what is the system utilization for the past 3 days?", your output must be a three-phase plan like this:
```json
[
  {
    "phase": 1,
    "goal": "Get the current date using the `util_getCurrentDate` tool to establish a reference point.",
    "relevant_tools": ["util_getCurrentDate"]
  },
  {
    "phase": 2,
    "goal": "Calculate the list of dates for 'the past 3 days' using the `util_calculateDateRange` tool.",
    "relevant_tools": ["util_calculateDateRange"]
  },
  {
    "phase": 3,
    "goal": "For each date calculated in the previous step, get the system utilization using the `dba_resusageSummary` tool.",
    "relevant_tools": ["dba_resusageSummary"],
    "type": "loop",
    "loop_over": "result_of_phase_2"
  }
]
```

Your response MUST be a single, valid JSON list of phase objects. Do NOT add any extra text, conversation, or markdown.

[model]: ```json
[
  {
    "phase": 1,
    "goal": "Get the current date using the `util_getCurrentDate` tool to establish a reference point.",
    "relevant_tools": ["util_getCurrentDate"]
  },
  {
    "phase": 2,
    "goal": "Calculate the list of dates for 'past 2 weeks' using the `util_calculateDateRange` tool.",
    "relevant_tools": ["util_calculateDateRange"]
  },
  {
    "phase": 3,
    "goal": "For each date calculated in the previous step, get the system utilization using the `dba_resusageSummary` tool.",
    "relevant_tools": ["dba_resusageSummary"],
    "type": "loop",
    "loop_over": "result_of_phase_2"
  }
]
```
[user]: SYSTEM PROMPT:

You are a tactical assistant executing a single phase of a larger plan. Your task is to decide the single best next action to take to achieve the current phase's goal, strictly adhering to the provided tool constraints.

--- OVERALL WORKFLOW GOAL ---
what is the system utilization of the past 2 weeks?

--- CURRENT PHASE GOAL ---
Get the current date using the `util_getCurrentDate` tool to establish a reference point.

--- CONSTRAINTS ---
- Permitted Tools for this Phase (You MUST use the exact argument names provided):

- Tool: `util_getCurrentDate`
  - Description: Returns the current system date in YYYY-MM-DD format. Use this as the first step for any user query involving relative dates like 'today', 'yesterday', or 'this week'.

- Previous Attempt (if any): None

--- WORKFLOW STATE & HISTORY ---
- Actions Taken So Far: []
- Data Collected So Far: {}

--- INSTRUCTIONS ---
1.  **Analyze the State**: Review the "CURRENT PHASE GOAL" and the "WORKFLOW STATE & HISTORY" to understand what has been done and what is needed next.
2.  **CRITICAL RULE (Tool Selection & Arguments)**: You **MUST** select your next action from the list of "Permitted Tools for this Phase". You are not allowed to use any other tool. Furthermore, you **MUST** use the exact argument names as they are defined in the tool details above. You **MUST NOT** invent, hallucinate, or use any arguments that are not explicitly listed in the definitions.
3.  **Self-Correction**: If a "Previous Attempt" is noted in the "CONSTRAINTS" section, it means your last choice was invalid. You **MUST** analyze the error and choose a different, valid tool from the permitted list. Do not repeat the invalid choice.
4.  **CoreLLMTask Usage**:
    -   For any task that involves synthesis, analysis, description, or summarization, you **MUST** use the `CoreLLMTask` tool, but only if it is in the permitted tools list.
    -   When calling `CoreLLMTask`, you **MUST** provide the `task_description` argument.
    -   Crucially, you **MUST** also determine which previous phase results are necessary for the task. You **MUST** provide these as a list of strings in the `source_data` argument.
    -   **CONTEXT PRESERVATION RULE**: If the current phase involves creating a final summary or report for the user, you **MUST** ensure you have all the necessary context. Your `source_data` list **MUST** include the results from **ALL** previous data-gathering phases (e.g., `["result_of_phase_1", "result_of_phase_2"]`) to prevent information loss.
5.  **Handle Loops**: If you are in a looping phase (indicated by the presence of a "LOOP CONTEXT" section), you **MUST** focus your action on the single item provided in `current_loop_item`. You **MUST** use the information within that item to formulate the arguments for your tool call.
6.  **Format Response**: Your response MUST be a single JSON object for a tool call.

Your response MUST be a single, valid JSON object for a tool call. Do NOT add any extra text or conversation.


USER PROMPT:
Determine the next action based on the instructions and state provided in the system prompt.
[model]: ```json
{"tool_name": "util_getCurrentDate", "arguments": {}}
```

--- Current User Prompt (with System Prompt) ---
SYSTEM PROMPT:

You are a tactical assistant executing a single phase of a larger plan. Your task is to decide the single best next action to take to achieve the current phase's goal, strictly adhering to the provided tool constraints.

--- OVERALL WORKFLOW GOAL ---
what is the system utilization of the past 2 weeks?

--- CURRENT PHASE GOAL ---
Calculate the list of dates for 'past 2 weeks' using the `util_calculateDateRange` tool.

--- CONSTRAINTS ---
- Permitted Tools for this Phase (You MUST use the exact argument names provided):

- Tool: `util_calculateDateRange`
  - Description: Calculates a list of dates based on a start date and a natural language phrase (e.g., 'past 3 days', 'last week'). This is a necessary second step for multi-day queries.
  - Arguments:
    - `start_date` (string, required): The anchor date for the calculation, usually today's date from `util_getCurrentDate`. Must be in YYYY-MM-DD format.
    - `date_phrase` (string, required): The natural language phrase describing the desired range (e.g., 'past 3 days', 'last 2 weeks').

- Previous Attempt (if any): None

--- WORKFLOW STATE & HISTORY ---
- Actions Taken So Far: [
  {
    "action": {
      "tool_name": "util_getCurrentDate",
      "arguments": {}
    },
    "result": {
      "status": "success",
      "metadata": {
        "tool_name": "util_getCurrentDate"
      },
      "results": [
        {
          "current_date": "2025-08-21"
        }
      ]
    }
  }
]
- Data Collected So Far: {
  "result_of_phase_1": [
    {
      "status": "success",
      "metadata": {
        "tool_name": "util_getCurrentDate"
      },
      "results": [
        {
          "current_date": "2025-08-21"
        }
      ]
    }
  ]
}

--- INSTRUCTIONS ---
1.  **Analyze the State**: Review the "CURRENT PHASE GOAL" and the "WORKFLOW STATE & HISTORY" to understand what has been done and what is needed next.
2.  **CRITICAL RULE (Tool Selection & Arguments)**: You **MUST** select your next action from the list of "Permitted Tools for this Phase". You are not allowed to use any other tool. Furthermore, you **MUST** use the exact argument names as they are defined in the tool details above. You **MUST NOT** invent, hallucinate, or use any arguments that are not explicitly listed in the definitions.
3.  **Self-Correction**: If a "Previous Attempt" is noted in the "CONSTRAINTS" section, it means your last choice was invalid. You **MUST** analyze the error and choose a different, valid tool from the permitted list. Do not repeat the invalid choice.
4.  **CoreLLMTask Usage**:
    -   For any task that involves synthesis, analysis, description, or summarization, you **MUST** use the `CoreLLMTask` tool, but only if it is in the permitted tools list.
    -   When calling `CoreLLMTask`, you **MUST** provide the `task_description` argument.
    -   Crucially, you **MUST** also determine which previous phase results are necessary for the task. You **MUST** provide these as a list of strings in the `source_data` argument.
    -   **CONTEXT PRESERVATION RULE**: If the current phase involves creating a final summary or report for the user, you **MUST** ensure you have all the necessary context. Your `source_data` list **MUST** include the results from **ALL** previous data-gathering phases (e.g., `["result_of_phase_1", "result_of_phase_2"]`) to prevent information loss.
5.  **Handle Loops**: If you are in a looping phase (indicated by the presence of a "LOOP CONTEXT" section), you **MUST** focus your action on the single item provided in `current_loop_item`. You **MUST** use the information within that item to formulate the arguments for your tool call.
6.  **Format Response**: Your response MUST be a single JSON object for a tool call.

Your response MUST be a single, valid JSON object for a tool call. Do NOT add any extra text or conversation.


USER PROMPT:
Determine the next action based on the instructions and state provided in the system prompt.

2025-08-21 22:46:03,217 - --- RESPONSE ---
```json
{"tool_name": "util_calculateDateRange", "arguments": {"start_date": "2025-08-21", "date_phrase": "past 2 weeks"}}
```
--------------------------------------------------

2025-08-21 22:46:10,492 - --- FULL CONTEXT (Session: df7e1f03-2ba5-457e-8b31-1a09c2af00c6) ---
--- REASON FOR CALL ---
Generating final summary from all collected tool data.

--- History ---
[user]: You are a helpful assistant.
[model]: Understood.
[user]: SYSTEM PROMPT:

# Core Directives
You are a specialized assistant for a Teradata database system. Your primary goal is to fulfill user requests by selecting the best capability (a tool or a prompt) from the categorized lists provided and supplying all necessary arguments.

# Response Format
Your response MUST be a single JSON object for a tool/prompt call OR a single plain text string for a final answer.

1.  **Tool/Prompt Calls (JSON format):**
    -   If the capability is a prompt, you MUST use the key `"prompt_name"`.
    -   If the capability is a tool, you MUST use the key `"tool_name"`.
    -   Provide all required arguments. Infer values from the conversation history if necessary.
    -   Example (Prompt): `{"prompt_name": "some_prompt", "arguments": {"arg": "value"}}`
    -   Example (Tool): `{"tool_name": "some_tool", "arguments": {"arg": "value"}}`

2.  **Final Answer (Plain Text format):**
    -   When you have sufficient information to fully answer the user's request, you MUST stop using tools.
    -   Your response MUST begin with the exact prefix `FINAL_ANSWER:`, followed by a natural language summary.
    -   Example: `FINAL_ANSWER: I found 48 databases on the system. The details are displayed below.`

# Decision Process
To select the correct capability, you MUST follow this two-step process, governed by one critical rule:

**CRITICAL RULE: Prioritize Specificity and Arguments.** Your primary filter for selecting a capability is its specificity. You MUST select the most granular capability that uses the most entities from the user's request (e.g., prefer a tool that uses a `table_name` over one that only uses a `database_name` if a table is mentioned). For direct actions and single analyses, you MUST select a `tool_name`; only select a `prompt_name` for broad, multi-step tasks explicitly described by the prompt.

1.  **Identify the Category:** First, analyze the user's request to determine which Tool or Prompt Category is the most relevant to their intent. The available categories are listed in the "Capabilities" section below.
2.  **Select the Capability:** Second, from within that single most relevant category, select the best tool or prompt to fulfill the request, adhering to the Critical Rule above.

# Few-Shot Examples
Here are examples of the correct thinking process:

**Example 1:**
- **User Query:** "what is the quality of table 'online' in database 'DEMO_Customer360_db'?"
- **Thought Process:**
    1.  The user's query is about a **table**.
    2.  My critical rule is to prioritize specificity. I must choose a table-level tool.
    3.  The `qlty_databaseQuality` prompt is for databases, not specific tables, so it's incorrect.
    4.  The `qlty_columnSummary` tool takes a `table_name` and is the most specific, correct choice.
- **Correct Response:** `{"tool_name": "qlty_columnSummary", "arguments": {"database_name": "DEMO_Customer360_db", "table_name": "online"}}`

**Example 2:**
- **User Query:** "describe the business purpose of the 'DEMO_Customer360_db' database"
- **Thought Process:**
    1.  The user's query is about a **database**. It's a broad request ("describe").
    2.  A prompt is better for broad tasks.
    3.  The `base_databaseBusinessDesc` prompt takes a `database_name` and is the correct choice.
- **Correct Response:** `{"prompt_name": "base_databaseBusinessDesc", "arguments": {"database_name": "DEMO_Customer360_db"}}`

**Example 3:**
- **User Query:** "what is the system utilization?"
- **Thought Process:**
    1.  The user is asking for a specific metric: "system utilization". This is a direct request for data.
    2.  My critical rule states I must prioritize a `tool_name` for direct actions.
    3.  The `dba_systemVoice` prompt is for adopting a persona, not for fetching specific metrics. It is the incorrect choice.
    4.  The `dba_resusageSummary` tool in the `Performance` category is designed to get system usage summary metrics. This is the correct choice.
- **Correct Response:** `{"tool_name": "dba_resusageSummary", "arguments": {}}`

# Best Practices
- **Context is Key:** Always use information from previous turns to fill in arguments like `db_name` or `table_name`.
- **Error Recovery:** If a tool fails, analyze the error message and attempt to call the tool again with corrected parameters. Only ask the user for clarification if you cannot recover.
- **SQL Generation:** When using the `base_readQuery` tool, you MUST use fully qualified table names in your SQL (e.g., `SELECT ... FROM my_database.my_table`).
- **Time-Sensitive Queries:** For queries involving relative dates (e.g., 'today', 'this week'), you MUST use the `util_getCurrentDate` tool first to determine the current date before proceeding.
- **Out of Scope:** If the user's request is unrelated to the available capabilities, respond with a `FINAL_ANSWER:` that politely explains you cannot fulfill the request and restates your purpose.
- **CRITICAL: Avoid Repetitive Behavior.** You are a highly intelligent agent. Do not get stuck in a loop by repeating the same tool calls or by cycling through the same set of tools. Once a tool has returned a successful result with data that is relevant to the user's request, do not call that same tool again unless there is a new and compelling reason to do so. If you have called a series of tools and believe you have enough information, you must call a FINAL_ANSWER. Do not repeat tool calls just to be "through".


# Capabilities
--- Available Tools ---
--- Category: Data Quality ---
- `qlty_columnSummary` (tool): 
Get the column summary statistics for a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_distinctCategories` (tool): 
Get the destinct categories from column in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_missingValues` (tool): 
Get the column names that having missing values in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_negativeValues` (tool): 
Get the column names that having negative values in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_rowsWithMissingValues` (tool): 
Get the rows with missing values in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_standardDeviation` (tool): 
Get the standard deviation from column in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_univariateStatistics` (tool): 
Get the univariate statistics for a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

--- Category: Data Visualization ---
- `viz_createChart` (tool): Generates a data visualization based on provided data. You must specify the chart type and map the data fields to the appropriate visual roles.
  - Arguments:
    - `chart_type` (string, required): The type of chart to generate (e.g., 'bar', 'pie', 'line', 'scatter'). This MUST be one of the types listed in the 'Charting Guidelines'.
    - `data` (list[dict], required): The data to be visualized, passed directly from the output of another tool.
    - `title` (string, required): A descriptive title for the chart.
    - `mapping` (dict, required): A dictionary that maps data keys to chart axes or roles (e.g., {'x_axis': 'product_name', 'y_axis': 'sales_total'}). The required keys for this mapping depend on the selected chart_type.
--- Category: Database Information ---
- `cust_td_serverInfo` (tool): Get the Teradata software information: demonstrates how to use parameters for prepared statements.
  - Arguments:
    - `infokey` (string, optional): No description.
- `dba_databaseVersion` (tool):  Get Teradata database version information.
- `base_databaseList` (tool): Lists all databases in the Teradata System.
--- Category: Database Space ---
- `dba_databaseSpace` (tool): 
Get database space if database name is provided, otherwise get all databases space allocations.

Arguments:
  database_name - database name

Returns:
  ResponseType: formatted response with query results + metadata

- `get_cube_cust_cube_db_space_metrics` (tool): 
    Tool to query the cube 'table_skew_pct'.
    Get the Teradata database space metrics for tables and databases

    Expected inputs:
        dimensions (str): Comma-separated dimension names to group by. Allowed values:
    - DatabaseName: Name of the database
    - TableName: Name of the table

        measures (str): Comma-separated measure names to aggregate. Allowed values:
    - current_perm: Object perm space in bytes
    - peak_perm: Object peak perm space in bytes
    - table_skew_pct: Object skew percentage

        filters (str): Comma-separated filter expressions to apply to either dimensions or measures selected. The dimension or measure used must be in the dimension list to group by or measure list, use valid SQL expressions, for example:
DatabaseName = 'value'
TableName = 'value'
current_perm > 1000
peak_perm > 1000
table_skew_pct > 1000

    Returns:
        Query result as a formatted response.
    
  - Arguments:
    - `dimensions` (string, optional): No description.
    - `measures` (string, optional): No description.
    - `filters` (string, optional): No description.
- `dba_systemSpace` (tool): Get the Teradata total system database space usage.
--- Category: Performance ---
- `dba_resusageSummary` (tool): 
Get the Teradata system usage summary metrics by weekday and hour for each workload type and query complexity bucket.

Arguments:
  dimensions - list of dimensions to aggregate the resource usage summary. All dimensions are: ["LogDate", "hourOfDay", "dayOfWeek", "workloadType", "workloadComplexity", "UserName", "AppId", "StatementType"]
  user_name - user name
  date - Date to analyze, formatted as `YYYY-MM-DD`
  dayOfWeek - day of the week to analyze
  hourOfDay - hour of day to analyze


- `dba_flowControl` (tool): Get the Teradata flow control metrics for a specified date range.
  - Arguments:
    - `start_date` (string, optional): No description.
    - `end_date` (string, optional): No description.
- `dba_userDelay` (tool): Get the Teradata user delay metrics for a specified date range.
  - Arguments:
    - `start_date` (string, optional): No description.
    - `end_date` (string, optional): No description.
--- Category: Query Execution ---
- `base_readQuery` (tool): 
Execute a SQL query via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  sql    - SQL text, with optional bind-parameter placeholders

Returns:
  ResponseType: formatted response with query results + metadata

--- Category: Sales Analytics ---
- `sales_top_customers` (tool): Get the top 20 customers by lifetime value.
- `sales_customer_profile` (tool): Get customer profile and metrics.
  - Arguments:
    - `customer_key` (string, optional): No description.
- `get_cube_sales_cube` (tool): 
    Tool to query the cube 'order_count'.
    Get the key sales metrics: USD amount and number of orders.

    Expected inputs:
        dimensions (str): Comma-separated dimension names to group by. Allowed values:
    - customer_key: Key for the customer
    - sales_year: Year of the sale
    - sales_month: Month of the sale

        measures (str): Comma-separated measure names to aggregate. Allowed values:
    - gift_amount_usd: Total gift card amount used for the order in USD
    - total_amount_usd: Total order amount in USD
    - order_count: Total number of orders

        filters (str): Comma-separated filter expressions to apply to either dimensions or measures selected. The dimension or measure used must be in the dimension list to group by or measure list, use valid SQL expressions, for example:
customer_key = 'value'
sales_year = 'value'
sales_month = 'value'
gift_amount_usd > 1000
total_amount_usd > 1000
order_count > 1000

    Returns:
        Query result as a formatted response.
    
  - Arguments:
    - `dimensions` (string, optional): No description.
    - `measures` (string, optional): No description.
    - `filters` (string, optional): No description.
--- Category: Security ---
- `sec_rolePermissions` (tool): 
Get permissions for a role.

Arguments:
  role_name - role name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `sec_userDbPermissions` (tool): 
Get permissions for a user.

Arguments:
  user_name - user name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `sec_userRoles` (tool): 
Get roles assigned to a user.

Arguments:
  user_name - user name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

--- Category: Session Management ---
- `dba_sessionInfo` (tool): Get the Teradata session information for user.
  - Arguments:
    - `user_name` (string, optional): No description.
--- Category: Table Management ---
- `dba_tableSpace` (tool): 
Get table space used for a table if table name is provided or get table space for all tables in a database if a database name is provided."

Arguments:
  database_name - database name
  table_name - table name

Returns:
  ResponseType: formatted response with query results + metadata

- `dba_tableSqlList` (tool): 
Get a list of SQL run against a table in the last number of days.

Arguments:
  table_name - table name
  no_days - number of days

Returns:
  ResponseType: formatted response with query results + metadata

- `dba_tableUsageImpact` (tool): 
Measure the usage of a table and views by users, this is helpful to understand what user and tables are driving most resource usage at any point in time.

Arguments:
  database_name - database name to analyze
  user_name - user name to analyze


- `base_columnDescription` (tool): 
Shows detailed column information about a database table via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name
  obj_name - table or view name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableAffinity` (tool): 
Get tables commonly used together by database users, this is helpful to infer relationships between tables via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name
  object_name - table or view name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableDDL` (tool): 
Displays the DDL definition of a table via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name
  table_name - table name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tablePreview` (tool): 
This function returns data sample and inferred structure from a database table or view via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  table_name - table or view name
  database_name - Database name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableUsage` (tool): 
Measure the usage of a table and views by users in a given schema, this is helpful to infer what database objects are most actively used or drive most value via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableList` (tool): Lists all tables in a database.
  - Arguments:
    - `database_name` (string, optional): No description.
--- Category: Usage Tracking ---
- `dba_featureUsage` (tool): Get the user feature usage metrics for a specified date range.
  - Arguments:
    - `start_date` (string, optional): No description.
    - `end_date` (string, optional): No description.
--- Category: User Management ---
- `dba_userSqlList` (tool): 
Get a list of SQL run by a user in the last number of days if a user name is provided, otherwise get list of all SQL in the last number of days.

Arguments:
  user_name - user name
  no_days - number of days

Returns:
  ResponseType: formatted response with query results + metadata

- `cust_activeUsers` (tool): Fetch currently active database users
--- Category: Utilities ---
- `tmpl_nameOfTool` (tool): 
<description of what the tool is for>

Arguments:
  arguments - arguments to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `evs_similarity_search` (tool): 
Enterprise Vector Store similarity search

Arguments:
  question - the query string to search for
  top_k - number of top results to return

Returns:
  ResponseType: formatted response with query results + metadata

- `rag_executeWorkflow` (tool): 
Execute complete RAG workflow to answer user questions based on document context.


This function handles the entire RAG pipeline:
1. Configuration setup (using configurable values from rag_config.yml)
2. Store user query (with /rag prefix stripping)
3. Generate query embeddings (tokenization + embedding)
4. Perform semantic search against chunk embeddings
5. Return retrieved context chunks for answer generation

The function uses configuration values from rag_config.yml with fallback defaults.

Arguments:
  question - user question to process
  k - number of top-k results to return (optional, uses config default if not provided)

Returns:
  Returns the top-k most relevant chunks with metadata for context-grounded answer generation.

- `rag_executeWorkflow_ivsm` (tool): 
Execute complete RAG workflow to answer user questions based on document context.

This function handles the entire RAG pipeline using IVSM functions:
1. Configuration setup (using configurable values from rag_config.yml)
2. Store user query (with /rag prefix stripping)
3. Tokenize query using ivsm.tokenizer_encode
4. Create embedding view using ivsm.IVSM_score
5. Convert embeddings to vector columns using ivsm.vector_to_columns
6. Perform semantic search against chunk embeddings

The function uses configuration values from rag_config.yml with fallback defaults.

Arguments:
  question - user question to process
  k - number of top-k results to return (optional, uses config default if not provided

Returns:
  Returns the top-k most relevant chunks with metadata for context-grounded answer generation.

- `util_getCurrentDate` (tool): Returns the current system date in YYYY-MM-DD format. Use this as the first step for any user query involving relative dates like 'today', 'yesterday', or 'this week'.
- `util_calculateDateRange` (tool): Calculates a list of dates based on a start date and a natural language phrase (e.g., 'past 3 days', 'last week'). This is a necessary second step for multi-day queries.
  - Arguments:
    - `start_date` (string, required): The anchor date for the calculation, usually today's date from `util_getCurrentDate`. Must be in YYYY-MM-DD format.
    - `date_phrase` (string, required): The natural language phrase describing the desired range (e.g., 'past 3 days', 'last 2 weeks').
- `CoreLLMTask` (tool): Performs internal, LLM-driven tasks that are not direct calls to the Teradata database. This tool is used for text synthesis, summarization, and formatting based on a specific 'task_description' provided by the LLM itself.
  - Arguments:
    - `task_description` (string, required): A natural language description of the internal task to be executed (e.g., 'describe the table in a business context', 'format final output'). The LLM infers this from the workflow plan.
    - `source_data` (list[string], required): A list of keys (e.g., 'result_of_phase_1') identifying which data from the workflow history is relevant for this task. This is critical for providing the correct context.
--- Available Prompts ---
--- Category: Prompts ---
- `base_query` (prompt): Help users interact with  Teradata databases effectively.
  - Arguments:
    - `query` (str, required): The problem or question that needs to be solved using Teradata database tools.
- `base_tableBusinessDesc` (prompt): You are a Teradata DBA who is an expert in describing the business use of tables in a database.
  - Arguments:
    - `database_name` (str, required): Database for the table to describe.
    - `table_name` (str, required): Table to describe.


USER PROMPT:

You are an expert strategic planning assistant. Your task is to analyze a user's request or a complex workflow goal and decompose it into a high-level, phased meta-plan. This plan will serve as a state machine executor.

--- GOAL ---
what is the system utilization of the past 3 days?

--- CONTEXT ---
- User's Original Question (for reference): what is the system utilization of the past 3 days?

--- INSTRUCTIONS ---
1.  **Analyze the Goal**: Carefully read the "GOAL" to understand the user's full intent.
2.  **Decompose into Phases**: Break down the overall goal into a sequence of logical phases. Each phase should represent a major step.
3.  **Define Each Phase**: For each phase, create a JSON object with the following keys:
    -   `"phase"`: An integer representing the step number (e.g., 1, 2, 3).
    -   `"goal"`: A clear, concise, and actionable description of what must be accomplished in this phase. This goal will guide a separate, tactical LLM.
    -   `"relevant_tools"`: A list of tool names that are permitted to be used during this phase. You MUST select the most appropriate and specific tools from the full "Capabilities" list provided in the main system prompt to achieve the phase's goal.
    -   (Optional) `"type": "loop"`: If a phase requires iterating over a list of items, you MUST include this key.
    -   (Optional) `"loop_over"`: If `"type"` is `"loop"`, specify the data source for the iteration (e.g., `"result_of_phase_1"`).
4.  **Embed Parameters**: When defining the `"goal"` for a phase, you MUST scan the main "GOAL" for any hardcoded arguments or parameters (e.g., table names, database names) relevant to that phase's task. You MUST embed these found parameters directly into the `"goal"` string to make it self-contained and explicit.
5.  **Final Synthesis and Formatting Phase**: If the main "GOAL" describes a multi-step process with a final reporting requirement, your plan **MUST** conclude with a single, final phase that handles both the synthesis of the final report AND its formatting. The `relevant_tools` for this final phase **MUST** be `["CoreLLMTask"]`.
6.  **CRITICAL RULE (Simplicity)**: If the "GOAL" is a simple, direct request that can be answered with a single tool call (e.g., "list all databases", "what is the system utilization?"), your plan **MUST** consist of only a single phase that calls the one most appropriate tool. Do not add unnecessary synthesis phases for simple data retrieval.
7.  **CRITICAL RULE (Execution Focus)**: Every phase you define **MUST** correspond to a concrete, tool-based action. You **MUST NOT** create phases for simple verification, confirmation, or acknowledgement of known information. Your plan must focus only on the execution steps required to gather new information or process existing data.
8.  **CRITICAL RULE (Capability Types)**: You are generating a plan of executable **tools**. The `relevant_tools` list **MUST ONLY** contain names of capabilities that are explicitly marked as `(tool)` in the system's "Capabilities" list. You **MUST NOT** include the name of any capability marked as `(prompt)`.
9.  **CRITICAL RULE (Efficiency)**: If a phase's `"goal"` already contains all the instructions for the final synthesis and formatting of the report (as specified in the main "GOAL"), you **MUST** make this the last phase of the plan. Do not add a separate, redundant formatting-only phase after it.

--- EXAMPLE (Complex Goal) ---
If the main goal requires getting DDL and then describing/formatting, your output should be a two-phase plan like this:
```json
[
  {
    "phase": 1,
    "goal": "Get the DDL for the table 'customers' in database 'sales' using the `base_tableDDL` tool.",
    "relevant_tools": ["base_tableDDL"]
  },
  {
    "phase": 2,
    "goal": "Synthesize a final report by describing the 'customers' table in a business context and format the output as markdown according to the Final output guidelines, using `***` for keys.",
    "relevant_tools": ["CoreLLMTask"]
  }
]
```

--- EXAMPLE (Simple Goal) ---
If the main goal is "what is the system utilization?", your output should be a single-phase plan like this:
```json
[
  {
    "phase": 1,
    "goal": "Get the system utilization using the `dba_resusageSummary` tool.",
    "relevant_tools": ["dba_resusageSummary"]
  }
]
```

--- EXAMPLE (Date Range Goal) ---
If the main goal is "what is the system utilization for the past 3 days?", your output must be a three-phase plan like this:
```json
[
  {
    "phase": 1,
    "goal": "Get the current date using the `util_getCurrentDate` tool to establish a reference point.",
    "relevant_tools": ["util_getCurrentDate"]
  },
  {
    "phase": 2,
    "goal": "Calculate the list of dates for 'the past 3 days' using the `util_calculateDateRange` tool.",
    "relevant_tools": ["util_calculateDateRange"]
  },
  {
    "phase": 3,
    "goal": "For each date calculated in the previous step, get the system utilization using the `dba_resusageSummary` tool.",
    "relevant_tools": ["dba_resusageSummary"],
    "type": "loop",
    "loop_over": "result_of_phase_2"
  }
]
```

Your response MUST be a single, valid JSON list of phase objects. Do NOT add any extra text, conversation, or markdown.

[model]: ```json
[
  {
    "phase": 1,
    "goal": "Get the current date using the `util_getCurrentDate` tool to establish a reference point.",
    "relevant_tools": ["util_getCurrentDate"]
  },
  {
    "phase": 2,
    "goal": "Calculate the list of dates for 'past 3 days' using the `util_calculateDateRange` tool.",
    "relevant_tools": ["util_calculateDateRange"]
  },
  {
    "phase": 3,
    "goal": "For each date calculated in the previous step, get the system utilization using the `dba_resusageSummary` tool.",
    "relevant_tools": ["dba_resusageSummary"],
    "type": "loop",
    "loop_over": "result_of_phase_2"
  }
]
```
[user]: SYSTEM PROMPT:

You are a tactical assistant executing a single phase of a larger plan. Your task is to decide the single best next action to take to achieve the current phase's goal, strictly adhering to the provided tool constraints.

--- OVERALL WORKFLOW GOAL ---
what is the system utilization of the past 3 days?

--- CURRENT PHASE GOAL ---
Get the current date using the `util_getCurrentDate` tool to establish a reference point.

--- CONSTRAINTS ---
- Permitted Tools for this Phase (You MUST use the exact argument names provided):

- Tool: `util_getCurrentDate`
  - Description: Returns the current system date in YYYY-MM-DD format. Use this as the first step for any user query involving relative dates like 'today', 'yesterday', or 'this week'.

- Previous Attempt (if any): None

--- WORKFLOW STATE & HISTORY ---
- Actions Taken So Far: []
- Data Collected So Far: {}

--- INSTRUCTIONS ---
1.  **Analyze the State**: Review the "CURRENT PHASE GOAL" and the "WORKFLOW STATE & HISTORY" to understand what has been done and what is needed next.
2.  **CRITICAL RULE (Tool Selection & Arguments)**: You **MUST** select your next action from the list of "Permitted Tools for this Phase". You are not allowed to use any other tool. Furthermore, you **MUST** use the exact argument names as they are defined in the tool details above. You **MUST NOT** invent, hallucinate, or use any arguments that are not explicitly listed in the definitions.
3.  **Self-Correction**: If a "Previous Attempt" is noted in the "CONSTRAINTS" section, it means your last choice was invalid. You **MUST** analyze the error and choose a different, valid tool from the permitted list. Do not repeat the invalid choice.
4.  **CoreLLMTask Usage**:
    -   For any task that involves synthesis, analysis, description, or summarization, you **MUST** use the `CoreLLMTask` tool, but only if it is in the permitted tools list.
    -   When calling `CoreLLMTask`, you **MUST** provide the `task_description` argument.
    -   Crucially, you **MUST** also determine which previous phase results are necessary for the task. You **MUST** provide these as a list of strings in the `source_data` argument.
    -   **CONTEXT PRESERVATION RULE**: If the current phase involves creating a final summary or report for the user, you **MUST** ensure you have all the necessary context. Your `source_data` list **MUST** include the results from **ALL** previous data-gathering phases (e.g., `["result_of_phase_1", "result_of_phase_2"]`) to prevent information loss.
5.  **Handle Loops**: If you are in a looping phase (indicated by the presence of a "LOOP CONTEXT" section), you **MUST** focus your action on the single item provided in `current_loop_item`. You **MUST** use the information within that item to formulate the arguments for your tool call.
6.  **Format Response**: Your response MUST be a single JSON object for a tool call.

Your response MUST be a single, valid JSON object for a tool call. Do NOT add any extra text or conversation.


USER PROMPT:
Determine the next action based on the instructions and state provided in the system prompt.
[model]: ```json
{"tool_name": "util_getCurrentDate", "arguments": {}}
```
[user]: SYSTEM PROMPT:

You are a tactical assistant executing a single phase of a larger plan. Your task is to decide the single best next action to take to achieve the current phase's goal, strictly adhering to the provided tool constraints.

--- OVERALL WORKFLOW GOAL ---
what is the system utilization of the past 3 days?

--- CURRENT PHASE GOAL ---
Calculate the list of dates for 'past 3 days' using the `util_calculateDateRange` tool.

--- CONSTRAINTS ---
- Permitted Tools for this Phase (You MUST use the exact argument names provided):

- Tool: `util_calculateDateRange`
  - Description: Calculates a list of dates based on a start date and a natural language phrase (e.g., 'past 3 days', 'last week'). This is a necessary second step for multi-day queries.
  - Arguments:
    - `start_date` (string, required): The anchor date for the calculation, usually today's date from `util_getCurrentDate`. Must be in YYYY-MM-DD format.
    - `date_phrase` (string, required): The natural language phrase describing the desired range (e.g., 'past 3 days', 'last 2 weeks').

- Previous Attempt (if any): None

--- WORKFLOW STATE & HISTORY ---
- Actions Taken So Far: [
  {
    "action": {
      "tool_name": "util_getCurrentDate",
      "arguments": {}
    },
    "result": {
      "status": "success",
      "metadata": {
        "tool_name": "util_getCurrentDate"
      },
      "results": [
        {
          "current_date": "2025-08-21"
        }
      ]
    }
  }
]
- Data Collected So Far: {
  "result_of_phase_1": [
    {
      "status": "success",
      "metadata": {
        "tool_name": "util_getCurrentDate"
      },
      "results": [
        {
          "current_date": "2025-08-21"
        }
      ]
    }
  ]
}

--- INSTRUCTIONS ---
1.  **Analyze the State**: Review the "CURRENT PHASE GOAL" and the "WORKFLOW STATE & HISTORY" to understand what has been done and what is needed next.
2.  **CRITICAL RULE (Tool Selection & Arguments)**: You **MUST** select your next action from the list of "Permitted Tools for this Phase". You are not allowed to use any other tool. Furthermore, you **MUST** use the exact argument names as they are defined in the tool details above. You **MUST NOT** invent, hallucinate, or use any arguments that are not explicitly listed in the definitions.
3.  **Self-Correction**: If a "Previous Attempt" is noted in the "CONSTRAINTS" section, it means your last choice was invalid. You **MUST** analyze the error and choose a different, valid tool from the permitted list. Do not repeat the invalid choice.
4.  **CoreLLMTask Usage**:
    -   For any task that involves synthesis, analysis, description, or summarization, you **MUST** use the `CoreLLMTask` tool, but only if it is in the permitted tools list.
    -   When calling `CoreLLMTask`, you **MUST** provide the `task_description` argument.
    -   Crucially, you **MUST** also determine which previous phase results are necessary for the task. You **MUST** provide these as a list of strings in the `source_data` argument.
    -   **CONTEXT PRESERVATION RULE**: If the current phase involves creating a final summary or report for the user, you **MUST** ensure you have all the necessary context. Your `source_data` list **MUST** include the results from **ALL** previous data-gathering phases (e.g., `["result_of_phase_1", "result_of_phase_2"]`) to prevent information loss.
5.  **Handle Loops**: If you are in a looping phase (indicated by the presence of a "LOOP CONTEXT" section), you **MUST** focus your action on the single item provided in `current_loop_item`. You **MUST** use the information within that item to formulate the arguments for your tool call.
6.  **Format Response**: Your response MUST be a single JSON object for a tool call.

Your response MUST be a single, valid JSON object for a tool call. Do NOT add any extra text or conversation.


USER PROMPT:
Determine the next action based on the instructions and state provided in the system prompt.
[model]: ```json
{"tool_name": "util_calculateDateRange", "arguments": {"start_date": "2025-08-21", "date_phrase": "past 3 days"}}
```
[user]: SYSTEM PROMPT:

# Core Directives
You are a specialized assistant for a Teradata database system. Your primary goal is to fulfill user requests by selecting the best capability (a tool or a prompt) from the categorized lists provided and supplying all necessary arguments.

# Response Format
Your response MUST be a single JSON object for a tool/prompt call OR a single plain text string for a final answer.

1.  **Tool/Prompt Calls (JSON format):**
    -   If the capability is a prompt, you MUST use the key `"prompt_name"`.
    -   If the capability is a tool, you MUST use the key `"tool_name"`.
    -   Provide all required arguments. Infer values from the conversation history if necessary.
    -   Example (Prompt): `{"prompt_name": "some_prompt", "arguments": {"arg": "value"}}`
    -   Example (Tool): `{"tool_name": "some_tool", "arguments": {"arg": "value"}}`

2.  **Final Answer (Plain Text format):**
    -   When you have sufficient information to fully answer the user's request, you MUST stop using tools.
    -   Your response MUST begin with the exact prefix `FINAL_ANSWER:`, followed by a natural language summary.
    -   Example: `FINAL_ANSWER: I found 48 databases on the system. The details are displayed below.`

# Decision Process
To select the correct capability, you MUST follow this two-step process, governed by one critical rule:

**CRITICAL RULE: Prioritize Specificity and Arguments.** Your primary filter for selecting a capability is its specificity. You MUST select the most granular capability that uses the most entities from the user's request (e.g., prefer a tool that uses a `table_name` over one that only uses a `database_name` if a table is mentioned). For direct actions and single analyses, you MUST select a `tool_name`; only select a `prompt_name` for broad, multi-step tasks explicitly described by the prompt.

1.  **Identify the Category:** First, analyze the user's request to determine which Tool or Prompt Category is the most relevant to their intent. The available categories are listed in the "Capabilities" section below.
2.  **Select the Capability:** Second, from within that single most relevant category, select the best tool or prompt to fulfill the request, adhering to the Critical Rule above.

# Few-Shot Examples
Here are examples of the correct thinking process:

**Example 1:**
- **User Query:** "what is the quality of table 'online' in database 'DEMO_Customer360_db'?"
- **Thought Process:**
    1.  The user's query is about a **table**.
    2.  My critical rule is to prioritize specificity. I must choose a table-level tool.
    3.  The `qlty_databaseQuality` prompt is for databases, not specific tables, so it's incorrect.
    4.  The `qlty_columnSummary` tool takes a `table_name` and is the most specific, correct choice.
- **Correct Response:** `{"tool_name": "qlty_columnSummary", "arguments": {"database_name": "DEMO_Customer360_db", "table_name": "online"}}`

**Example 2:**
- **User Query:** "describe the business purpose of the 'DEMO_Customer360_db' database"
- **Thought Process:**
    1.  The user's query is about a **database**. It's a broad request ("describe").
    2.  A prompt is better for broad tasks.
    3.  The `base_databaseBusinessDesc` prompt takes a `database_name` and is the correct choice.
- **Correct Response:** `{"prompt_name": "base_databaseBusinessDesc", "arguments": {"database_name": "DEMO_Customer360_db"}}`

**Example 3:**
- **User Query:** "what is the system utilization?"
- **Thought Process:**
    1.  The user is asking for a specific metric: "system utilization". This is a direct request for data.
    2.  My critical rule states I must prioritize a `tool_name` for direct actions.
    3.  The `dba_systemVoice` prompt is for adopting a persona, not for fetching specific metrics. It is the incorrect choice.
    4.  The `dba_resusageSummary` tool in the `Performance` category is designed to get system usage summary metrics. This is the correct choice.
- **Correct Response:** `{"tool_name": "dba_resusageSummary", "arguments": {}}`

# Best Practices
- **Context is Key:** Always use information from previous turns to fill in arguments like `db_name` or `table_name`.
- **Error Recovery:** If a tool fails, analyze the error message and attempt to call the tool again with corrected parameters. Only ask the user for clarification if you cannot recover.
- **SQL Generation:** When using the `base_readQuery` tool, you MUST use fully qualified table names in your SQL (e.g., `SELECT ... FROM my_database.my_table`).
- **Time-Sensitive Queries:** For queries involving relative dates (e.g., 'today', 'this week'), you MUST use the `util_getCurrentDate` tool first to determine the current date before proceeding.
- **Out of Scope:** If the user's request is unrelated to the available capabilities, respond with a `FINAL_ANSWER:` that politely explains you cannot fulfill the request and restates your purpose.
- **CRITICAL: Avoid Repetitive Behavior.** You are a highly intelligent agent. Do not get stuck in a loop by repeating the same tool calls or by cycling through the same set of tools. Once a tool has returned a successful result with data that is relevant to the user's request, do not call that same tool again unless there is a new and compelling reason to do so. If you have called a series of tools and believe you have enough information, you must call a FINAL_ANSWER. Do not repeat tool calls just to be "through".


# Capabilities
--- Available Tools ---
--- Category: Data Quality ---
- `qlty_columnSummary` (tool): 
Get the column summary statistics for a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_distinctCategories` (tool): 
Get the destinct categories from column in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_missingValues` (tool): 
Get the column names that having missing values in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_negativeValues` (tool): 
Get the column names that having negative values in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_rowsWithMissingValues` (tool): 
Get the rows with missing values in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_standardDeviation` (tool): 
Get the standard deviation from column in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_univariateStatistics` (tool): 
Get the univariate statistics for a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

--- Category: Data Visualization ---
- `viz_createChart` (tool): Generates a data visualization based on provided data. You must specify the chart type and map the data fields to the appropriate visual roles.
  - Arguments:
    - `chart_type` (string, required): The type of chart to generate (e.g., 'bar', 'pie', 'line', 'scatter'). This MUST be one of the types listed in the 'Charting Guidelines'.
    - `data` (list[dict], required): The data to be visualized, passed directly from the output of another tool.
    - `title` (string, required): A descriptive title for the chart.
    - `mapping` (dict, required): A dictionary that maps data keys to chart axes or roles (e.g., {'x_axis': 'product_name', 'y_axis': 'sales_total'}). The required keys for this mapping depend on the selected chart_type.
--- Category: Database Information ---
- `cust_td_serverInfo` (tool): Get the Teradata software information: demonstrates how to use parameters for prepared statements.
  - Arguments:
    - `infokey` (string, optional): No description.
- `dba_databaseVersion` (tool):  Get Teradata database version information.
- `base_databaseList` (tool): Lists all databases in the Teradata System.
--- Category: Database Space ---
- `dba_databaseSpace` (tool): 
Get database space if database name is provided, otherwise get all databases space allocations.

Arguments:
  database_name - database name

Returns:
  ResponseType: formatted response with query results + metadata

- `get_cube_cust_cube_db_space_metrics` (tool): 
    Tool to query the cube 'table_skew_pct'.
    Get the Teradata database space metrics for tables and databases

    Expected inputs:
        dimensions (str): Comma-separated dimension names to group by. Allowed values:
    - DatabaseName: Name of the database
    - TableName: Name of the table

        measures (str): Comma-separated measure names to aggregate. Allowed values:
    - current_perm: Object perm space in bytes
    - peak_perm: Object peak perm space in bytes
    - table_skew_pct: Object skew percentage

        filters (str): Comma-separated filter expressions to apply to either dimensions or measures selected. The dimension or measure used must be in the dimension list to group by or measure list, use valid SQL expressions, for example:
DatabaseName = 'value'
TableName = 'value'
current_perm > 1000
peak_perm > 1000
table_skew_pct > 1000

    Returns:
        Query result as a formatted response.
    
  - Arguments:
    - `dimensions` (string, optional): No description.
    - `measures` (string, optional): No description.
    - `filters` (string, optional): No description.
- `dba_systemSpace` (tool): Get the Teradata total system database space usage.
--- Category: Performance ---
- `dba_resusageSummary` (tool): 
Get the Teradata system usage summary metrics by weekday and hour for each workload type and query complexity bucket.

Arguments:
  dimensions - list of dimensions to aggregate the resource usage summary. All dimensions are: ["LogDate", "hourOfDay", "dayOfWeek", "workloadType", "workloadComplexity", "UserName", "AppId", "StatementType"]
  user_name - user name
  date - Date to analyze, formatted as `YYYY-MM-DD`
  dayOfWeek - day of the week to analyze
  hourOfDay - hour of day to analyze


- `dba_flowControl` (tool): Get the Teradata flow control metrics for a specified date range.
  - Arguments:
    - `start_date` (string, optional): No description.
    - `end_date` (string, optional): No description.
- `dba_userDelay` (tool): Get the Teradata user delay metrics for a specified date range.
  - Arguments:
    - `start_date` (string, optional): No description.
    - `end_date` (string, optional): No description.
--- Category: Query Execution ---
- `base_readQuery` (tool): 
Execute a SQL query via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  sql    - SQL text, with optional bind-parameter placeholders

Returns:
  ResponseType: formatted response with query results + metadata

--- Category: Sales Analytics ---
- `sales_top_customers` (tool): Get the top 20 customers by lifetime value.
- `sales_customer_profile` (tool): Get customer profile and metrics.
  - Arguments:
    - `customer_key` (string, optional): No description.
- `get_cube_sales_cube` (tool): 
    Tool to query the cube 'order_count'.
    Get the key sales metrics: USD amount and number of orders.

    Expected inputs:
        dimensions (str): Comma-separated dimension names to group by. Allowed values:
    - customer_key: Key for the customer
    - sales_year: Year of the sale
    - sales_month: Month of the sale

        measures (str): Comma-separated measure names to aggregate. Allowed values:
    - gift_amount_usd: Total gift card amount used for the order in USD
    - total_amount_usd: Total order amount in USD
    - order_count: Total number of orders

        filters (str): Comma-separated filter expressions to apply to either dimensions or measures selected. The dimension or measure used must be in the dimension list to group by or measure list, use valid SQL expressions, for example:
customer_key = 'value'
sales_year = 'value'
sales_month = 'value'
gift_amount_usd > 1000
total_amount_usd > 1000
order_count > 1000

    Returns:
        Query result as a formatted response.
    
  - Arguments:
    - `dimensions` (string, optional): No description.
    - `measures` (string, optional): No description.
    - `filters` (string, optional): No description.
--- Category: Security ---
- `sec_rolePermissions` (tool): 
Get permissions for a role.

Arguments:
  role_name - role name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `sec_userDbPermissions` (tool): 
Get permissions for a user.

Arguments:
  user_name - user name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `sec_userRoles` (tool): 
Get roles assigned to a user.

Arguments:
  user_name - user name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

--- Category: Session Management ---
- `dba_sessionInfo` (tool): Get the Teradata session information for user.
  - Arguments:
    - `user_name` (string, optional): No description.
--- Category: Table Management ---
- `dba_tableSpace` (tool): 
Get table space used for a table if table name is provided or get table space for all tables in a database if a database name is provided."

Arguments:
  database_name - database name
  table_name - table name

Returns:
  ResponseType: formatted response with query results + metadata

- `dba_tableSqlList` (tool): 
Get a list of SQL run against a table in the last number of days.

Arguments:
  table_name - table name
  no_days - number of days

Returns:
  ResponseType: formatted response with query results + metadata

- `dba_tableUsageImpact` (tool): 
Measure the usage of a table and views by users, this is helpful to understand what user and tables are driving most resource usage at any point in time.

Arguments:
  database_name - database name to analyze
  user_name - user name to analyze


- `base_columnDescription` (tool): 
Shows detailed column information about a database table via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name
  obj_name - table or view name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableAffinity` (tool): 
Get tables commonly used together by database users, this is helpful to infer relationships between tables via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name
  object_name - table or view name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableDDL` (tool): 
Displays the DDL definition of a table via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name
  table_name - table name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tablePreview` (tool): 
This function returns data sample and inferred structure from a database table or view via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  table_name - table or view name
  database_name - Database name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableUsage` (tool): 
Measure the usage of a table and views by users in a given schema, this is helpful to infer what database objects are most actively used or drive most value via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableList` (tool): Lists all tables in a database.
  - Arguments:
    - `database_name` (string, optional): No description.
--- Category: Usage Tracking ---
- `dba_featureUsage` (tool): Get the user feature usage metrics for a specified date range.
  - Arguments:
    - `start_date` (string, optional): No description.
    - `end_date` (string, optional): No description.
--- Category: User Management ---
- `dba_userSqlList` (tool): 
Get a list of SQL run by a user in the last number of days if a user name is provided, otherwise get list of all SQL in the last number of days.

Arguments:
  user_name - user name
  no_days - number of days

Returns:
  ResponseType: formatted response with query results + metadata

- `cust_activeUsers` (tool): Fetch currently active database users
--- Category: Utilities ---
- `tmpl_nameOfTool` (tool): 
<description of what the tool is for>

Arguments:
  arguments - arguments to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `evs_similarity_search` (tool): 
Enterprise Vector Store similarity search

Arguments:
  question - the query string to search for
  top_k - number of top results to return

Returns:
  ResponseType: formatted response with query results + metadata

- `rag_executeWorkflow` (tool): 
Execute complete RAG workflow to answer user questions based on document context.


This function handles the entire RAG pipeline:
1. Configuration setup (using configurable values from rag_config.yml)
2. Store user query (with /rag prefix stripping)
3. Generate query embeddings (tokenization + embedding)
4. Perform semantic search against chunk embeddings
5. Return retrieved context chunks for answer generation

The function uses configuration values from rag_config.yml with fallback defaults.

Arguments:
  question - user question to process
  k - number of top-k results to return (optional, uses config default if not provided)

Returns:
  Returns the top-k most relevant chunks with metadata for context-grounded answer generation.

- `rag_executeWorkflow_ivsm` (tool): 
Execute complete RAG workflow to answer user questions based on document context.

This function handles the entire RAG pipeline using IVSM functions:
1. Configuration setup (using configurable values from rag_config.yml)
2. Store user query (with /rag prefix stripping)
3. Tokenize query using ivsm.tokenizer_encode
4. Create embedding view using ivsm.IVSM_score
5. Convert embeddings to vector columns using ivsm.vector_to_columns
6. Perform semantic search against chunk embeddings

The function uses configuration values from rag_config.yml with fallback defaults.

Arguments:
  question - user question to process
  k - number of top-k results to return (optional, uses config default if not provided

Returns:
  Returns the top-k most relevant chunks with metadata for context-grounded answer generation.

- `util_getCurrentDate` (tool): Returns the current system date in YYYY-MM-DD format. Use this as the first step for any user query involving relative dates like 'today', 'yesterday', or 'this week'.
- `util_calculateDateRange` (tool): Calculates a list of dates based on a start date and a natural language phrase (e.g., 'past 3 days', 'last week'). This is a necessary second step for multi-day queries.
  - Arguments:
    - `start_date` (string, required): The anchor date for the calculation, usually today's date from `util_getCurrentDate`. Must be in YYYY-MM-DD format.
    - `date_phrase` (string, required): The natural language phrase describing the desired range (e.g., 'past 3 days', 'last 2 weeks').
- `CoreLLMTask` (tool): Performs internal, LLM-driven tasks that are not direct calls to the Teradata database. This tool is used for text synthesis, summarization, and formatting based on a specific 'task_description' provided by the LLM itself.
  - Arguments:
    - `task_description` (string, required): A natural language description of the internal task to be executed (e.g., 'describe the table in a business context', 'format final output'). The LLM infers this from the workflow plan.
    - `source_data` (list[string], required): A list of keys (e.g., 'result_of_phase_1') identifying which data from the workflow history is relevant for this task. This is critical for providing the correct context.
--- Available Prompts ---
--- Category: Prompts ---
- `base_query` (prompt): Help users interact with  Teradata databases effectively.
  - Arguments:
    - `query` (str, required): The problem or question that needs to be solved using Teradata database tools.
- `base_tableBusinessDesc` (prompt): You are a Teradata DBA who is an expert in describing the business use of tables in a database.
  - Arguments:
    - `database_name` (str, required): Database for the table to describe.
    - `table_name` (str, required): Table to describe.


USER PROMPT:
You are an expert data analyst. Synthesize all collected data into a clear, concise, and insightful final answer.

--- USER'S QUESTION ---
'what is the system utilization of the past 3 days?'

--- DATA COLLECTED ---
```json
[
  {
    "status": "success",
    "metadata": {
      "tool_name": "util_getCurrentDate"
    },
    "results": [
      {
        "current_date": "2025-08-21"
      }
    ]
  },
  {
    "status": "success",
    "metadata": {
      "tool_name": "util_calculateDateRange"
    },
    "results": [
      {
        "date": "2025-08-18"
      },
      {
        "date": "2025-08-19"
      },
      {
        "date": "2025-08-20"
      }
    ]
  },
  {
    "status": "success",
    "metadata": {
      "tool_name": "dba_resusageSummary",
      "total_rows": 1,
      "comment": "Total system resource usage summary."
    },
    "results": [
      {
        "Request Count": "0",
        "Total AMPCPUTime": "None",
        "Total IOCount": "None",
        "Total ReqIOKB": "None",
        "Total ReqPhysIO": "None",
        "Total ReqPhysIOKB": "None",
        "Total ReqIO GB": "None",
        "Total ReqPhysIOGB": "None",
        "Total Server Byte Count": "None"
      }
    ]
  },
  {
    "status": "success",
    "metadata": {
      "tool_name": "dba_resusageSummary",
      "total_rows": 1,
      "comment": "Total system resource usage summary."
    },
    "results": [
      {
        "Request Count": "283",
        "Total AMPCPUTime": "1.1800000000000002",
        "Total IOCount": "15931.0",
        "Total ReqIOKB": "741228.0",
        "Total ReqPhysIO": "44.0",
        "Total ReqPhysIOKB": "904.0",
        "Total ReqIO GB": "0.7068901062011719",
        "Total ReqPhysIOGB": "0.00086212158203125",
        "Total Server Byte Count": "0"
      }
    ]
  },
  {
    "status": "success",
    "metadata": {
      "tool_name": "dba_resusageSummary",
      "total_rows": 1,
      "comment": "Total system resource usage summary."
    },
    "results": [
      {
        "Request Count": "121",
        "Total AMPCPUTime": "0.316",
        "Total IOCount": "3929.0",
        "Total ReqIOKB": "163096.0",
        "Total ReqPhysIO": "8.0",
        "Total ReqPhysIOKB": "184.0",
        "Total ReqIO GB": "0.15554046630859375",
        "Total ReqPhysIOGB": "0.00017547607421875",
        "Total Server Byte Count": "0"
      }
    ]
  }
]
```

--- INSTRUCTIONS ---
1.  Provide a holistic analysis and actionable insights.
2.  Begin with a high-level summary, then use bullet points for key observations.
3.  Your entire response **MUST** begin with `FINAL_ANSWER:`.

[model]: FINAL_ANSWER: The system utilization for the past 3 days (2025-08-18 to 2025-08-20) shows varying levels of activity.

*   **2025-08-18:** No resource usage data was found for this date.
*   **2025-08-19:** The system processed 283 requests, consuming 1.18 AMP CPU seconds and performing 15931 I/O operations, with a total of 741228 KB of I/O.
*   **2025-08-20:** The system processed 121 requests, consuming 0.316 AMP CPU seconds and performing 3929 I/O operations, with a total of 163096 KB of I/O.

[user]: SYSTEM PROMPT:

# Core Directives
You are a specialized assistant for a Teradata database system. Your primary goal is to fulfill user requests by selecting the best capability (a tool or a prompt) from the categorized lists provided and supplying all necessary arguments.

# Response Format
Your response MUST be a single JSON object for a tool/prompt call OR a single plain text string for a final answer.

1.  **Tool/Prompt Calls (JSON format):**
    -   If the capability is a prompt, you MUST use the key `"prompt_name"`.
    -   If the capability is a tool, you MUST use the key `"tool_name"`.
    -   Provide all required arguments. Infer values from the conversation history if necessary.
    -   Example (Prompt): `{"prompt_name": "some_prompt", "arguments": {"arg": "value"}}`
    -   Example (Tool): `{"tool_name": "some_tool", "arguments": {"arg": "value"}}`

2.  **Final Answer (Plain Text format):**
    -   When you have sufficient information to fully answer the user's request, you MUST stop using tools.
    -   Your response MUST begin with the exact prefix `FINAL_ANSWER:`, followed by a natural language summary.
    -   Example: `FINAL_ANSWER: I found 48 databases on the system. The details are displayed below.`

# Decision Process
To select the correct capability, you MUST follow this two-step process, governed by one critical rule:

**CRITICAL RULE: Prioritize Specificity and Arguments.** Your primary filter for selecting a capability is its specificity. You MUST select the most granular capability that uses the most entities from the user's request (e.g., prefer a tool that uses a `table_name` over one that only uses a `database_name` if a table is mentioned). For direct actions and single analyses, you MUST select a `tool_name`; only select a `prompt_name` for broad, multi-step tasks explicitly described by the prompt.

1.  **Identify the Category:** First, analyze the user's request to determine which Tool or Prompt Category is the most relevant to their intent. The available categories are listed in the "Capabilities" section below.
2.  **Select the Capability:** Second, from within that single most relevant category, select the best tool or prompt to fulfill the request, adhering to the Critical Rule above.

# Few-Shot Examples
Here are examples of the correct thinking process:

**Example 1:**
- **User Query:** "what is the quality of table 'online' in database 'DEMO_Customer360_db'?"
- **Thought Process:**
    1.  The user's query is about a **table**.
    2.  My critical rule is to prioritize specificity. I must choose a table-level tool.
    3.  The `qlty_databaseQuality` prompt is for databases, not specific tables, so it's incorrect.
    4.  The `qlty_columnSummary` tool takes a `table_name` and is the most specific, correct choice.
- **Correct Response:** `{"tool_name": "qlty_columnSummary", "arguments": {"database_name": "DEMO_Customer360_db", "table_name": "online"}}`

**Example 2:**
- **User Query:** "describe the business purpose of the 'DEMO_Customer360_db' database"
- **Thought Process:**
    1.  The user's query is about a **database**. It's a broad request ("describe").
    2.  A prompt is better for broad tasks.
    3.  The `base_databaseBusinessDesc` prompt takes a `database_name` and is the correct choice.
- **Correct Response:** `{"prompt_name": "base_databaseBusinessDesc", "arguments": {"database_name": "DEMO_Customer360_db"}}`

**Example 3:**
- **User Query:** "what is the system utilization?"
- **Thought Process:**
    1.  The user is asking for a specific metric: "system utilization". This is a direct request for data.
    2.  My critical rule states I must prioritize a `tool_name` for direct actions.
    3.  The `dba_systemVoice` prompt is for adopting a persona, not for fetching specific metrics. It is the incorrect choice.
    4.  The `dba_resusageSummary` tool in the `Performance` category is designed to get system usage summary metrics. This is the correct choice.
- **Correct Response:** `{"tool_name": "dba_resusageSummary", "arguments": {}}`

# Best Practices
- **Context is Key:** Always use information from previous turns to fill in arguments like `db_name` or `table_name`.
- **Error Recovery:** If a tool fails, analyze the error message and attempt to call the tool again with corrected parameters. Only ask the user for clarification if you cannot recover.
- **SQL Generation:** When using the `base_readQuery` tool, you MUST use fully qualified table names in your SQL (e.g., `SELECT ... FROM my_database.my_table`).
- **Time-Sensitive Queries:** For queries involving relative dates (e.g., 'today', 'this week'), you MUST use the `util_getCurrentDate` tool first to determine the current date before proceeding.
- **Out of Scope:** If the user's request is unrelated to the available capabilities, respond with a `FINAL_ANSWER:` that politely explains you cannot fulfill the request and restates your purpose.
- **CRITICAL: Avoid Repetitive Behavior.** You are a highly intelligent agent. Do not get stuck in a loop by repeating the same tool calls or by cycling through the same set of tools. Once a tool has returned a successful result with data that is relevant to the user's request, do not call that same tool again unless there is a new and compelling reason to do so. If you have called a series of tools and believe you have enough information, you must call a FINAL_ANSWER. Do not repeat tool calls just to be "through".


# Capabilities
--- Available Tools ---
--- Category: Data Quality ---
- `qlty_columnSummary` (tool): 
Get the column summary statistics for a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_distinctCategories` (tool): 
Get the destinct categories from column in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_missingValues` (tool): 
Get the column names that having missing values in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_negativeValues` (tool): 
Get the column names that having negative values in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_rowsWithMissingValues` (tool): 
Get the rows with missing values in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_standardDeviation` (tool): 
Get the standard deviation from column in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_univariateStatistics` (tool): 
Get the univariate statistics for a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

--- Category: Data Visualization ---
- `viz_createChart` (tool): Generates a data visualization based on provided data. You must specify the chart type and map the data fields to the appropriate visual roles.
  - Arguments:
    - `chart_type` (string, required): The type of chart to generate (e.g., 'bar', 'pie', 'line', 'scatter'). This MUST be one of the types listed in the 'Charting Guidelines'.
    - `data` (list[dict], required): The data to be visualized, passed directly from the output of another tool.
    - `title` (string, required): A descriptive title for the chart.
    - `mapping` (dict, required): A dictionary that maps data keys to chart axes or roles (e.g., {'x_axis': 'product_name', 'y_axis': 'sales_total'}). The required keys for this mapping depend on the selected chart_type.
--- Category: Database Information ---
- `cust_td_serverInfo` (tool): Get the Teradata software information: demonstrates how to use parameters for prepared statements.
  - Arguments:
    - `infokey` (string, optional): No description.
- `dba_databaseVersion` (tool):  Get Teradata database version information.
- `base_databaseList` (tool): Lists all databases in the Teradata System.
--- Category: Database Space ---
- `dba_databaseSpace` (tool): 
Get database space if database name is provided, otherwise get all databases space allocations.

Arguments:
  database_name - database name

Returns:
  ResponseType: formatted response with query results + metadata

- `get_cube_cust_cube_db_space_metrics` (tool): 
    Tool to query the cube 'table_skew_pct'.
    Get the Teradata database space metrics for tables and databases

    Expected inputs:
        dimensions (str): Comma-separated dimension names to group by. Allowed values:
    - DatabaseName: Name of the database
    - TableName: Name of the table

        measures (str): Comma-separated measure names to aggregate. Allowed values:
    - current_perm: Object perm space in bytes
    - peak_perm: Object peak perm space in bytes
    - table_skew_pct: Object skew percentage

        filters (str): Comma-separated filter expressions to apply to either dimensions or measures selected. The dimension or measure used must be in the dimension list to group by or measure list, use valid SQL expressions, for example:
DatabaseName = 'value'
TableName = 'value'
current_perm > 1000
peak_perm > 1000
table_skew_pct > 1000

    Returns:
        Query result as a formatted response.
    
  - Arguments:
    - `dimensions` (string, optional): No description.
    - `measures` (string, optional): No description.
    - `filters` (string, optional): No description.
- `dba_systemSpace` (tool): Get the Teradata total system database space usage.
--- Category: Performance ---
- `dba_resusageSummary` (tool): 
Get the Teradata system usage summary metrics by weekday and hour for each workload type and query complexity bucket.

Arguments:
  dimensions - list of dimensions to aggregate the resource usage summary. All dimensions are: ["LogDate", "hourOfDay", "dayOfWeek", "workloadType", "workloadComplexity", "UserName", "AppId", "StatementType"]
  user_name - user name
  date - Date to analyze, formatted as `YYYY-MM-DD`
  dayOfWeek - day of the week to analyze
  hourOfDay - hour of day to analyze


- `dba_flowControl` (tool): Get the Teradata flow control metrics for a specified date range.
  - Arguments:
    - `start_date` (string, optional): No description.
    - `end_date` (string, optional): No description.
- `dba_userDelay` (tool): Get the Teradata user delay metrics for a specified date range.
  - Arguments:
    - `start_date` (string, optional): No description.
    - `end_date` (string, optional): No description.
--- Category: Query Execution ---
- `base_readQuery` (tool): 
Execute a SQL query via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  sql    - SQL text, with optional bind-parameter placeholders

Returns:
  ResponseType: formatted response with query results + metadata

--- Category: Sales Analytics ---
- `sales_top_customers` (tool): Get the top 20 customers by lifetime value.
- `sales_customer_profile` (tool): Get customer profile and metrics.
  - Arguments:
    - `customer_key` (string, optional): No description.
- `get_cube_sales_cube` (tool): 
    Tool to query the cube 'order_count'.
    Get the key sales metrics: USD amount and number of orders.

    Expected inputs:
        dimensions (str): Comma-separated dimension names to group by. Allowed values:
    - customer_key: Key for the customer
    - sales_year: Year of the sale
    - sales_month: Month of the sale

        measures (str): Comma-separated measure names to aggregate. Allowed values:
    - gift_amount_usd: Total gift card amount used for the order in USD
    - total_amount_usd: Total order amount in USD
    - order_count: Total number of orders

        filters (str): Comma-separated filter expressions to apply to either dimensions or measures selected. The dimension or measure used must be in the dimension list to group by or measure list, use valid SQL expressions, for example:
customer_key = 'value'
sales_year = 'value'
sales_month = 'value'
gift_amount_usd > 1000
total_amount_usd > 1000
order_count > 1000

    Returns:
        Query result as a formatted response.
    
  - Arguments:
    - `dimensions` (string, optional): No description.
    - `measures` (string, optional): No description.
    - `filters` (string, optional): No description.
--- Category: Security ---
- `sec_rolePermissions` (tool): 
Get permissions for a role.

Arguments:
  role_name - role name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `sec_userDbPermissions` (tool): 
Get permissions for a user.

Arguments:
  user_name - user name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `sec_userRoles` (tool): 
Get roles assigned to a user.

Arguments:
  user_name - user name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

--- Category: Session Management ---
- `dba_sessionInfo` (tool): Get the Teradata session information for user.
  - Arguments:
    - `user_name` (string, optional): No description.
--- Category: Table Management ---
- `dba_tableSpace` (tool): 
Get table space used for a table if table name is provided or get table space for all tables in a database if a database name is provided."

Arguments:
  database_name - database name
  table_name - table name

Returns:
  ResponseType: formatted response with query results + metadata

- `dba_tableSqlList` (tool): 
Get a list of SQL run against a table in the last number of days.

Arguments:
  table_name - table name
  no_days - number of days

Returns:
  ResponseType: formatted response with query results + metadata

- `dba_tableUsageImpact` (tool): 
Measure the usage of a table and views by users, this is helpful to understand what user and tables are driving most resource usage at any point in time.

Arguments:
  database_name - database name to analyze
  user_name - user name to analyze


- `base_columnDescription` (tool): 
Shows detailed column information about a database table via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name
  obj_name - table or view name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableAffinity` (tool): 
Get tables commonly used together by database users, this is helpful to infer relationships between tables via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name
  object_name - table or view name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableDDL` (tool): 
Displays the DDL definition of a table via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name
  table_name - table name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tablePreview` (tool): 
This function returns data sample and inferred structure from a database table or view via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  table_name - table or view name
  database_name - Database name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableUsage` (tool): 
Measure the usage of a table and views by users in a given schema, this is helpful to infer what database objects are most actively used or drive most value via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableList` (tool): Lists all tables in a database.
  - Arguments:
    - `database_name` (string, optional): No description.
--- Category: Usage Tracking ---
- `dba_featureUsage` (tool): Get the user feature usage metrics for a specified date range.
  - Arguments:
    - `start_date` (string, optional): No description.
    - `end_date` (string, optional): No description.
--- Category: User Management ---
- `dba_userSqlList` (tool): 
Get a list of SQL run by a user in the last number of days if a user name is provided, otherwise get list of all SQL in the last number of days.

Arguments:
  user_name - user name
  no_days - number of days

Returns:
  ResponseType: formatted response with query results + metadata

- `cust_activeUsers` (tool): Fetch currently active database users
--- Category: Utilities ---
- `tmpl_nameOfTool` (tool): 
<description of what the tool is for>

Arguments:
  arguments - arguments to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `evs_similarity_search` (tool): 
Enterprise Vector Store similarity search

Arguments:
  question - the query string to search for
  top_k - number of top results to return

Returns:
  ResponseType: formatted response with query results + metadata

- `rag_executeWorkflow` (tool): 
Execute complete RAG workflow to answer user questions based on document context.


This function handles the entire RAG pipeline:
1. Configuration setup (using configurable values from rag_config.yml)
2. Store user query (with /rag prefix stripping)
3. Generate query embeddings (tokenization + embedding)
4. Perform semantic search against chunk embeddings
5. Return retrieved context chunks for answer generation

The function uses configuration values from rag_config.yml with fallback defaults.

Arguments:
  question - user question to process
  k - number of top-k results to return (optional, uses config default if not provided)

Returns:
  Returns the top-k most relevant chunks with metadata for context-grounded answer generation.

- `rag_executeWorkflow_ivsm` (tool): 
Execute complete RAG workflow to answer user questions based on document context.

This function handles the entire RAG pipeline using IVSM functions:
1. Configuration setup (using configurable values from rag_config.yml)
2. Store user query (with /rag prefix stripping)
3. Tokenize query using ivsm.tokenizer_encode
4. Create embedding view using ivsm.IVSM_score
5. Convert embeddings to vector columns using ivsm.vector_to_columns
6. Perform semantic search against chunk embeddings

The function uses configuration values from rag_config.yml with fallback defaults.

Arguments:
  question - user question to process
  k - number of top-k results to return (optional, uses config default if not provided

Returns:
  Returns the top-k most relevant chunks with metadata for context-grounded answer generation.

- `util_getCurrentDate` (tool): Returns the current system date in YYYY-MM-DD format. Use this as the first step for any user query involving relative dates like 'today', 'yesterday', or 'this week'.
- `util_calculateDateRange` (tool): Calculates a list of dates based on a start date and a natural language phrase (e.g., 'past 3 days', 'last week'). This is a necessary second step for multi-day queries.
  - Arguments:
    - `start_date` (string, required): The anchor date for the calculation, usually today's date from `util_getCurrentDate`. Must be in YYYY-MM-DD format.
    - `date_phrase` (string, required): The natural language phrase describing the desired range (e.g., 'past 3 days', 'last 2 weeks').
- `CoreLLMTask` (tool): Performs internal, LLM-driven tasks that are not direct calls to the Teradata database. This tool is used for text synthesis, summarization, and formatting based on a specific 'task_description' provided by the LLM itself.
  - Arguments:
    - `task_description` (string, required): A natural language description of the internal task to be executed (e.g., 'describe the table in a business context', 'format final output'). The LLM infers this from the workflow plan.
    - `source_data` (list[string], required): A list of keys (e.g., 'result_of_phase_1') identifying which data from the workflow history is relevant for this task. This is critical for providing the correct context.
--- Available Prompts ---
--- Category: Prompts ---
- `base_query` (prompt): Help users interact with  Teradata databases effectively.
  - Arguments:
    - `query` (str, required): The problem or question that needs to be solved using Teradata database tools.
- `base_tableBusinessDesc` (prompt): You are a Teradata DBA who is an expert in describing the business use of tables in a database.
  - Arguments:
    - `database_name` (str, required): Database for the table to describe.
    - `table_name` (str, required): Table to describe.


USER PROMPT:

You are an expert strategic planning assistant. Your task is to analyze a user's request or a complex workflow goal and decompose it into a high-level, phased meta-plan. This plan will serve as a state machine executor.

--- GOAL ---
what is the system utilization of the past 2 weeks?

--- CONTEXT ---
- User's Original Question (for reference): what is the system utilization of the past 2 weeks?

--- INSTRUCTIONS ---
1.  **Analyze the Goal**: Carefully read the "GOAL" to understand the user's full intent.
2.  **Decompose into Phases**: Break down the overall goal into a sequence of logical phases. Each phase should represent a major step.
3.  **Define Each Phase**: For each phase, create a JSON object with the following keys:
    -   `"phase"`: An integer representing the step number (e.g., 1, 2, 3).
    -   `"goal"`: A clear, concise, and actionable description of what must be accomplished in this phase. This goal will guide a separate, tactical LLM.
    -   `"relevant_tools"`: A list of tool names that are permitted to be used during this phase. You MUST select the most appropriate and specific tools from the full "Capabilities" list provided in the main system prompt to achieve the phase's goal.
    -   (Optional) `"type": "loop"`: If a phase requires iterating over a list of items, you MUST include this key.
    -   (Optional) `"loop_over"`: If `"type"` is `"loop"`, specify the data source for the iteration (e.g., `"result_of_phase_1"`).
4.  **Embed Parameters**: When defining the `"goal"` for a phase, you MUST scan the main "GOAL" for any hardcoded arguments or parameters (e.g., table names, database names) relevant to that phase's task. You MUST embed these found parameters directly into the `"goal"` string to make it self-contained and explicit.
5.  **Final Synthesis and Formatting Phase**: If the main "GOAL" describes a multi-step process with a final reporting requirement, your plan **MUST** conclude with a single, final phase that handles both the synthesis of the final report AND its formatting. The `relevant_tools` for this final phase **MUST** be `["CoreLLMTask"]`.
6.  **CRITICAL RULE (Simplicity)**: If the "GOAL" is a simple, direct request that can be answered with a single tool call (e.g., "list all databases", "what is the system utilization?"), your plan **MUST** consist of only a single phase that calls the one most appropriate tool. Do not add unnecessary synthesis phases for simple data retrieval.
7.  **CRITICAL RULE (Execution Focus)**: Every phase you define **MUST** correspond to a concrete, tool-based action. You **MUST NOT** create phases for simple verification, confirmation, or acknowledgement of known information. Your plan must focus only on the execution steps required to gather new information or process existing data.
8.  **CRITICAL RULE (Capability Types)**: You are generating a plan of executable **tools**. The `relevant_tools` list **MUST ONLY** contain names of capabilities that are explicitly marked as `(tool)` in the system's "Capabilities" list. You **MUST NOT** include the name of any capability marked as `(prompt)`.
9.  **CRITICAL RULE (Efficiency)**: If a phase's `"goal"` already contains all the instructions for the final synthesis and formatting of the report (as specified in the main "GOAL"), you **MUST** make this the last phase of the plan. Do not add a separate, redundant formatting-only phase after it.

--- EXAMPLE (Complex Goal) ---
If the main goal requires getting DDL and then describing/formatting, your output should be a two-phase plan like this:
```json
[
  {
    "phase": 1,
    "goal": "Get the DDL for the table 'customers' in database 'sales' using the `base_tableDDL` tool.",
    "relevant_tools": ["base_tableDDL"]
  },
  {
    "phase": 2,
    "goal": "Synthesize a final report by describing the 'customers' table in a business context and format the output as markdown according to the Final output guidelines, using `***` for keys.",
    "relevant_tools": ["CoreLLMTask"]
  }
]
```

--- EXAMPLE (Simple Goal) ---
If the main goal is "what is the system utilization?", your output should be a single-phase plan like this:
```json
[
  {
    "phase": 1,
    "goal": "Get the system utilization using the `dba_resusageSummary` tool.",
    "relevant_tools": ["dba_resusageSummary"]
  }
]
```

--- EXAMPLE (Date Range Goal) ---
If the main goal is "what is the system utilization for the past 3 days?", your output must be a three-phase plan like this:
```json
[
  {
    "phase": 1,
    "goal": "Get the current date using the `util_getCurrentDate` tool to establish a reference point.",
    "relevant_tools": ["util_getCurrentDate"]
  },
  {
    "phase": 2,
    "goal": "Calculate the list of dates for 'the past 3 days' using the `util_calculateDateRange` tool.",
    "relevant_tools": ["util_calculateDateRange"]
  },
  {
    "phase": 3,
    "goal": "For each date calculated in the previous step, get the system utilization using the `dba_resusageSummary` tool.",
    "relevant_tools": ["dba_resusageSummary"],
    "type": "loop",
    "loop_over": "result_of_phase_2"
  }
]
```

Your response MUST be a single, valid JSON list of phase objects. Do NOT add any extra text, conversation, or markdown.

[model]: ```json
[
  {
    "phase": 1,
    "goal": "Get the current date using the `util_getCurrentDate` tool to establish a reference point.",
    "relevant_tools": ["util_getCurrentDate"]
  },
  {
    "phase": 2,
    "goal": "Calculate the list of dates for 'past 2 weeks' using the `util_calculateDateRange` tool.",
    "relevant_tools": ["util_calculateDateRange"]
  },
  {
    "phase": 3,
    "goal": "For each date calculated in the previous step, get the system utilization using the `dba_resusageSummary` tool.",
    "relevant_tools": ["dba_resusageSummary"],
    "type": "loop",
    "loop_over": "result_of_phase_2"
  }
]
```
[user]: SYSTEM PROMPT:

You are a tactical assistant executing a single phase of a larger plan. Your task is to decide the single best next action to take to achieve the current phase's goal, strictly adhering to the provided tool constraints.

--- OVERALL WORKFLOW GOAL ---
what is the system utilization of the past 2 weeks?

--- CURRENT PHASE GOAL ---
Get the current date using the `util_getCurrentDate` tool to establish a reference point.

--- CONSTRAINTS ---
- Permitted Tools for this Phase (You MUST use the exact argument names provided):

- Tool: `util_getCurrentDate`
  - Description: Returns the current system date in YYYY-MM-DD format. Use this as the first step for any user query involving relative dates like 'today', 'yesterday', or 'this week'.

- Previous Attempt (if any): None

--- WORKFLOW STATE & HISTORY ---
- Actions Taken So Far: []
- Data Collected So Far: {}

--- INSTRUCTIONS ---
1.  **Analyze the State**: Review the "CURRENT PHASE GOAL" and the "WORKFLOW STATE & HISTORY" to understand what has been done and what is needed next.
2.  **CRITICAL RULE (Tool Selection & Arguments)**: You **MUST** select your next action from the list of "Permitted Tools for this Phase". You are not allowed to use any other tool. Furthermore, you **MUST** use the exact argument names as they are defined in the tool details above. You **MUST NOT** invent, hallucinate, or use any arguments that are not explicitly listed in the definitions.
3.  **Self-Correction**: If a "Previous Attempt" is noted in the "CONSTRAINTS" section, it means your last choice was invalid. You **MUST** analyze the error and choose a different, valid tool from the permitted list. Do not repeat the invalid choice.
4.  **CoreLLMTask Usage**:
    -   For any task that involves synthesis, analysis, description, or summarization, you **MUST** use the `CoreLLMTask` tool, but only if it is in the permitted tools list.
    -   When calling `CoreLLMTask`, you **MUST** provide the `task_description` argument.
    -   Crucially, you **MUST** also determine which previous phase results are necessary for the task. You **MUST** provide these as a list of strings in the `source_data` argument.
    -   **CONTEXT PRESERVATION RULE**: If the current phase involves creating a final summary or report for the user, you **MUST** ensure you have all the necessary context. Your `source_data` list **MUST** include the results from **ALL** previous data-gathering phases (e.g., `["result_of_phase_1", "result_of_phase_2"]`) to prevent information loss.
5.  **Handle Loops**: If you are in a looping phase (indicated by the presence of a "LOOP CONTEXT" section), you **MUST** focus your action on the single item provided in `current_loop_item`. You **MUST** use the information within that item to formulate the arguments for your tool call.
6.  **Format Response**: Your response MUST be a single JSON object for a tool call.

Your response MUST be a single, valid JSON object for a tool call. Do NOT add any extra text or conversation.


USER PROMPT:
Determine the next action based on the instructions and state provided in the system prompt.
[model]: ```json
{"tool_name": "util_getCurrentDate", "arguments": {}}
```
[user]: SYSTEM PROMPT:

You are a tactical assistant executing a single phase of a larger plan. Your task is to decide the single best next action to take to achieve the current phase's goal, strictly adhering to the provided tool constraints.

--- OVERALL WORKFLOW GOAL ---
what is the system utilization of the past 2 weeks?

--- CURRENT PHASE GOAL ---
Calculate the list of dates for 'past 2 weeks' using the `util_calculateDateRange` tool.

--- CONSTRAINTS ---
- Permitted Tools for this Phase (You MUST use the exact argument names provided):

- Tool: `util_calculateDateRange`
  - Description: Calculates a list of dates based on a start date and a natural language phrase (e.g., 'past 3 days', 'last week'). This is a necessary second step for multi-day queries.
  - Arguments:
    - `start_date` (string, required): The anchor date for the calculation, usually today's date from `util_getCurrentDate`. Must be in YYYY-MM-DD format.
    - `date_phrase` (string, required): The natural language phrase describing the desired range (e.g., 'past 3 days', 'last 2 weeks').

- Previous Attempt (if any): None

--- WORKFLOW STATE & HISTORY ---
- Actions Taken So Far: [
  {
    "action": {
      "tool_name": "util_getCurrentDate",
      "arguments": {}
    },
    "result": {
      "status": "success",
      "metadata": {
        "tool_name": "util_getCurrentDate"
      },
      "results": [
        {
          "current_date": "2025-08-21"
        }
      ]
    }
  }
]
- Data Collected So Far: {
  "result_of_phase_1": [
    {
      "status": "success",
      "metadata": {
        "tool_name": "util_getCurrentDate"
      },
      "results": [
        {
          "current_date": "2025-08-21"
        }
      ]
    }
  ]
}

--- INSTRUCTIONS ---
1.  **Analyze the State**: Review the "CURRENT PHASE GOAL" and the "WORKFLOW STATE & HISTORY" to understand what has been done and what is needed next.
2.  **CRITICAL RULE (Tool Selection & Arguments)**: You **MUST** select your next action from the list of "Permitted Tools for this Phase". You are not allowed to use any other tool. Furthermore, you **MUST** use the exact argument names as they are defined in the tool details above. You **MUST NOT** invent, hallucinate, or use any arguments that are not explicitly listed in the definitions.
3.  **Self-Correction**: If a "Previous Attempt" is noted in the "CONSTRAINTS" section, it means your last choice was invalid. You **MUST** analyze the error and choose a different, valid tool from the permitted list. Do not repeat the invalid choice.
4.  **CoreLLMTask Usage**:
    -   For any task that involves synthesis, analysis, description, or summarization, you **MUST** use the `CoreLLMTask` tool, but only if it is in the permitted tools list.
    -   When calling `CoreLLMTask`, you **MUST** provide the `task_description` argument.
    -   Crucially, you **MUST** also determine which previous phase results are necessary for the task. You **MUST** provide these as a list of strings in the `source_data` argument.
    -   **CONTEXT PRESERVATION RULE**: If the current phase involves creating a final summary or report for the user, you **MUST** ensure you have all the necessary context. Your `source_data` list **MUST** include the results from **ALL** previous data-gathering phases (e.g., `["result_of_phase_1", "result_of_phase_2"]`) to prevent information loss.
5.  **Handle Loops**: If you are in a looping phase (indicated by the presence of a "LOOP CONTEXT" section), you **MUST** focus your action on the single item provided in `current_loop_item`. You **MUST** use the information within that item to formulate the arguments for your tool call.
6.  **Format Response**: Your response MUST be a single JSON object for a tool call.

Your response MUST be a single, valid JSON object for a tool call. Do NOT add any extra text or conversation.


USER PROMPT:
Determine the next action based on the instructions and state provided in the system prompt.
[model]: ```json
{"tool_name": "util_calculateDateRange", "arguments": {"start_date": "2025-08-21", "date_phrase": "past 2 weeks"}}
```

--- Current User Prompt (with System Prompt) ---
SYSTEM PROMPT:

# Core Directives
You are a specialized assistant for a Teradata database system. Your primary goal is to fulfill user requests by selecting the best capability (a tool or a prompt) from the categorized lists provided and supplying all necessary arguments.

# Response Format
Your response MUST be a single JSON object for a tool/prompt call OR a single plain text string for a final answer.

1.  **Tool/Prompt Calls (JSON format):**
    -   If the capability is a prompt, you MUST use the key `"prompt_name"`.
    -   If the capability is a tool, you MUST use the key `"tool_name"`.
    -   Provide all required arguments. Infer values from the conversation history if necessary.
    -   Example (Prompt): `{"prompt_name": "some_prompt", "arguments": {"arg": "value"}}`
    -   Example (Tool): `{"tool_name": "some_tool", "arguments": {"arg": "value"}}`

2.  **Final Answer (Plain Text format):**
    -   When you have sufficient information to fully answer the user's request, you MUST stop using tools.
    -   Your response MUST begin with the exact prefix `FINAL_ANSWER:`, followed by a natural language summary.
    -   Example: `FINAL_ANSWER: I found 48 databases on the system. The details are displayed below.`

# Decision Process
To select the correct capability, you MUST follow this two-step process, governed by one critical rule:

**CRITICAL RULE: Prioritize Specificity and Arguments.** Your primary filter for selecting a capability is its specificity. You MUST select the most granular capability that uses the most entities from the user's request (e.g., prefer a tool that uses a `table_name` over one that only uses a `database_name` if a table is mentioned). For direct actions and single analyses, you MUST select a `tool_name`; only select a `prompt_name` for broad, multi-step tasks explicitly described by the prompt.

1.  **Identify the Category:** First, analyze the user's request to determine which Tool or Prompt Category is the most relevant to their intent. The available categories are listed in the "Capabilities" section below.
2.  **Select the Capability:** Second, from within that single most relevant category, select the best tool or prompt to fulfill the request, adhering to the Critical Rule above.

# Few-Shot Examples
Here are examples of the correct thinking process:

**Example 1:**
- **User Query:** "what is the quality of table 'online' in database 'DEMO_Customer360_db'?"
- **Thought Process:**
    1.  The user's query is about a **table**.
    2.  My critical rule is to prioritize specificity. I must choose a table-level tool.
    3.  The `qlty_databaseQuality` prompt is for databases, not specific tables, so it's incorrect.
    4.  The `qlty_columnSummary` tool takes a `table_name` and is the most specific, correct choice.
- **Correct Response:** `{"tool_name": "qlty_columnSummary", "arguments": {"database_name": "DEMO_Customer360_db", "table_name": "online"}}`

**Example 2:**
- **User Query:** "describe the business purpose of the 'DEMO_Customer360_db' database"
- **Thought Process:**
    1.  The user's query is about a **database**. It's a broad request ("describe").
    2.  A prompt is better for broad tasks.
    3.  The `base_databaseBusinessDesc` prompt takes a `database_name` and is the correct choice.
- **Correct Response:** `{"prompt_name": "base_databaseBusinessDesc", "arguments": {"database_name": "DEMO_Customer360_db"}}`

**Example 3:**
- **User Query:** "what is the system utilization?"
- **Thought Process:**
    1.  The user is asking for a specific metric: "system utilization". This is a direct request for data.
    2.  My critical rule states I must prioritize a `tool_name` for direct actions.
    3.  The `dba_systemVoice` prompt is for adopting a persona, not for fetching specific metrics. It is the incorrect choice.
    4.  The `dba_resusageSummary` tool in the `Performance` category is designed to get system usage summary metrics. This is the correct choice.
- **Correct Response:** `{"tool_name": "dba_resusageSummary", "arguments": {}}`

# Best Practices
- **Context is Key:** Always use information from previous turns to fill in arguments like `db_name` or `table_name`.
- **Error Recovery:** If a tool fails, analyze the error message and attempt to call the tool again with corrected parameters. Only ask the user for clarification if you cannot recover.
- **SQL Generation:** When using the `base_readQuery` tool, you MUST use fully qualified table names in your SQL (e.g., `SELECT ... FROM my_database.my_table`).
- **Time-Sensitive Queries:** For queries involving relative dates (e.g., 'today', 'this week'), you MUST use the `util_getCurrentDate` tool first to determine the current date before proceeding.
- **Out of Scope:** If the user's request is unrelated to the available capabilities, respond with a `FINAL_ANSWER:` that politely explains you cannot fulfill the request and restates your purpose.
- **CRITICAL: Avoid Repetitive Behavior.** You are a highly intelligent agent. Do not get stuck in a loop by repeating the same tool calls or by cycling through the same set of tools. Once a tool has returned a successful result with data that is relevant to the user's request, do not call that same tool again unless there is a new and compelling reason to do so. If you have called a series of tools and believe you have enough information, you must call a FINAL_ANSWER. Do not repeat tool calls just to be "through".


# Capabilities
--- Available Tools ---
--- Category: Data Quality ---
- `qlty_columnSummary` (tool): 
Get the column summary statistics for a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_distinctCategories` (tool): 
Get the destinct categories from column in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_missingValues` (tool): 
Get the column names that having missing values in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_negativeValues` (tool): 
Get the column names that having negative values in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_rowsWithMissingValues` (tool): 
Get the rows with missing values in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_standardDeviation` (tool): 
Get the standard deviation from column in a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `qlty_univariateStatistics` (tool): 
Get the univariate statistics for a table.

Arguments:
  database_name - name of the database
  table_name - table name to analyze
  column_name - column name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

--- Category: Data Visualization ---
- `viz_createChart` (tool): Generates a data visualization based on provided data. You must specify the chart type and map the data fields to the appropriate visual roles.
  - Arguments:
    - `chart_type` (string, required): The type of chart to generate (e.g., 'bar', 'pie', 'line', 'scatter'). This MUST be one of the types listed in the 'Charting Guidelines'.
    - `data` (list[dict], required): The data to be visualized, passed directly from the output of another tool.
    - `title` (string, required): A descriptive title for the chart.
    - `mapping` (dict, required): A dictionary that maps data keys to chart axes or roles (e.g., {'x_axis': 'product_name', 'y_axis': 'sales_total'}). The required keys for this mapping depend on the selected chart_type.
--- Category: Database Information ---
- `cust_td_serverInfo` (tool): Get the Teradata software information: demonstrates how to use parameters for prepared statements.
  - Arguments:
    - `infokey` (string, optional): No description.
- `dba_databaseVersion` (tool):  Get Teradata database version information.
- `base_databaseList` (tool): Lists all databases in the Teradata System.
--- Category: Database Space ---
- `dba_databaseSpace` (tool): 
Get database space if database name is provided, otherwise get all databases space allocations.

Arguments:
  database_name - database name

Returns:
  ResponseType: formatted response with query results + metadata

- `get_cube_cust_cube_db_space_metrics` (tool): 
    Tool to query the cube 'table_skew_pct'.
    Get the Teradata database space metrics for tables and databases

    Expected inputs:
        dimensions (str): Comma-separated dimension names to group by. Allowed values:
    - DatabaseName: Name of the database
    - TableName: Name of the table

        measures (str): Comma-separated measure names to aggregate. Allowed values:
    - current_perm: Object perm space in bytes
    - peak_perm: Object peak perm space in bytes
    - table_skew_pct: Object skew percentage

        filters (str): Comma-separated filter expressions to apply to either dimensions or measures selected. The dimension or measure used must be in the dimension list to group by or measure list, use valid SQL expressions, for example:
DatabaseName = 'value'
TableName = 'value'
current_perm > 1000
peak_perm > 1000
table_skew_pct > 1000

    Returns:
        Query result as a formatted response.
    
  - Arguments:
    - `dimensions` (string, optional): No description.
    - `measures` (string, optional): No description.
    - `filters` (string, optional): No description.
- `dba_systemSpace` (tool): Get the Teradata total system database space usage.
--- Category: Performance ---
- `dba_resusageSummary` (tool): 
Get the Teradata system usage summary metrics by weekday and hour for each workload type and query complexity bucket.

Arguments:
  dimensions - list of dimensions to aggregate the resource usage summary. All dimensions are: ["LogDate", "hourOfDay", "dayOfWeek", "workloadType", "workloadComplexity", "UserName", "AppId", "StatementType"]
  user_name - user name
  date - Date to analyze, formatted as `YYYY-MM-DD`
  dayOfWeek - day of the week to analyze
  hourOfDay - hour of day to analyze


- `dba_flowControl` (tool): Get the Teradata flow control metrics for a specified date range.
  - Arguments:
    - `start_date` (string, optional): No description.
    - `end_date` (string, optional): No description.
- `dba_userDelay` (tool): Get the Teradata user delay metrics for a specified date range.
  - Arguments:
    - `start_date` (string, optional): No description.
    - `end_date` (string, optional): No description.
--- Category: Query Execution ---
- `base_readQuery` (tool): 
Execute a SQL query via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  sql    - SQL text, with optional bind-parameter placeholders

Returns:
  ResponseType: formatted response with query results + metadata

--- Category: Sales Analytics ---
- `sales_top_customers` (tool): Get the top 20 customers by lifetime value.
- `sales_customer_profile` (tool): Get customer profile and metrics.
  - Arguments:
    - `customer_key` (string, optional): No description.
- `get_cube_sales_cube` (tool): 
    Tool to query the cube 'order_count'.
    Get the key sales metrics: USD amount and number of orders.

    Expected inputs:
        dimensions (str): Comma-separated dimension names to group by. Allowed values:
    - customer_key: Key for the customer
    - sales_year: Year of the sale
    - sales_month: Month of the sale

        measures (str): Comma-separated measure names to aggregate. Allowed values:
    - gift_amount_usd: Total gift card amount used for the order in USD
    - total_amount_usd: Total order amount in USD
    - order_count: Total number of orders

        filters (str): Comma-separated filter expressions to apply to either dimensions or measures selected. The dimension or measure used must be in the dimension list to group by or measure list, use valid SQL expressions, for example:
customer_key = 'value'
sales_year = 'value'
sales_month = 'value'
gift_amount_usd > 1000
total_amount_usd > 1000
order_count > 1000

    Returns:
        Query result as a formatted response.
    
  - Arguments:
    - `dimensions` (string, optional): No description.
    - `measures` (string, optional): No description.
    - `filters` (string, optional): No description.
--- Category: Security ---
- `sec_rolePermissions` (tool): 
Get permissions for a role.

Arguments:
  role_name - role name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `sec_userDbPermissions` (tool): 
Get permissions for a user.

Arguments:
  user_name - user name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `sec_userRoles` (tool): 
Get roles assigned to a user.

Arguments:
  user_name - user name to analyze

Returns:
  ResponseType: formatted response with query results + metadata

--- Category: Session Management ---
- `dba_sessionInfo` (tool): Get the Teradata session information for user.
  - Arguments:
    - `user_name` (string, optional): No description.
--- Category: Table Management ---
- `dba_tableSpace` (tool): 
Get table space used for a table if table name is provided or get table space for all tables in a database if a database name is provided."

Arguments:
  database_name - database name
  table_name - table name

Returns:
  ResponseType: formatted response with query results + metadata

- `dba_tableSqlList` (tool): 
Get a list of SQL run against a table in the last number of days.

Arguments:
  table_name - table name
  no_days - number of days

Returns:
  ResponseType: formatted response with query results + metadata

- `dba_tableUsageImpact` (tool): 
Measure the usage of a table and views by users, this is helpful to understand what user and tables are driving most resource usage at any point in time.

Arguments:
  database_name - database name to analyze
  user_name - user name to analyze


- `base_columnDescription` (tool): 
Shows detailed column information about a database table via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name
  obj_name - table or view name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableAffinity` (tool): 
Get tables commonly used together by database users, this is helpful to infer relationships between tables via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name
  object_name - table or view name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableDDL` (tool): 
Displays the DDL definition of a table via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name
  table_name - table name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tablePreview` (tool): 
This function returns data sample and inferred structure from a database table or view via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  table_name - table or view name
  database_name - Database name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableUsage` (tool): 
Measure the usage of a table and views by users in a given schema, this is helpful to infer what database objects are most actively used or drive most value via SQLAlchemy, bind parameters if provided (prepared SQL), and return the fully rendered SQL (with literals) in metadata.

Arguments:
  database_name - Database name

Returns:
  ResponseType: formatted response with query results + metadata

- `base_tableList` (tool): Lists all tables in a database.
  - Arguments:
    - `database_name` (string, optional): No description.
--- Category: Usage Tracking ---
- `dba_featureUsage` (tool): Get the user feature usage metrics for a specified date range.
  - Arguments:
    - `start_date` (string, optional): No description.
    - `end_date` (string, optional): No description.
--- Category: User Management ---
- `dba_userSqlList` (tool): 
Get a list of SQL run by a user in the last number of days if a user name is provided, otherwise get list of all SQL in the last number of days.

Arguments:
  user_name - user name
  no_days - number of days

Returns:
  ResponseType: formatted response with query results + metadata

- `cust_activeUsers` (tool): Fetch currently active database users
--- Category: Utilities ---
- `tmpl_nameOfTool` (tool): 
<description of what the tool is for>

Arguments:
  arguments - arguments to analyze

Returns:
  ResponseType: formatted response with query results + metadata

- `evs_similarity_search` (tool): 
Enterprise Vector Store similarity search

Arguments:
  question - the query string to search for
  top_k - number of top results to return

Returns:
  ResponseType: formatted response with query results + metadata

- `rag_executeWorkflow` (tool): 
Execute complete RAG workflow to answer user questions based on document context.


This function handles the entire RAG pipeline:
1. Configuration setup (using configurable values from rag_config.yml)
2. Store user query (with /rag prefix stripping)
3. Generate query embeddings (tokenization + embedding)
4. Perform semantic search against chunk embeddings
5. Return retrieved context chunks for answer generation

The function uses configuration values from rag_config.yml with fallback defaults.

Arguments:
  question - user question to process
  k - number of top-k results to return (optional, uses config default if not provided)

Returns:
  Returns the top-k most relevant chunks with metadata for context-grounded answer generation.

- `rag_executeWorkflow_ivsm` (tool): 
Execute complete RAG workflow to answer user questions based on document context.

This function handles the entire RAG pipeline using IVSM functions:
1. Configuration setup (using configurable values from rag_config.yml)
2. Store user query (with /rag prefix stripping)
3. Tokenize query using ivsm.tokenizer_encode
4. Create embedding view using ivsm.IVSM_score
5. Convert embeddings to vector columns using ivsm.vector_to_columns
6. Perform semantic search against chunk embeddings

The function uses configuration values from rag_config.yml with fallback defaults.

Arguments:
  question - user question to process
  k - number of top-k results to return (optional, uses config default if not provided

Returns:
  Returns the top-k most relevant chunks with metadata for context-grounded answer generation.

- `util_getCurrentDate` (tool): Returns the current system date in YYYY-MM-DD format. Use this as the first step for any user query involving relative dates like 'today', 'yesterday', or 'this week'.
- `util_calculateDateRange` (tool): Calculates a list of dates based on a start date and a natural language phrase (e.g., 'past 3 days', 'last week'). This is a necessary second step for multi-day queries.
  - Arguments:
    - `start_date` (string, required): The anchor date for the calculation, usually today's date from `util_getCurrentDate`. Must be in YYYY-MM-DD format.
    - `date_phrase` (string, required): The natural language phrase describing the desired range (e.g., 'past 3 days', 'last 2 weeks').
- `CoreLLMTask` (tool): Performs internal, LLM-driven tasks that are not direct calls to the Teradata database. This tool is used for text synthesis, summarization, and formatting based on a specific 'task_description' provided by the LLM itself.
  - Arguments:
    - `task_description` (string, required): A natural language description of the internal task to be executed (e.g., 'describe the table in a business context', 'format final output'). The LLM infers this from the workflow plan.
    - `source_data` (list[string], required): A list of keys (e.g., 'result_of_phase_1') identifying which data from the workflow history is relevant for this task. This is critical for providing the correct context.
--- Available Prompts ---
--- Category: Prompts ---
- `base_query` (prompt): Help users interact with  Teradata databases effectively.
  - Arguments:
    - `query` (str, required): The problem or question that needs to be solved using Teradata database tools.
- `base_tableBusinessDesc` (prompt): You are a Teradata DBA who is an expert in describing the business use of tables in a database.
  - Arguments:
    - `database_name` (str, required): Database for the table to describe.
    - `table_name` (str, required): Table to describe.


USER PROMPT:
You are an expert data analyst. Synthesize all collected data into a clear, concise, and insightful final answer.

--- USER'S QUESTION ---
'what is the system utilization of the past 2 weeks?'

--- DATA COLLECTED ---
```json
[
  {
    "status": "success",
    "metadata": {
      "tool_name": "util_getCurrentDate"
    },
    "results": [
      {
        "current_date": "2025-08-21"
      }
    ]
  },
  {
    "status": "success",
    "metadata": {
      "tool_name": "util_calculateDateRange"
    },
    "results": [
      {
        "date": "2025-08-04"
      },
      {
        "date": "2025-08-05"
      },
      {
        "date": "2025-08-06"
      },
      {
        "date": "2025-08-07"
      },
      {
        "date": "2025-08-08"
      },
      {
        "date": "2025-08-09"
      },
      {
        "date": "2025-08-10"
      },
      {
        "date": "2025-08-11"
      },
      {
        "date": "2025-08-12"
      },
      {
        "date": "2025-08-13"
      },
      {
        "date": "2025-08-14"
      },
      {
        "date": "2025-08-15"
      },
      {
        "date": "2025-08-16"
      },
      {
        "date": "2025-08-17"
      }
    ]
  },
  {
    "status": "success",
    "metadata": {
      "tool_name": "dba_resusageSummary",
      "total_rows": 1,
      "comment": "Total system resource usage summary."
    },
    "results": [
      {
        "Request Count": "0",
        "Total AMPCPUTime": "None",
        "Total IOCount": "None",
        "Total ReqIOKB": "None",
        "Total ReqPhysIO": "None",
        "Total ReqPhysIOKB": "None",
        "Total ReqIO GB": "None",
        "Total ReqPhysIOGB": "None",
        "Total Server Byte Count": "None"
      }
    ]
  },
  {
    "status": "success",
    "metadata": {
      "tool_name": "dba_resusageSummary",
      "total_rows": 1,
      "comment": "Total system resource usage summary."
    },
    "results": [
      {
        "Request Count": "0",
        "Total AMPCPUTime": "None",
        "Total IOCount": "None",
        "Total ReqIOKB": "None",
        "Total ReqPhysIO": "None",
        "Total ReqPhysIOKB": "None",
        "Total ReqIO GB": "None",
        "Total ReqPhysIOGB": "None",
        "Total Server Byte Count": "None"
      }
    ]
  },
  {
    "status": "success",
    "metadata": {
      "tool_name": "dba_resusageSummary",
      "total_rows": 1,
      "comment": "Total system resource usage summary."
    },
    "results": [
      {
        "Request Count": "0",
        "Total AMPCPUTime": "None",
        "Total IOCount": "None",
        "Total ReqIOKB": "None",
        "Total ReqPhysIO": "None",
        "Total ReqPhysIOKB": "None",
        "Total ReqIO GB": "None",
        "Total ReqPhysIOGB": "None",
        "Total Server Byte Count": "None"
      }
    ]
  },
  {
    "status": "success",
    "metadata": {
      "tool_name": "dba_resusageSummary",
      "total_rows": 1,
      "comment": "Total system resource usage summary."
    },
    "results": [
      {
        "Request Count": "0",
        "Total AMPCPUTime": "None",
        "Total IOCount": "None",
        "Total ReqIOKB": "None",
        "Total ReqPhysIO": "None",
        "Total ReqPhysIOKB": "None",
        "Total ReqIO GB": "None",
        "Total ReqPhysIOGB": "None",
        "Total Server Byte Count": "None"
      }
    ]
  },
  {
    "status": "success",
    "metadata": {
      "tool_name": "dba_resusageSummary",
      "total_rows": 1,
      "comment": "Total system resource usage summary."
    },
    "results": [
      {
        "Request Count": "0",
        "Total AMPCPUTime": "None",
        "Total IOCount": "None",
        "Total ReqIOKB": "None",
        "Total ReqPhysIO": "None",
        "Total ReqPhysIOKB": "None",
        "Total ReqIO GB": "None",
        "Total ReqPhysIOGB": "None",
        "Total Server Byte Count": "None"
      }
    ]
  },
  {
    "status": "success",
    "metadata": {
      "tool_name": "dba_resusageSummary",
      "total_rows": 1,
      "comment": "Total system resource usage summary."
    },
    "results": [
      {
        "Request Count": "0",
        "Total AMPCPUTime": "None",
        "Total IOCount": "None",
        "Total ReqIOKB": "None",
        "Total ReqPhysIO": "None",
        "Total ReqPhysIOKB": "None",
        "Total ReqIO GB": "None",
        "Total ReqPhysIOGB": "None",
        "Total Server Byte Count": "None"
      }
    ]
  },
  {
    "status": "success",
    "metadata": {
      "tool_name": "dba_resusageSummary",
      "total_rows": 1,
      "comment": "Total system resource usage summary."
    },
    "results": [
      {
        "Request Count": "0",
        "Total AMPCPUTime": "None",
        "Total IOCount": "None",
        "Total ReqIOKB": "None",
        "Total ReqPhysIO": "None",
        "Total ReqPhysIOKB": "None",
        "Total ReqIO GB": "None",
        "Total ReqPhysIOGB": "None",
        "Total Server Byte Count": "None"
      }
    ]
  },
  {
    "status": "success",
    "metadata": {
      "tool_name": "dba_resusageSummary",
      "total_rows": 1,
      "comment": "Total system resource usage summary."
    },
    "results": [
      {
        "Request Count": "0",
        "Total AMPCPUTime": "None",
        "Total IOCount": "None",
        "Total ReqIOKB": "None",
        "Total ReqPhysIO": "None",
        "Total ReqPhysIOKB": "None",
        "Total ReqIO GB": "None",
        "Total ReqPhysIOGB": "None",
        "Total Server Byte Count": "None"
      }
    ]
  },
  {
    "status": "success",
    "metadata": {
      "tool_name": "dba_resusageSummary",
      "total_rows": 1,
      "comment": "Total system resource usage summary."
    },
    "results": [
      {
        "Request Count": "0",
        "Total AMPCPUTime": "None",
        "Total IOCount": "None",
        "Total ReqIOKB": "None",
        "Total ReqPhysIO": "None",
        "Total ReqPhysIOKB": "None",
        "Total ReqIO GB": "None",
        "Total ReqPhysIOGB": "None",
        "Total Server Byte Count": "None"
      }
    ]
  },
  {
    "status": "success",
    "metadata": {
      "tool_name": "dba_resusageSummary",
      "total_rows": 1,
      "comment": "Total system resource usage summary."
    },
    "results": [
      {
        "Request Count": "138",
        "Total AMPCPUTime": "0.7680000000000001",
        "Total IOCount": "8079.0",
        "Total ReqIOKB": "400616.0",
        "Total ReqPhysIO": "72.0",
        "Total ReqPhysIOKB": "1632.0",
        "Total ReqIO GB": "0.38205718994140625",
        "Total ReqPhysIOGB": "0.001556396484375",
        "Total Server Byte Count": "0"
      }
    ]
  },
  {
    "status": "success",
    "metadata": {
      "tool_name": "dba_resusageSummary",
      "total_rows": 1,
      "comment": "Total system resource usage summary."
    },
    "results": [
      {
        "Request Count": "493",
        "Total AMPCPUTime": "0.3960000000000001",
        "Total IOCount": "2520.0",
        "Total ReqIOKB": "97596.0",
        "Total ReqPhysIO": "336.0",
        "Total ReqPhysIOKB": "10304.0",
        "Total ReqIO GB": "0.09307479858398438",
        "Total ReqPhysIOGB": "0.00982666015625",
        "Total Server Byte Count": "0"
      }
    ]
  },
  {
    "status": "success",
    "metadata": {
      "tool_name": "dba_resusageSummary",
      "total_rows": 1,
      "comment": "Total system resource usage summary."
    },
    "results": [
      {
        "Request Count": "0",
        "Total AMPCPUTime": "None",
        "Total IOCount": "None",
        "Total ReqIOKB": "None",
        "Total ReqPhysIO": "None",
        "Total ReqPhysIOKB": "None",
        "Total ReqIO GB": "None",
        "Total ReqPhysIOGB": "None",
        "Total Server Byte Count": "None"
      }
    ]
  },
  {
    "status": "success",
    "metadata": {
      "tool_name": "dba_resusageSummary",
      "total_rows": 1,
      "comment": "Total system resource usage summary."
    },
    "results": [
      {
        "Request Count": "0",
        "Total AMPCPUTime": "None",
        "Total IOCount": "None",
        "Total ReqIOKB": "None",
        "Total ReqPhysIO": "None",
        "Total ReqPhysIOKB": "None",
        "Total ReqIO GB": "None",
        "Total ReqPhysIOGB": "None",
        "Total Server Byte Count": "None"
      }
    ]
  },
  {
    "status": "success",
    "metadata": {
      "tool_name": "dba_resusageSummary",
      "total_rows": 1,
      "comment": "Total system resource usage summary."
    },
    "results": [
      {
        "Request Count": "0",
        "Total AMPCPUTime": "None",
        "Total IOCount": "None",
        "Total ReqIOKB": "None",
        "Total ReqPhysIO": "None",
        "Total ReqPhysIOKB": "None",
        "Total ReqIO GB": "None",
        "Total ReqPhysIOGB": "None",
        "Total Server Byte Count": "None"
      }
    ]
  }
]
```

--- INSTRUCTIONS ---
1.  Provide a holistic analysis and actionable insights.
2.  Begin with a high-level summary, then use bullet points for key observations.
3.  Your entire response **MUST** begin with `FINAL_ANSWER:`.


2025-08-21 22:46:10,492 - --- RESPONSE ---
FINAL_ANSWER: The system utilization for the past 2 weeks (2025-08-04 to 2025-08-17) reveals sporadic resource usage. Many days show no resource consumption, while a few exhibit moderate activity.

*   **Days with No Resource Usage:** 2025-08-04, 2025-08-05, 2025-08-06, 2025-08-07, 2025-08-08, 2025-08-09, 2025-08-10, 2025-08-11, 2025-08-12, 2025-08-13, 2025-08-17: These dates show "None" for CPU time, I/O count, and other metrics, indicating minimal or no system activity during these periods.
*   **2025-08-15:** The system processed 138 requests, consuming 0.768 AMP CPU seconds and performing 8079 I/O operations, with a total of 400616 KB of I/O.
*   **2025-08-16:** The system processed 493 requests, consuming 0.396 AMP CPU seconds and performing 2520 I/O operations, with a total of 97596 KB of I/O.
*   **Inconsistent Activity:** The wide variation in resource utilization across the two-week period suggests inconsistent workloads or potential periods of system idleness. Further investigation into the specific applications or users active on 2025-08-15 and 2025-08-16 may provide insights into the reasons for the increased activity on those days.
--------------------------------------------------

